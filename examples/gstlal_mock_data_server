#!/usr/bin/env python
#
# Copyright (C) 2010 Leo Singer
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
"""
Advanced LIGO mock data server.

Produces mock data frames under the current working directory, as in:
./H1/H-H1_MOCK-0000/H-H1_MOCK-000000256-16.gwf

Also, if the --port option is provided, this program also deploys a TCP server
that provides 

To retrieve streaming h(t) and print as ASCII, try the following:
 1. Launch with the optional TCP server mode, as in:
   $ gstlal_mock_data_server --port 6000
 2. Launch the client pipeline with:
   $ gst-launch tcpclientsrc port=6000 ! gdpdepay ! lal_nxydump ! filesink location=/dev/stdout
"""
__author__ = "Leo Singer <leo.singer@ligo.org>"


#
# Parse command line options
#

from optparse import OptionParser, Option

opts, args = OptionParser(usage = "%prog [options]" + __doc__, option_list = [
	Option("--port", "-p", type="int", help="Enable streaming h(t) on this port."),
	Option("--instrument", "-i", default="H1", help="Name of instrument (default=H1)"),
]).parse_args()


#
# Late imports
#

from gstlal.pipeutil import *
from gstlal.lloidparts import mkelems_fast, LLOIDHandler
from pylal.Fr import frputvect
from gstlal.pipeio import array_from_audio_buffer
import os, os.path, errno


#
# Callback for writing frame files
#

# FIXME: replace this when Jordi finishes his frame-writing element.

# Output location parameters
namestem = opts.instrument[0] + '-' + opts.instrument + '_MOCK-'
channel_name = 'MOCK-STRAIN'
long_channel_name = '%s:%s' % (opts.instrument, channel_name)

# Sample rate, block size parameters
fs = 16384 # sample rate in Hz
unit_size = 8 # data unit size in bytes
frame_duration = 16 # frame file duration in seconds
max_streaming_buf_size = 1024 # max length in bytes for streaming buffers

# For streaming h(t), produce blocks that begin on integer nanosecond boundaries
# because these have exactly representable timestamps.
min_streaming_buf_size = unit_size * fs / gst.util_greatest_common_divisor(fs, gst.SECOND)
streaming_buf_size = (max_streaming_buf_size // min_streaming_buf_size) * min_streaming_buf_size

def appsink_new_buffer(elem):
	buf = elem.emit("pull-buffer")
	dirname = "%s/%s%04d" % (opts.instrument, namestem, buf.timestamp / (100000 * gst.SECOND))
	basename = "%s%09d-%d.gwf" % (namestem, buf.timestamp / gst.SECOND, buf.duration / gst.SECOND)
	path = os.path.join(dirname, basename)
	try:
		os.makedirs(dirname)
	except OSError, exc:
		if exc.errno != errno.EEXIST:
			raise
	framedict = {
		'name': long_channel_name,
		'data': array_from_audio_buffer(buf).flatten(),
		'start': buf.timestamp / float(gst.SECOND),
		'dx': 1. / buf.caps[0]['rate'],
		'x_unit': 'time',
		'y_unit': 'strain',
		'kind': 'ADC',
	}
	frputvect(path, (framedict,), 'generated by gstlal_mock_data_server')


#
# Build pipeline
#

pipeline = gst.Pipeline("mock_data_server")
mainloop = gobject.MainLoop()
handler = LLOIDHandler(mainloop, pipeline)

# Show debug messages from tcpserversink
gst.debug_set_threshold_for_name('tcpserversink', gst.LEVEL_DEBUG)

# Make mock h(t)
elems = mkelems_fast(pipeline,
	"lal_fakeadvligosrc",
	{
		"instrument": opts.instrument,
		"channel-name": channel_name,
		"blocksize": fs * frame_duration * unit_size,
	},
	"progressreport", {"name": "progress_hoft"},
	"tee")

# appsink for capturing buffers and writing them to frame files
mkelems_fast(pipeline, elems[-1], "queue", {"max-size-time": 0, "max-size-buffers": 2}, "appsink", {"emit-signals": True, "max-buffers": 1, "sync": opts.port is not None})[-1].connect_after("new-buffer", appsink_new_buffer)

# Create optional TCP server
if opts.port is not None:
	mkelems_fast(pipeline,
		elems[-1],
		"queue", {"max-size-time": 0, "max-size-buffers": 2},
		"lal_reblock",
		{
			"block-duration": streaming_buf_size / 8 * gst.SECOND / fs
		},
		"gdppay",
		"tcpserversink",
		{
			"port": opts.port,
			"sync-method": "latest-keyframe",
			"recover-policy": "keyframe",
			"unit-type": "bytes",
			"units-soft-max": 1024**3 # 1 gigabyte
		}
	)


#
# Run pipeline
#

pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
