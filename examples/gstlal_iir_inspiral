#!/usr/bin/env python
import sys
import scipy
import numpy
import pylab
from optparse import OptionParser
from gstlal.pipeio import repack_complex_array_to_real, repack_real_array_to_complex
from glue import segments
from pylal.datatypes import LIGOTimeGPS
from gstlal import ligolw_output
from pylal.xlal.datatypes.snglinspiraltable import from_buffer as sngl_inspirals_from_buffer

#
# a function for plotting multiple time series, used for debugging
# 

def plot(pipeline, pre_elems, title="gstlal"):
	elems = []
	elems.append(pipeutil.mkelem("queue", {"max-size-time": 2}))
	elems.append(pipeutil.mkelem("cairovis_waterfall", {"title": title, "z-autoscale": True, "colormap": "jet", "history": 10 * gst.SECOND}))
	elems.append(pipeutil.mkelem("capsfilter",{"caps": gst.Caps("video/x-raw-rgb,framerate=12/1,width=800,height=800")}))
	elems.append(pipeutil.mkelem("ximagesink",{"sync": False,"async": False,}))
	for elem in elems: pipeline.add(elem)
	elems = pre_elems + elems
	gst.element_link_many(*elems)

#
# A function for parsing command line
#

def parse_command_line():
	parser = OptionParser(description = __doc__)
	parser.add_option("--iir-bank", metavar = "filename", help = "Set the name of the LIGO light-weight XML file from which to load the iir template bank (required).")
	parser.add_option("--injections", metavar = "filename", help = "Set the name of the LIGO light-weight XML file from which to load the injections (optional).")
	parser.add_option("--gps-start-time", help="GPS start time (required)", type="float")
	parser.add_option("--gps-end-time", help="GPS end time (required)", type="float")
	parser.add_option("--frame-cache", help="frame-cache. If not specified fake data will be used", type="str")
	parser.add_option("--output", metavar = "filename", help = "Set the filename in which to save the triggers (required)")
	parser.add_option("--instrument", metavar="IFO", help="set the instrument default H1", default="H1")
	parser.add_option("--channel-name", metavar="channel", help="set the channel default LSC-STRAIN", default="LSC-STRAIN")
	parser.add_option("--tmp-space",  metavar="PATH")
	parser.add_option("--comment",  metavar="str")
	parser.add_option("--snr-threshold", metavar="float", help="SNR threshold default 5.5", default=5.5) 
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")
	
	options, filenames = parser.parse_args()

	fail = ""
	for option in ("iir_bank", "output", "gps_start_time", "gps_end_time"):
		if getattr(options, option) is None:
			fail += "must provide option %s\n" % (option)

	if fail: raise ValueError, fail
	
	effective_gps_start_time = LIGOTimeGPS(options.gps_start_time)
	effective_gps_end_time = LIGOTimeGPS(options.gps_end_time)

	process_params = ligolw_output.make_process_params(options) #FIXME override program name
	options.seg = segments.segment(effective_gps_start_time, effective_gps_end_time)

	return options, filenames, process_params

#
# Main
#

options, filenames, process_params = parse_command_line()

from gstlal import cbc_template_iir
from gstlal.reference_psd import read_psd
from glue.ligolw import utils, array, param
from gstlal import pipeutil
from gstlal.lloidparts import seek_event_for_gps, mkelems_fast
from gstlal.pipeutil import gobject, gst

#
# extract parameters from the bank
#

xmldoc = utils.load_filename(options.iir_bank, gz=options.iir_bank.endswith('.gz'))
A, B, D, autocor = cbc_template_iir.get_matrices_from_xml(xmldoc)
sample_rate = param.get_pyvalue(xmldoc, 'sample_rate')
flower = param.get_pyvalue(xmldoc, 'flower')
snr_threshold = options.snr_threshold

# dictionaries for elements
tee = {}
tee2 = {}
triggergen = {}
chisq = {}

# get the pipeline running
mainloop = gobject.MainLoop()
pipeline = gst.Pipeline("gstlal_iir_inspiral")

#
# setup the output stage FIXME move this to support multiple instruments
#

from gstlal.lloidparts import DetectorData

detectors = {
        options.instrument: DetectorData(options.frame_cache, options.channel_name)
}

options.out_seg = segments.segment(options.seg[0], options.seg[1]) #FIXME make better outseg def.
data = ligolw_output.Data(options, detectors)
data.prepare_output_file(process_params)

def appsink_new_buffer(elem, data):
	for row in sngl_inspirals_from_buffer(elem.get_property("last-buffer")):
		if (row.end_time + 1e-9*row.end_time_ns) in data.out_seg:
			row.process_id = data.process.process_id
			row.event_id = data.sngl_inspiral_table.get_next_id()
			data.sngl_inspiral_table.append(row)
	if data.connection: data.connection.commit()

#
# loop over instruments FIXME for now it is just one instrument :)
#

for ifo in [options.instrument]:
	elems = []
	#FIXME add frame support
	elems.append(pipeutil.mkelem("lal_fakeligosrc", {"channel-name": options.channel_name, "instrument": ifo, "blocksize": 16384 * 8}))
	#elems.append(pipeutil.mkelem("audiotestsrc", {"wave":10, "freq":0.1}))
	elems.append(pipeutil.mkelem("progressreport"))

	# add injection if specified
	if options.injections:
		elems.append(pipeutil.mkelem("queue"))
		elems.append(pipeutil.mkelem("lal_simulation", {"xml-location": options.injections}))
		elems.append(pipeutil.mkelem("queue"))

	# resample at the specified sample rate
	elems.append(pipeutil.mkelem("audioresample"))
	elems.append(pipeutil.mkelem("capsfilter",{"caps": gst.Caps("audio/x-raw-float,width=64,rate=%d" % (sample_rate))}))

	# apply whitening and do filtering
	elems.append(pipeutil.mkelem("lal_whiten",{"zero-pad": 0, "fft-length": 8, "average-samples": 32, "median-samples": 9,}))
	elems.append(pipeutil.mkelem("lal_nofakedisconts"))
	elems.append(pipeutil.mkelem("queue"))
	elems.append(pipeutil.mkelem("progressreport"))
	tee2[ifo] = pipeutil.mkelem("tee")
	elems.append(tee2[ifo])

	#
	# Uncomment to dump input to txt (HUGE)
	#

	nxydump = pipeutil.mkelem("lal_nxydump")
	pipeline.add(nxydump)
	filesink = pipeutil.mkelem("filesink", {"location":"input.txt"})
	pipeline.add(filesink)
	nxydump.link(filesink)

	iirbank = pipeutil.mkelem("lal_iirbank",{"name": ifo+" iir", "a1-matrix": repack_complex_array_to_real(A), "b0-matrix": repack_complex_array_to_real(B), "delay-matrix":D})
	elems.append(iirbank)
	tee2[ifo].link(iirbank)
	elems.append(pipeutil.mkelem("queue"))
	elems.append(pipeutil.mkelem("lal_togglecomplex"))
	elems.append(pipeutil.mkelem("lal_nofakedisconts"))
	elems.append(pipeutil.mkelem("progressreport"))
	tee[ifo] =  pipeutil.mkelem("tee")

	elems.append(tee[ifo])
	for elem in elems: pipeline.add(elem)
	gst.element_link_many(*elems)

	tee2[ifo].link(nxydump)

	triggergen[ifo] = pipeutil.mkelem("lal_triggergen",{"bank-filename":options.iir_bank, "snr-thresh":snr_threshold, "max-gap": 1.0})
	chisq[ifo] = pipeutil.mkelem("lal_autochisq", {"snr-thresh":snr_threshold, "latency": -50, "autocorrelation-matrix":repack_complex_array_to_real(autocor)})
	pipeline.add(chisq[ifo])
	pipeline.add(triggergen[ifo])

	queue = pipeutil.mkelem("queue")
	pipeline.add(queue)
	tee[ifo].link(queue)
	queue.link_pads("src", triggergen[ifo], "snr")
	
	queue = pipeutil.mkelem("queue")
	pipeline.add(queue)
	tee[ifo].link(queue)
	queue.link(chisq[ifo])
	chisq[ifo].link(triggergen[ifo])

	#
	# Uncomment to dump snr to txt (HUGE)
	#
	tc = pipeutil.mkelem("lal_togglecomplex")
	pipeline.add(tc)
	nxydump = pipeutil.mkelem("lal_nxydump")
	pipeline.add(nxydump)
	filesink = pipeutil.mkelem("filesink", {"location":"snroutput.txt"})
	pipeline.add(filesink)
	tee[ifo].link(tc)
	tc.link(nxydump)
	nxydump.link(filesink)
	
	appsink = pipeutil.mkelem("appsink",{"caps": gst.Caps("application/x-lal-snglinspiral"), "sync": False, "async": False, "emit-signals": True, "max-buffers": 1, "drop": True})
	pipeline.add(appsink)
	triggergen[ifo].link(appsink)
	appsink.connect_after("new-buffer", appsink_new_buffer, data)
		

############################################################
# run the pipeline

class Handler(object):
	def __init__(self, mainloop, pipeline):
		self.mainloop = mainloop
		self.pipeline = pipeline

		bus = pipeline.get_bus()
		bus.add_signal_watch()
		bus.connect("message", self.on_message)

	def on_message(self, bus, message):
		if message.type == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
		elif message.type == gst.MESSAGE_ERROR:
			gerr, dbgmsg = message.parse_error()
			self.pipeline.set_state(gst.STATE_NULL)
			self.mainloop.quit()
			sys.exit("error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg))


gst.DEBUG_BIN_TO_DOT_FILE(pipeline, gst.DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS, "gstlal_iir_inspiral_graph")

seekevent = seek_event_for_gps(options.gps_start_time, options.gps_end_time)

for src in pipeline.iterate_sources():
	src.send_event(seekevent)

handler = Handler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()

data.write_output_file()
