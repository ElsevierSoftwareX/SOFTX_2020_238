#!/usr/bin/env python
"""

Calculate impulse response of LLOID filter bank by injecting an impulse
into the pipeline and recording the output.  Cumulative SNR is recorded
at each time slice.

"""
__author__ = "Leo Singer <leo.singer@ligo.org>"


# Command line interface

from optparse import OptionParser, Option
try: # FIXME Python 2.4 compatibility for cluster
	any
except:
	from glue.iterutils import any

opts, args = OptionParser(description = __doc__,
	option_list = [
		Option("--templates", help="Name of a binary data file containing templates."),
		Option("--svd-bank", help="Name of an SVD'd template bank."),
		Option("-d", "--downsample-quality", metavar="0..10", help="Downsampling quality setting (default=9).", choices=[str(q) for q in range(11)], default=9),
		Option("-u", "--upsample-quality", metavar="0..10", help="Upsampling quality setting (default=9).", choices=[str(q) for q in range(11)], default=9),
		Option("-o", "--output", metavar="FILE_%d.out", help="Printf-style pattern for output files.  The single numeric printf specifier will be replaced by the index of each time slice."),
	]
).parse_args()

if any(getattr(opts, key) is None for key in ('templates', 'svd_bank', 'downsample_quality', 'upsample_quality', 'output')):
	raise RuntimeError("Missing some required arguments")


# Pipeline

from gstlal.pipeutil import *
from gstlal import lloidparts
from gstlal import pipeparts
from gstlal.lloidparts import mkelems_fast
from gstlal.svd_bank import read_bank
import math, numpy
import os.path


gst.plugin_load_file(os.path.join(os.path.dirname(__file__), 'libcomputematchsink.so'))
bank = read_bank(opts.svd_bank)
count_fragments = len(bank.bank_fragments)
upsample_quality = int(opts.upsample_quality)
downsample_quality = int(opts.downsample_quality)

pipeline = gst.Pipeline("impulse_response")
mainloop = gobject.MainLoop()
handler = lloidparts.LLOIDHandler(mainloop, pipeline)

source_rate = max(bank.get_rates())

# Input stage
src_elems = mkelems_fast(pipeline,
	"audiotestsrc", {"wave": "square", "freq": 0.001 / bank.filter_length, "volume": 1.},
	"audiofirfilter", {"kernel": [1., -1.]},
	"audiodelay", {"samples": source_rate},
	"lal_nofakedisconts", {"silent": True},
	"capsfilter", {"caps": gst.Caps("audio/x-raw-float,width=64,channels=1,rate=%d" % source_rate)},
	"tee",
)

# Loop over bank fragments in chronological order
for i, bank_fragment in enumerate(sorted(bank.bank_fragments, key = lambda x: x.end, reverse = True)):
	head = mkelems_fast(pipeline,
		src_elems[-1],
		"audioamplify", {"clipping-method": "none", "amplification": 1/math.sqrt(pipeparts.audioresample_variance_gain(downsample_quality, source_rate, bank_fragment.rate))},
		"audiodelay", {"samples": long(round(bank_fragment.start * source_rate + source_rate // bank_fragment.rate - 1))},
		"lal_nofakedisconts", {"silent": True},
		"audioresample", {"quality": downsample_quality},
		"lal_nofakedisconts", {"silent": True},
		"queue", {"max-size-bytes": 0, "max-size-buffers": 0, "max-size-time": long(math.ceil(2 * bank.filter_length * gst.SECOND))},
		"capsfilter", {"caps": gst.Caps("audio/x-raw-float,rate=%d" % bank_fragment.rate)},
		"lal_firbank2", {"fir-matrix": bank_fragment.orthogonal_template_bank, "time-domain": True},
		"lal_nofakedisconts", {"silent": True},
		"lal_reblock",
		"lal_matrixmixer", {"matrix": bank_fragment.mix_matrix},
	)[-1]
	if i > 0:
		head = mkelems_fast(pipeline,
			head,
			"lal_adder", {"sync": True})[-1]
		mkelems_fast(pipeline,
			last_head,
			"queue", {"max-size-bytes": 0, "max-size-buffers": 0, "max-size-time": gst.SECOND},
			"audioresample", {"quality": upsample_quality}, # Always at same upsample quality (highest allowed)
			"lal_nofakedisconts", {"silent": True},
			"capsfilter", {"caps": gst.Caps("audio/x-raw-float,rate=%d" % bank_fragment.rate)},
			head)
	if i < count_fragments - 1:
		head = mkelems_fast(pipeline, head, "tee")[-1]
	mkelems_fast(pipeline,
		head,
		"audioresample", {"quality": 10}, # Always at same upsample quality (highest allowed)
		"lal_nofakedisconts", {"silent": True},
		"capsfilter", {"caps": gst.Caps("audio/x-raw-float,rate=%d" % source_rate)},
		"lal_delay", {"delay": source_rate},
		"lal_nofakedisconts", {"silent": True},
		"queue", {"max-size-bytes": 0, "max-size-buffers": 0, "max-size-time": gst.SECOND},
		"progressreport",
		"computematchsink", {"input-filename": opts.templates, "output-filename": opts.output % (len(bank.bank_fragments) - i - 1)})
	last_head = head

src_elems[0].set_state(gst.STATE_READY)
src_elems[0].send_event(gst.event_new_seek(
	1.0, gst.FORMAT_TIME, gst.SEEK_FLAG_NONE,
	gst.SEEK_TYPE_SET, 0,
	gst.SEEK_TYPE_SET, long(math.ceil((1 + bank.filter_length) * gst.SECOND))
))



pipeline.set_state(gst.STATE_PLAYING)
gst.DEBUG_BIN_TO_DOT_FILE(pipeline, gst.DEBUG_GRAPH_SHOW_ALL, "impulse_response")
mainloop.run()
