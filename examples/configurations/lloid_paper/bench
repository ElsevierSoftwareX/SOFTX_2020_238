#!/usr/bin/env python
"""

Benchmark latency of LLOID pipeline by synchronously feeding a stream of zeros
into it and recording both buffer timestamps and clock time.

"""
__author__ = "Leo Singer <leo.singer@ligo.org>"


# Command line interface

from optparse import OptionParser, Option
try: # FIXME Python 2.4 compatibility for cluster
	any
except:
	from glue.iterutils import any

opts, args = OptionParser(description = __doc__,
	option_list = [
		Option("--svd-bank", help="Name of an SVD'd template bank."),
		Option("-d", "--downsample-quality", metavar="0..10", help="Downsampling quality setting (default=9).", choices=[str(q) for q in range(11)], default=9),
		Option("-u", "--upsample-quality", metavar="0..10", help="Upsampling quality setting (default=9).", choices=[str(q) for q in range(11)], default=9),
	]
).parse_args()

if any(getattr(opts, key) is None for key in ('svd_bank', 'downsample_quality', 'upsample_quality')):
	raise RuntimeError("Missing some required arguments")


# Pipeline

from gstlal.pipeutil import *
from gstlal import lloidparts
from gstlal import pipeparts
from gstlal.lloidparts import mkelems_fast
from gstlal.svd_bank import read_bank
from itertools import groupby
from operator import attrgetter
import math, numpy


bank = read_bank(opts.svd_bank)
count_fragments = len(bank.bank_fragments)
upsample_quality = int(opts.upsample_quality)
downsample_quality = int(opts.downsample_quality)

pipeline = gst.Pipeline("impulse_response")
mainloop = gobject.MainLoop()
handler = lloidparts.LLOIDHandler(mainloop, pipeline)

rates = sorted(list(set(bank.get_rates())), reverse=True)
source_rate = rates[0]
min_rate = rates[-1]
resample_filter_length = (8, 16, 32, 48, 64, 80, 96, 128, 160, 192, 256)

total_latency = 0.5 * resample_filter_length[downsample_quality] / min_rate
for rate in rates[1:]:
	total_latency += 0.5 * resample_filter_length[upsample_quality] / rate
print total_latency

# Input stage
src = mkelems_fast(pipeline,
	"audiotestsrc", {"wave": "silence", "samplesperbuffer": source_rate / 4, "num-buffers": long(round(bank.filter_length * 40))},
	"flags", {"clear": "gap"},
	"capsfilter", {"caps": gst.Caps("audio/x-raw-float,width=64,channels=1,rate=%d" % source_rate)},
	"progressreport2", {"name": "progress_hft", "do-query": False, "high-precision": True, "absolute-time": True, "update-freq": 1},
	"tee",
)[-1]

# Loop over bank fragments, grouped by sample rate, from latest (highest frequency) to earliest (lowest frequency)
for rate, fragments in groupby(bank.bank_fragments, attrgetter('rate')):

	# Decimation
	if rate == source_rate:
		src1 = src
	else:
		src1 = mkelems_fast(pipeline,
			src,
			"audioresample", {"quality": downsample_quality},
			"lal_nofakedisconts", {"silent": True},
			"capsfilter", {"caps": gst.Caps("audio/x-raw-float,rate=%d" % rate)},
			"audioamplify", {"clipping-method": "none", "amplification": 1/math.sqrt(pipeparts.audioresample_variance_gain(downsample_quality, source_rate, rate))},
			"tee"
		)[-1]

	accum = mkelems_fast(pipeline,
		"adder",
	)[-1]

	if rate != source_rate:
		accum.link(last_accum)

	if rate != min_rate:
		last_accum = mkelems_fast(pipeline,
			"audioresample", {"quality": upsample_quality},
			"lal_nofakedisconts", {"silent": True},
			"capsfilter", {"caps": gst.Caps("audio/x-raw-float,rate=%d" % rate)},
			accum
		)[0]

	for fragment in fragments:
		mkelems_fast(pipeline,
			src1,
			"audiodelay", {"samples": long(round(fragment.start * rate))},
			"lal_nofakedisconts", {"silent": True},
			"lal_firbank2", {"fir-matrix": fragment.orthogonal_template_bank, "time-domain": True},
			"lal_nofakedisconts", {"silent": True},
			"lal_matrixmixer", {"matrix": fragment.mix_matrix},
			"queue", {"max-size-bytes": 0, "max-size-buffers": 0, "max-size-time": long(math.ceil((total_latency + fragment.start) * gst.SECOND))},
			accum
		)

	if rate == source_rate:
		mkelems_fast(pipeline,
			accum,
			"progressreport2", {"name": "progress_snr", "do-query": False, "high-precision": True, "absolute-time": True, "update-freq": 1},
			"fakesink", {"sync": True, "async": True}
		)


pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
