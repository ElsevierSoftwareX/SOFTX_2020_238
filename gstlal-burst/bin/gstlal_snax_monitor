#!/usr/bin/env python

# Copyright (C) 2018  Patrick Godwin
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

__usage__ = "gstlal_feature_monitor [--options]"
__description__ = "an executable to collect and monitor streaming features"
__author__ = "Patrick Godwin (patrick.godwin@ligo.org)"

#-------------------------------------------------
#                  Preamble
#-------------------------------------------------

from collections import defaultdict, deque
import json
import optparse
import os
import signal
import sqlite3
import sys
import time

from confluent_kafka import Consumer, KafkaError

from ligo.scald import io

from gstlal.snax import multichannel_datasource
from gstlal.snax import utils

#-------------------------------------------------
#                  Functions
#-------------------------------------------------

def parse_command_line():

    parser = optparse.OptionParser(usage=__usage__, description=__description__)
    group = optparse.OptionGroup(parser, "Monitor Options", "General settings for configuring the monitor.")
    group.add_option("-v","--verbose", default=False, action="store_true", help = "Print to stdout in addition to writing to automatically generated log.")
    group.add_option("--log-level", type = "int", default = 10, help = "Sets the verbosity of logging. Default = 10.")
    group.add_option("--instrument", metavar = "string", default = "H1", help = "Sets the instrument for files written to disk. Default = H1")
    group.add_option("--target-channel", metavar = "string", help = "Sets the target channel to view.")
    group.add_option("--rootdir", metavar = "path", default = ".", help = "Location where log messages and sqlite database lives")
    group.add_option("--tag", metavar = "string", default = "test", help = "Sets the name of the tag used. Default = 'test'")
    group.add_option("--sample-rate", type = "int", metavar = "Hz", default = 1, help = "Set the sample rate for feature timeseries output, must be a power of 2. Default = 1 Hz.")
    group.add_option("--num-channels", type = "int", help = "Set the full number of channels being processed upstream, used for monitoring purposes.")
    group.add_option("--channel-list", type="string", metavar = "name", help = "Set the list of the channels to process. Command given as --channel-list=location/to/file")
    group.add_option("--processing-cadence", type = "float", default = 0.1, help = "Rate at which the monitor acquires and processes data. Default = 0.1 seconds.")
    group.add_option("--request-timeout", type = "float", default = 0.2, help = "Timeout for requesting messages from a topic. Default = 0.2 seconds.")
    group.add_option("--kafka-server", metavar = "string", help = "Sets the server url that the kafka topic is hosted on. Required.")
    group.add_option("--input-topic-basename", metavar = "string", help = "Sets the input kafka topic basename. Required.")
    group.add_option("--data-backend", default="hdf5", help = "Choose the backend for data to be stored into, options: [hdf5|influx]. default = hdf5.")
    group.add_option("--influx-hostname", help = "Specify the hostname for the influxDB database. Required if --data-backend = influx.")
    group.add_option("--influx-port", help = "Specify the port for the influxDB database. Required if --data-backend = influx.")
    group.add_option("--influx-database-name", help = "Specify the database name for the influxDB database. Required if --data-backend = influx.")
    group.add_option("--enable-auth", default=False, action="store_true", help = "If set, enables authentication for the influx aggregator.")
    group.add_option("--enable-https", default=False, action="store_true", help = "If set, enables HTTPS connections for the influx aggregator.")
    group.add_option("--data-type", metavar="string", help="Specify datatypes to aggregate from 'min', 'max', 'median'. Default = max")
    group.add_option("--num-processes", type = "int", default = 2, help = "Number of processes to use concurrently, default 2.")
    parser.add_option_group(group)

    options, args = parser.parse_args()

    return options, args

#-------------------------------------------------
#                   Classes
#-------------------------------------------------

class StreamMonitor(object):
    """
    Listens to incoming streaming features, collects metrics and pushes relevant metrics to sqlite.
    """
    def __init__(self, logger, options):
        logger.info('setting up feature monitor...')

        ### initialize timing options
        self.request_timeout = options.request_timeout
        self.processing_cadence = options.processing_cadence
        self.sample_rate = options.sample_rate
        self.is_running = False

        ### kafka settings
        self.kafka_settings = {'bootstrap.servers': options.kafka_server,
                               'group.id': 'monitor_%s'%options.tag}

        ### initialize consumers
        self.consumer = Consumer(self.kafka_settings)
        self.consumer.subscribe([options.input_topic_basename])

        ### initialize queues
        self.feature_queue = deque(maxlen = 60 * self.sample_rate)

        ### other settings
        if options.target_channel:
            self.target_channel = options.target_channel
        else:
            self.target_channel = '%s:CAL-DELTAL_EXTERNAL_DQ'%options.instrument
        self.num_channels = options.num_channels

        self.data_type = options.data_type

        ### keep track of last timestamp processed and saved
        self.last_save = None
        self.timestamp = None

        ### set up aggregator 
        logger.info("setting up monitor with backend: %s"%options.data_backend)
        if options.data_backend == 'influx':
            self.agg_sink = io.influx.Aggregator(
                hostname=options.influx_hostname,
                port=options.influx_port,
                db=options.influx_database_name,
                auth=options.enable_auth,
                https=options.enable_https,
                reduce_across_tags=False,
            )
        else: ### hdf5 data backend
            self.agg_sink = io.hdf5.Aggregator(
                rootdir=options.rootdir,
                num_processes=options.num_processes,
                reduce_across_tags=False,
            )

        ### determine channels to be processed
        name, _ = options.channel_list.rsplit('.', 1)
        self.channels = set(multichannel_datasource.channel_dict_from_channel_file(options.channel_list).keys())

        ### define measurements to be stored
        for metric in ('target_snr', 'synchronizer_latency', 'percent_missed'):
            self.agg_sink.register_schema(metric, columns='data', column_key='data', tags='job', tag_key='job')

    def fetch_data(self):
        """
        requests for a new message from an individual topic,
        and add to the feature queue
        """
        message = self.consumer.poll(timeout=self.request_timeout)

        ### only add to queue if no errors in receiving data
        if message and not message.error():
            features = json.loads(message.value())
            self.add_to_queue(features['timestamp'], features['features'])

    def add_to_queue(self, timestamp, data):
        """
        add a set of features for a given timestamp to the feature queue
        """
        self.feature_queue.appendleft((timestamp, data))
        self.timestamp = timestamp

    def process_queue(self):
        """
        process features and generate metrics from synchronizer on a regular cadence
        """
        if self.timestamp:
            if not self.last_save or utils.in_new_epoch(self.timestamp, self.last_save, 1):

                ### check for missing channels
                missing_channels = set()

                metrics = defaultdict(list)
                while len(self.feature_queue) > 0:
                    ### remove data with oldest timestamp and process
                    timestamp, features = self.feature_queue.pop()
                    latency = utils.gps2latency(timestamp) 

                    ### check for missing channels
                    these_channels = set(features.keys())
                    missing_channels = self.channels - these_channels
                    ### generate metrics
                    metrics['time'].append(timestamp)
                    metrics['synchronizer_latency'].append(latency)
                    metrics['percent_missed'].append(100 * (float(self.num_channels - len(features.keys())) / self.num_channels))

                    if features.has_key(self.target_channel):
                        metrics['target_time'].append(timestamp)
                        metrics['target_snr'].append(features[self.target_channel][0]['snr'])

                ### store and aggregate features
                for metric in ('synchronizer_latency', 'percent_missed'):
                    data = {'time': metrics['time'], 'fields': {'data': metrics[metric]}}
                    self.agg_sink.store_columns(metric, {'synchronizer': data}, aggregate=self.data_type)
                if len(metrics['target_time']) > 0:
                    data = {'time': metrics['target_time'], 'fields': {'data': metrics['target_snr']}}
                    self.agg_sink.store_columns('target_snr', {'synchronizer': data}, aggregate=self.data_type)

                self.last_save = timestamp
                logger.info('processed features up to timestamp %.3f, max latency = %.3f s, percent missing channels = %.3f' % (timestamp, max(metrics['synchronizer_latency']), max(metrics['percent_missed'])))
                if missing_channels:
                    logger.info('channels missing @ timestamp=%.3f: %s' % (timestamp, repr(list(missing_channels))))


    def start(self):
        """
        starts ingesting features and monitoring and pushes metrics to sqlite
        """
        logger.info('starting feature monitor...')
        self.is_running = True
        while self.is_running:
            ### ingest incoming features
            self.fetch_data()
            ### store and aggregate generated metrics
            self.process_queue()
            ### repeat with processing cadence
            time.sleep(self.processing_cadence)

    def stop(self):
        """
        shut down gracefully
        """
        logger.info('shutting down feature monitor...')

class SignalHandler(object):
    """
    helper class to shut down the stream monitor gracefully before exiting
    """
    def __init__(self, monitor, signals = [signal.SIGINT, signal.SIGTERM]):
        self.monitor = monitor
        for sig in signals:
            signal.signal(sig, self)

    def __call__(self, signum, frame):
        self.monitor.stop()
        sys.exit(0)


#-------------------------------------------------
#                    Main
#-------------------------------------------------

if __name__ == '__main__':
    # parse arguments
    options, args = parse_command_line()

    ### set up logging
    logger = utils.get_logger(
        '-'.join([options.tag, 'feature_monitor']),
        log_level=options.log_level,
        rootdir=options.rootdir,
        verbose=options.verbose
    )

    # create summary instance
    monitor = StreamMonitor(logger, options=options)

    # install signal handler
    SignalHandler(monitor)

    # start up monitor
    monitor.start()
