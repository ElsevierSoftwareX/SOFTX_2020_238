#!/usr/bin/env python
#
# Copyright (C) 2010-2015  Jordi Burguet-Castell, Madeline Wade, Aaron Viets
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


"""
This pipeline produces h(t) given DARM_ERR and DARM_CTRL or given DELTAL_RESIDUAL and DELTAL_CTRL. It can be run online in real-time or offline on frame files.  It can write h(t) frames to frame files or to a shared memory partition.

The differential arm length resulting from external sources is						

\Delta L_{ext} = ((f^2 + f_s^2 - i * f * f_s / Q) / f^2)							
* ((1 + i * f / f_cc) / (\kappa_c C_res)) * d_{err}							     
+ (A_tst * \kappa_tst + A_pu * \kappa_pu) * d_{ctrl}							    

where C is the static portion of the sensing function, A_tst is the TST actuation function, A_pu is the PUM+UIM actuation, \kappa_c is the time-dependent gain of the sensing function, \kappa_tst is the time-dependent gain of TST actuation, and \kappa_pu is the time-dependent gain of the PUM/UIM actuation.  \Delta L_{ext} is divided by the average arm length (4000 km) to obtain h(t), the external strain in the detectors,												

h(t) = \Delta L_{ext} / L .										  

The time-dependent gains (\kappa's) as well as the value for the coupled cavity pole f_cc and SRC detuning parameters f_s and Q are calcuated in this pipeline as well.

This pipeline will most often be run in a format where it picks up after part of the actuation and sensing functions have been applied to the appropriate channels.  In this mode, the input channels are \Delta L_{res} and \Delta L_{ctrl, i}.  This pipeline then applies further high frequency corrections to each of these channels, applies the appropriate time delay to each channel, adds the channels together, and divides by L.											

h(t) = (((f^2 + f_s^2 - i * f * f_s / Q) / f^2)							     
* ((1 + i * f / f_cc) / \kappa_c) * corrections * \Delta L_{res}						    
+ \kappa_tst * \Delta L_{ctrl, TST}										 
+ \kappa_pu * (\Delta L_{ctrl, P} + \Delta L_{ctrl, U})) / L							

Note: The actuation \kappa's are complex numbers.  Only the real part of the computed \kappa's are applied as time-dependent gain corrections.

Further documentation explaining the time domain calibration procedure can be found in LIGO DCC #T1400256 and #P1700236.

For a full list of example command lines that were used to create the O1 h(t) frames, see https://wiki.ligo.org/Calibration/GDSCalibrationConfigurationsO1.
For a full list of example command lines that were used to create the O2 h(t) frames, see https://wiki.ligo.org/Calibration/GDSCalibrationConfigurationsO2.

Type gstlal_compute_strain --help to see the full list of command line options.
"""

import sys
import numpy
import time
import resource

from optparse import OptionParser, Option
import ConfigParser

import gi
gi.require_version('Gst', '1.0')
from gi.repository import GObject, Gst
GObject.threads_init()
Gst.init(None)

import lal

from gstlal import pipeparts
from gstlal import calibration_parts
from gstlal import simplehandler
from gstlal import datasource

from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
array.use_in(ligolw.LIGOLWContentHandler)
param.use_in(ligolw.LIGOLWContentHandler)
from glue.ligolw import utils
from ligo import segments

#
# Function definition for writing pipeline graph
#

def write_graph(demux):
	pipeparts.write_dump_dot(pipeline, "%s.%s" % (DebuggingConfigs["pipelinegraphfilename"], "PLAYING"), verbose = True)

#
# Make sure we have sufficient resources
# We allocate far more memory than we need, so this is okay
#

def setrlimit(res, lim):
	hard_lim = resource.getrlimit(res)[1]
	resource.setrlimit(res, (lim if lim is not None else hard_lim, hard_lim))
# set the number of processes and total set size up to hard limit and
# shrink the per-thread stack size (default is 10 MiB)
setrlimit(resource.RLIMIT_NPROC, None)
setrlimit(resource.RLIMIT_AS, None)
setrlimit(resource.RLIMIT_RSS, None)
setrlimit(resource.RLIMIT_STACK, 1024*1024)

#
# Function definition to obtain the current GPS time
#

def now():
	return lal.LIGOTimeGPS(lal.UTCToGPS(time.gmtime()), 0)
	

#
# Function to update FIR matrix property
#

def fir_matrix_update(elem, arg, filtered):
	filtered.set_property("kernel", elem.get_property("fir_matrix")[0][::-1])
	print("fir matrix updated")

#############################################################################
##################### Program Command Line Options ##########################
#############################################################################

parser = OptionParser(description = __doc__)

# Append program specific options

# These options should be used whether the pipeline runs in full calibration mode or partial calibration mode
parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the start time of the segment to analyze in GPS seconds. This is required iff --data-source=frames")
parser.add_option("--gps-end-time", metavar = "seconds", help = "Set the end time of the segment to analyze in GPS seconds. This is required iff --data-source=frames")
parser.add_option("--wings", metavar = "seconds", default = 0, type = "int", help = "Number of seconds to trim off of the beginning and end of the output. Should only be used if --data-source=frames.")
parser.add_option("--frame-duration", metavar = "seconds", type = "int", default = 4, help = "Set the number of seconds for each frame. (Default = 4)")
parser.add_option("--frames-per-file", metavar = "count", type = "int", default = 1, help = "Set the number of frames per frame file. (Default = 1)")
parser.add_option("--config-file", metavar = "name", help = "Full path to configuration file for running.")

# Parse options
options, filenames = parser.parse_args()

#############################################################################
######################### Config File Options  ##############################
#############################################################################

def ConfigSectionMap(section):
	dict1 = {}
	options = Config.options(section)
	for option in options:
		try:
			dict1[option] = Config.get(section, option)
			if dict1[option] == -1:
				DebugPrint("skip: %s" % option)
		except:
			print("exception on %s!" % option)
			dict[option] = None
	return dict1

Config = ConfigParser.ConfigParser()
Config.read(options.config_file)

InputConfigs = ConfigSectionMap("InputConfigurations")
OutputConfigs = ConfigSectionMap("OutputConfigurations")
CalibrationConfigs = ConfigSectionMap("CalibrationConfigurations")
DebuggingConfigs = ConfigSectionMap("DebuggingConfigurations")
TDCFConfigs = ConfigSectionMap("TDCFConfigurations")
ChannelNames = ConfigSectionMap("ChannelNames")
SampleRates = ConfigSectionMap("SampleRates")
Bitmasks = ConfigSectionMap("Bitmasks")
PipelineConfigs = ConfigSectionMap("PipelineConfigurations")
DataCleaningConfigs = ConfigSectionMap("DataCleaningConfigurations")


# Sanity checks for command line options
data_sources = set(("frames", "lvshm"))

if InputConfigs["datasource"] not in data_sources:
	raise ValueError("DataSource must be one of %s" % ",".join(data_sources))

if InputConfigs["datasource"] == "frames" and InputConfigs["framecache"] is None:
	raise ValueError("FrameCache must be specified when using DataSource: frames")

if int(options.wings != 0) and InputConfigs["datasource"] != "frames":
	raise ValueError("Wings can only be set when DataSource: frames")

if CalibrationConfigs["ifo"] is None:
	raise ValueError("must specify IFO")

if InputConfigs["datasource"] == "frames" and (options.gps_start_time is None or options.gps_end_time is None):
	raise ValueError("must specify --gps-start-time and --gps-end-time when DataSource: frames")

if (CalibrationConfigs["calibrationmode"] != "Full") and (CalibrationConfigs["calibrationmode"] != "Partial"):
	raise ValueError("must specify either Full or Partial for CalibrationMode")

if int(TDCFConfigs["recordfactorssr"]) > int(TDCFConfigs["computefactorssr"]):
	raise ValueError("RecordFactorsSR must be less than or equal to ComputeFactorsSR")

if TDCFConfigs["factorsfromfiltersfile"] is "No" and (TDCFConfigs["computefs"] is "Yes" or TDCFConfigs["computesrcq"] is "Yes") and ((InputConfigs["datasource"] is "frames" and int(options.gps_start_time) < 1175954418) or (InputConfigs["datasource"] == "lvshm" and now() < 1175954418)):
	raise ValueError("Cannot compute SRC detuning parameters as the needed EPICS channels are not in the frames until GPS time 1175954418. Set ComputeFs: No and ComputeSRCQ: No.")

if options.gps_start_time is not None:
	if options.gps_end_time is None:
		raise ValueError("must provide both --gps-start-time and --gps-end-time")
	if InputConfigs["datasource"] == "lvshm":
		raise ValueError("cannot set --gps-start-time or --gps-end-time with DataSource: lvshm")
	if int(options.gps_start_time) >= int(options.gps_end_time):
		raise ValueError("--gps-start-time must be < --gps-end-time: %s < %s" % (options.gps_start_time, options.gps_end_time))
elif options.gps_end_time is not None:
	raise ValueError("must provide both --gps-start-time and --gps-end-time")

###################################################################################################
######################################## Setup ####################################################
###################################################################################################

# Set up instrument and channel name info from command line options
instrument = CalibrationConfigs["ifo"]

if options.gps_start_time is not None and options.gps_end_time is not None:
	gps_start_time = int(options.gps_start_time)
	gps_end_time = int(options.gps_end_time)

# Set up short-cut names for each of the sample rates used throughout the pipeline and establish caps string shortcuts
hoft_sr = int(SampleRates["hoftsr"]) # Sample rate for h(t)
calibstate_sr = int(SampleRates["calibstatesr"]) # Sample rate for the CALIB_STATE_VECTOR
odc_sr = int(SampleRates["odcsr"]) # Sample rate of the ODC channel that is read in
ctrl_sr = int(SampleRates["ctrlsr"]) # Sample rate of the control channel (such as DARM_CTRL or DELTAL_CTRL)
tst_exc_sr = int(SampleRates["tstexcsr"])
coh_sr = int(SampleRates["cohsr"]) # Sample rate for the coherence uncertainty channels
epics_sr = int(SampleRates["epicsrefsr"]) # Sample rate for EPICS records used for TDCFs
compute_factors_sr = int(SampleRates["computefactorssr"]) # Sample rate for computing TDCFs
record_factors_sr = int(SampleRates["recordfactorssr"]) # Sample rate for recording TDCFs
hoft_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % hoft_sr
ctrl_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % ctrl_sr
calibstate_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % calibstate_sr
odc_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % odc_sr
coh_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % coh_sr
ref_factors_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % epics_sr
compute_calib_factors_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0X0" % compute_factors_sr
compute_calib_factors_complex_caps = "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % compute_factors_sr

# Short cut names for a few other items that appear numerous times
filter_latency = float(PipelineConfigs["filterlatency"])
demodulation_filter_time = int(TDCFConfigs["demodulationfiltertime"])
coherence_unc_threshold = float(TDCFConfigs["coherenceuncthreshold"])
actuation_filter_update_time = float(TDCFConfigs["actuationfilterupdatetime"])
actuation_filter_averaging_time = float(TDCFConfigs["actuationfilteraveragingtime"])
actuation_filter_taper_length = int(TDCFConfigs["actuationfiltertaperlength"])
sensing_filter_update_time = float(TDCFConfigs["sensingfilterupdatetime"])
sensing_filter_averaging_time = float(TDCFConfigs["sensingfilteraveragingtime"])
sensing_filter_taper_length = int(TDCFConfigs["sensingfiltertaperlength"])
cleaning_check_rms_time = float(DataCleaningConfigs["cleaningcheckrmstime"])
cleaning_check_range_low_min = float(DataCleaningConfigs["cleaningcheckrangelowmin"])
cleaning_check_range_low_max = float(DataCleaningConfigs["cleaningcheckrangelowmax"])
cleaning_check_range_mid_min = float(DataCleaningConfigs["cleaningcheckrangemidmin"])
cleaning_check_range_mid_max = float(DataCleaningConfigs["cleaningcheckrangemidmax"])
powerlines_tf_averaging_time = float(DataCleaningConfigs["powerlinestfaveragingtime"])
powerlines_freq_var = float(DataCleaningConfigs["powerlinesfreqvar"])
witness_channel_fft_time = float(DataCleaningConfigs["witnesschannelffttime"])
num_witness_ffts = int(DataCleaningConfigs["numwitnessffts"])
witness_fir_length = float(DataCleaningConfigs["witnessfirlength"])
witness_frequency_resolution = float(DataCleaningConfigs["witnessfrequencyresolution"])
witness_tf_update_time = float(DataCleaningConfigs["witnesstfupdatetime"])
witness_filter_taper_time = float(DataCleaningConfigs["witnessfiltertapertime"])

expected_kappatst_real = float(TDCFConfigs["expectedkappatstreal"])
expected_kappatst_imag = float(TDCFConfigs["expectedkappatstimag"])
expected_kappapu_real = float(TDCFConfigs["expectedkappapureal"])
expected_kappapu_imag = float(TDCFConfigs["expectedkappapuimag"])
expected_kappap_real = float(TDCFConfigs["expectedkappapreal"])
expected_kappap_imag = float(TDCFConfigs["expectedkappapimag"])
expected_kappau_real = float(TDCFConfigs["expectedkappaureal"])
expected_kappau_imag = float(TDCFConfigs["expectedkappauimag"])
expected_kappac = float(TDCFConfigs["expectedkappac"])
expected_fcc = float(TDCFConfigs["expectedfcc"])
expected_fs = float(TDCFConfigs["expectedfs"])
expected_srcq = float(TDCFConfigs["expectedsrcq"])
kappatst_real_var = float(TDCFConfigs["kappatstrealvar"])
kappatst_imag_var = float(TDCFConfigs["kappatstimagvar"])
kappapu_real_var = float(TDCFConfigs["kappapurealvar"])
kappapu_imag_var = float(TDCFConfigs["kappapuimagvar"])
kappap_real_var = float(TDCFConfigs["kappaprealvar"])
kappap_imag_var = float(TDCFConfigs["kappapimagvar"])
kappau_real_var = float(TDCFConfigs["kappaurealvar"])
kappau_imag_var = float(TDCFConfigs["kappauimagvar"])
kappac_var = float(TDCFConfigs["kappacvar"])
fcc_var = float(TDCFConfigs["fccvar"])
fs_var = float(TDCFConfigs["fsvar"])
srcQinv_min = float(TDCFConfigs["srcqinvmin"])
srcQinv_max = float(TDCFConfigs["srcqinvmax"])

# Set up smoothing, averaging and integration sample sizes for kappa calulations
integration_samples = demodulation_filter_time * compute_factors_sr
factors_average_samples = int(TDCFConfigs["tdcfaveragingtime"]) * compute_factors_sr
median_smoothing_samples = int(TDCFConfigs["mediansmoothingtime"]) * compute_factors_sr
kappa_gate_attack_length = -integration_samples * (1.0 - filter_latency)
kappa_gate_hold_length = -integration_samples * filter_latency - (filter_latency != 0) * int(TDCFConfigs["coherencetime"]) * compute_factors_sr

# Set up string for the channels suffix and prefix as provided by the user
if OutputConfigs["chansuffix"] != "None":
	chan_suffix = OutputConfigs["chansuffix"]
else:
	chan_suffix = ""
chan_prefix = OutputConfigs["chanprefix"]

# Set up shortcut variables for boolean options
# Booleans for TDCFs
compute_kappatst = Config.getboolean("TDCFConfigurations", "computekappatst")
compute_kappapu = Config.getboolean("TDCFConfigurations", "computekappapu")
compute_kappap = Config.getboolean("TDCFConfigurations", "computekappap")
compute_kappau = Config.getboolean("TDCFConfigurations", "computekappau")
compute_kappac = Config.getboolean("TDCFConfigurations", "computekappac")
compute_fcc = Config.getboolean("TDCFConfigurations", "computefcc")
compute_fs = Config.getboolean("TDCFConfigurations", "computefs")
compute_srcq = Config.getboolean("TDCFConfigurations", "computesrcq")
apply_kappatst = Config.getboolean("TDCFConfigurations", "applykappatst")
apply_complex_kappatst = Config.getboolean("TDCFConfigurations", "applycomplexkappatst")
apply_kappapu = Config.getboolean("TDCFConfigurations", "applykappapu")
apply_complex_kappapu = Config.getboolean("TDCFConfigurations", "applycomplexkappapu")
apply_kappap = Config.getboolean("TDCFConfigurations", "applykappap")
apply_complex_kappap = Config.getboolean("TDCFConfigurations", "applycomplexkappap")
apply_kappau = Config.getboolean("TDCFConfigurations", "applykappau")
apply_complex_kappau = Config.getboolean("TDCFConfigurations", "applycomplexkappau")
apply_kappac = Config.getboolean("TDCFConfigurations", "applykappac")
apply_fcc = Config.getboolean("TDCFConfigurations", "applyfcc")
apply_srcq = Config.getboolean("TDCFConfigurations", "applysrcq")
apply_fs = Config.getboolean("TDCFConfigurations", "applyfs")
use_coherence = Config.getboolean("TDCFConfigurations", "usecoherence")
tdcf_default_to_median = Config.getboolean("TDCFConfigurations", "tdcfdefaulttomedian")
# Boolean for state vector computation
compute_calib_statevector = Config.getboolean("CalibrationConfigurations", "computecalibstatevector")
# Boolean for computing factors from filters file
factors_from_filters_file = Config.getboolean("TDCFConfigurations", "factorsfromfiltersfile")
# Boolean for removing calibration lines, power lines, DC component
remove_cal_lines = Config.getboolean("DataCleaningConfigurations", "removecallines")
remove_power_lines = Config.getboolean("DataCleaningConfigurations", "removepowerlines")
remove_dc = Config.getboolean("DataCleaningConfigurations", "removedc")
# If td is true we will perform filtering in the time domain (direct convolution) in all FIR filtering routines below
td = not Config.getboolean("PipelineConfigurations", "frequencydomainfiltering")
# Boolean for dewhitening
dewhitening = Config.getboolean("PipelineConfigurations", "dewhitening")
# Boolean for low-latency mood
low_latency = Config.getboolean("PipelineConfigurations", "lowlatency")
# Boolean for verboseness
verbose = Config.getboolean("DebuggingConfigurations", "verbose")
# Boolean for file_check_sum
file_check_sum = Config.getboolean("InputConfigurations", "filechecksum")
skip_bad_files = Config.getboolean("InputConfigurations", "skipbadfiles")

# If we are using EPICS from frames and removing calibration lines, we need EP10 to remove the ESD line. Otherwise, we just remove the other lines if possible.
if (not factors_from_filters_file) and remove_cal_lines and (InputConfigs["datasource"] == "lvshm" or (instrument == "H1" and gps_start_time > 1175976256) or (instrument == "L1" and gps_start_time > 1179588864)):
	remove_esd_act_line = True
else:
	remove_esd_act_line = False

# How many EPICS will we for the CALIB_STATE_VECTOR calculation? It depends on the IFO and the time we are calibrating
if not compute_calib_statevector:
	num_dq_epics = 0
elif InputConfigs["datasource"] == "lvshm":
	num_dq_epics = 14
elif instrument == "H1" and gps_start_time > 1175976256:
	num_dq_epics = 14
elif instrument == "L1" and gps_start_time > 1179588864:
	num_dq_epics = 10
else:
	num_dq_epics = 9
if (not factors_from_filters_file) and (compute_fs or compute_srcq) and ((InputConfigs["datasource"] is "frames" and gps_start_time < 1175954418) or (InputConfigs["datasource"] == "lvshm" and now() < 1175954418)):
	raise ValueError("Cannot compute SRC detuning parameters as the needed EPICS channels are not in the frames until GPS time 1175954418. Set ComputeFs: No and ComputeSRCQ: No.")

#
# Load in the filters file that contains filter coefficients, etc.
#

filters = numpy.load(InputConfigs["filtersfilename"])

# If we're reading the reference model factors from the filters file, load them
if factors_from_filters_file or compute_calib_statevector:
	try:
		EP1_real = float(filters["EP1_real"])
		EP1_imag = float(filters["EP1_imag"])
		EP2_real = float(filters["EP2_real"])
		EP2_imag = float(filters["EP2_imag"])
		EP3_real = float(filters["EP3_real"])
		EP3_imag = float(filters["EP3_imag"])
		EP4_real = float(filters["EP4_real"])
		EP4_imag = float(filters["EP4_imag"])
		EP5_real = float(filters["EP5_real"])
		EP5_imag = float(filters["EP5_imag"])
		EP6_real = float(filters["EP6_real"])
		EP6_imag = float(filters["EP6_imag"])
		EP7_real = float(filters["EP7_real"])
		EP7_imag = float(filters["EP7_imag"])
		EP8_real = float(filters["EP8_real"])
		EP8_imag = float(filters["EP8_imag"])
		EP9_real = float(filters["EP9_real"])
		EP9_imag = float(filters["EP9_imag"])
	except:
		if factors_from_filters_file:
			raise ValueError("Cannot compute time-dependent correction factors, as the needed EPICS are not contained in the specified filters file.")
		if num_dq_epics > 0:
			num_dq_epics = 0
	try:
		EP10_real = float(filters["EP10_real"])
		EP10_imag = float(filters["EP10_imag"])
		if factors_from_filters_file and remove_cal_lines:
			remove_esd_act_line = True
		else:
			remove_esd_act_line = False
	except:
		if factors_from_filters_file:
			remove_esd_act_line = False
		if num_dq_epics > 9:
			num_dq_epics = 9
	try:
		EP11_real = float(filters["EP11_real"])
		EP11_imag = float(filters["EP11_imag"])
		EP12_real = float(filters["EP12_real"])
		EP12_imag = float(filters["EP12_imag"])
		EP13_real = float(filters["EP13_real"])
		EP13_imag = float(filters["EP13_imag"])
		EP14_real = float(filters["EP14_real"])
		EP14_imag = float(filters["EP14_imag"])
	except:
		if factors_from_filters_file and (compute_srcq or compute_fs):
			raise ValueError("Cannot compute SRC spring frequency or Q, as the needed EPICS are not contained in the specified filters file.")
		if num_dq_epics > 10:
			num_dq_epics = 10

# Load all of the kappa dewhitening and correction factors
darm_act_line_freq = float(filters["ka_pcal_line_freq"])
pcal_corr_at_darm_act_freq_real = float(filters["ka_pcal_corr_re"])
pcal_corr_at_darm_act_freq_imag = float(filters["ka_pcal_corr_im"])
pu_act_esd_line_freq = float(filters["ka_esd_line_freq"])
opt_gain_fcc_line_freq = float(filters["kc_pcal_line_freq"])
pcal_corr_at_opt_gain_fcc_freq_real = float(filters["kc_pcal_corr_re"])
pcal_corr_at_opt_gain_fcc_freq_imag = float(filters["kc_pcal_corr_im"])
esd_act_line_freq = float(filters["ktst_esd_line_freq"])
pcal_line_removal_dict = {}
if remove_cal_lines:
	pcal_line_removal_dict["pcal1"] = [darm_act_line_freq, pcal_corr_at_darm_act_freq_real, pcal_corr_at_darm_act_freq_imag, None]
	pcal_line_removal_dict["pcal2"] = [opt_gain_fcc_line_freq, pcal_corr_at_opt_gain_fcc_freq_real, pcal_corr_at_opt_gain_fcc_freq_imag, None]
try:
	src_pcal_line_freq = float(filters["src_pcal_line_freq"])
	pcal_corr_at_src_freq_real = float(filters["src_pcal_corr_re"])
	pcal_corr_at_src_freq_imag = float(filters["src_pcal_corr_im"])
	if src_pcal_line_freq > 10.0 and remove_cal_lines and src_pcal_line_freq != darm_act_line_freq:
		pcal_line_removal_dict["pcal4"] = [src_pcal_line_freq, pcal_corr_at_src_freq_real, pcal_corr_at_src_freq_imag, None]
except:
	if compute_srcq or compute_fs:
		raise ValueError("Cannot compute SRC spring frequency or Q, as the calibration line frequency is not contained in the specified filters file.")
try:
	high_pcal_line_freq = float(filters["high_pcal_line_freq"])
	pcal_corr_at_high_line_freq_real = float(filters["high_pcal_corr_re"])
	pcal_corr_at_high_line_freq_imag = float(filters["high_pcal_corr_im"])
	if high_pcal_line_freq > 0 and remove_cal_lines:
		pcal_line_removal_dict["pcal3"] = [high_pcal_line_freq, pcal_corr_at_high_line_freq_real, pcal_corr_at_high_line_freq_imag, None]
except:
	high_pcal_line_freq = 0.0
try:
	roaming_pcal_line_freq = float(filters["roaming_pcal_line_freq"])
	pcal_corr_at_roaming_line_real = float(filters["roaming_pcal_corr_re"])
	pcal_corr_at_roaming_line_imag = float(filters["roaming_pcal_corr_im"])
	if roaming_pcal_line_freq > 0.0 and remove_cal_lines:
		pcal_line_removal_dict["pcal5"] = [roaming_pcal_line_freq, pcal_corr_at_roaming_line_real, pcal_corr_at_roaming_line_imag, None]
except:
	roaming_pcal_line_freq = 0.0
try:
	fcc_default = float(filters["fcc"])
except:
	fcc_default = expected_fcc
try:
	fs_default = float(filters["fs"])
	srcQ_default = float(filters["srcQ"])
except:
	fs_default = expected_fs
	srcQ_default = expected_srcq

if dewhitening:
	try:
		derr_dewhiten_at_darm_act_freq_real = float(filters["ka_pcal_whitener_re"])
		derr_dewhiten_at_darm_act_freq_imag = float(filters["ka_pcal_whitener_im"])
		derr_dewhiten_at_pu_act_freq_real = float(filters["ka_esd_whitener_re"])
		derr_dewhiten_at_pu_act_freq_imag = float(filters["ka_esd_whitener_im"])
		derr_dewhiten_at_opt_gain_fcc_freq_real = float(filters["kc_pcal_whitener_re"])
		derr_dewhiten_at_opt_gain_fcc_freq_imag = float(filters["kc_pcal_whitener_im"])
		derr_dewhiten_at_esd_act_freq_real = float(filters["ktst_esd_whitener_re"])
		derr_dewhiten_at_esd_act_freq_imag = float(filters["ktst_esd_whitener_im"])
	except:
		derr_dewhiten_at_darm_act_freq_real = 1.0
		derr_dewhiten_at_darm_act_freq_imag = 0.0
		derr_dewhiten_at_pu_act_freq_real = 1.0
		derr_dewhiten_at_pu_act_freq_imag = 0.0
		derr_dewhiten_at_opt_gain_fcc_freq_real = 1.0
		derr_dewhiten_at_opt_gain_fcc_freq_imag = 0.0
		derr_dewhiten_at_esd_act_freq_real = 1.0
		derr_dewhiten_at_esd_act_freq_imag = 0.0

# If we're performing partial calibration, load the deltal filters
if CalibrationConfigs["calibrationmode"] == "Partial":
	reschaindelay = int(filters["res_corr_delay"])
	reschainfilt = filters["res_corr_filter"]
	tstdelay = pumuimdelay = int(filters["ctrl_corr_delay"])
	tstfilt = pumuimfilt = filters["ctrl_corr_filter"]
	tstchainsr = pumuimchainsr = int(filters["ctrl_corr_sr"])
	if dewhitening:
		tstdewhitensr = int(filters["deltal_tst_dewhiten_sr"])
		pumuimdewhitensr = int(filters["deltal_pumuim_dewhiten_sr"])
		tstdewhitendelay = int(filters["deltal_tst_dewhiten_delay"])
		pumuimdewhitendelay = int(filters["deltal_pumuim_dewhiten_delay"])
		tstdewhiten = filters["deltal_tst_dewhiten"]
		pumuimdewhiten = filters["deltal_pumuim_dewhiten"]
		resdewhitendelay = int(filters["deltal_res_dewhiten_delay"])
		resdewhiten = filters["deltal_res_dewhiten"]

	# Load the high-pass filter for h(t)
	try:
		act_highpass_delay = int(filters['ctrl_highpass_delay'])
		invsens_highpass_delay = int(filters['res_highpass_delay'])
		act_highpass = filters["ctrl_highpass"]
		invsens_highpass = filters["res_highpass"]
	except:
		act_highpass = []
		invsens_highpass = []
		invsens_highpass_delay = 0
		act_highpass_delay = 0

# If we're performing full calibration, load the actuation, sensing filters
if CalibrationConfigs["calibrationmode"] == "Full":
	tstchainsr = int(filters["actuation_tst_sr"])
	pumuimchainsr = int(filters["actuation_pumuim_sr"])
	tstdelay = int(filters["actuation_tst_delay"])
	pumuimdelay = int(filters["actuation_pumuim_delay"])
	tstfilt = filters["actuation_tst"]
	pumuimfilt = filters["actuation_pumuim"]
	reschaindelay = int(filters["inv_sens_delay"])
	reschainfilt = filters["inv_sensing"]
	if dewhitening:
		ctrldewhitendelay = int(filters["dewhiten_ctrl_delay"])
		ctrldewhiten = filters["dewhiten_ctrl"]
		ctrldewhitensr = int(filters["dewhiten_ctrl_sr"])
		resdewhitendelay = int(filters["dewhiten_err_delay"])
		resdewhiten = filters["dewhiten_err"]

	# Load the high-pass filter for h(t)
	try:
		act_highpass_delay = int(filters['actuation_highpass_delay'])
		invsens_highpass_delay = int(filters['invsens_highpass_delay'])
		act_highpass = filters["actuation_highpass"]
		invsens_highpass = filters["inv_sensing_highpass"]
	except:
		act_highpass = []
		invsens_highpass = []

#
# Set up the appropriate channel list. In this section, we also fill a list called headkeys
# that will be the keys for the dictionary holding each pipeline branch name, and we set up
# a dictionary that will be populated with pipeline branch names based on the channel list.
#

head_dict = {}
channel_list = []
headkeys = []

# If we are computing the CALIB_STATE_VECTOR, we need the ODC state vector
if compute_calib_statevector:
	channel_list.append((instrument, ChannelNames["inputdqchannel"]))
	headkeys.append("odcstatevector")

# If we are using the front-end EPICS records to either compute the TDCFs or the CALIB_STATE_VECTOR, we need to add those channels
# Needed for kappa_tst, kappa_pu, kappa_c and f_cc
if not factors_from_filters_file and (compute_kappatst or compute_kappapu or compute_kappap or compute_kappau or compute_kappac or compute_fcc or compute_fs or compute_srcq) or num_dq_epics > 0:
	channel_list.extend(((instrument, ChannelNames["ep1realchannel"]), (instrument, ChannelNames["ep1imagchannel"])))
	headkeys.extend(("EP1_real", "EP1_imag"))
# These are needed for kappa_pu and kappa_c and f_cc
if not factors_from_filters_file and (compute_kappac or compute_fcc or compute_kappapu or compute_fs or compute_srcq) or num_dq_epics > 3:
	channel_list.extend(((instrument, ChannelNames["ep2realchannel"]), (instrument, ChannelNames["ep2imagchannel"]), (instrument, ChannelNames["ep3realchannel"]), (instrument, ChannelNames["ep3imagchannel"]), (instrument, ChannelNames["ep4realchannel"]), (instrument, ChannelNames["ep4imagchannel"])))
	headkeys.extend(("EP2_real", "EP2_imag", "EP3_real", "EP3_imag", "EP4_real", "EP4_imag"))
# If we are computing either kappa_c or f_cc, we need some more EPICS records
if not factors_from_filters_file and (compute_kappac or compute_fcc or compute_fs or compute_srcq) or num_dq_epics > 8:
	channel_list.extend(((instrument, ChannelNames["ep6realchannel"]), (instrument, ChannelNames["ep6imagchannel"]), (instrument, ChannelNames["ep7realchannel"]), (instrument, ChannelNames["ep7imagchannel"]), (instrument, ChannelNames["ep8realchannel"]), (instrument, ChannelNames["ep8imagchannel"]), (instrument, ChannelNames["ep9realchannel"]), (instrument, ChannelNames["ep9imagchannel"])))
	headkeys.extend(("EP6_real", "EP6_imag", "EP7_real", "EP7_imag", "EP8_real", "EP8_imag", "EP9_real", "EP9_imag"))

# EP10 is needed to remove the ESD line
if not factors_from_filters_file and remove_esd_act_line or num_dq_epics > 9:
	channel_list.extend(((instrument, ChannelNames["ep10realchannel"]), (instrument, ChannelNames["ep10imagchannel"])))
	headkeys.extend(("EP10_real", "EP10_imag"))

# These are needed if we compute the optical spring frequency and/or Q-factor of the Signal Recycling Cavity (SRC)
if not factors_from_filters_file and (compute_fs or compute_srcq) or num_dq_epics > 13:
	channel_list.extend(((instrument, ChannelNames["ep11realchannel"]), (instrument, ChannelNames["ep11imagchannel"]), (instrument, ChannelNames["ep12realchannel"]), (instrument, ChannelNames["ep12imagchannel"]), (instrument, ChannelNames["ep13realchannel"]), (instrument, ChannelNames["ep13imagchannel"]), (instrument, ChannelNames["ep14realchannel"]), (instrument, ChannelNames["ep14imagchannel"])))
	headkeys.extend(("EP11_real", "EP11_imag", "EP12_real", "EP12_imag", "EP13_real", "EP13_imag", "EP14_real", "EP14_imag"))

# If we are using pre-computed coherence to gate kappas
if use_coherence:
	if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		channel_list.extend(((instrument, ChannelNames["cohuncsusline1channel"]), (instrument, ChannelNames["cohuncpcalyline1channel"]), (instrument, ChannelNames["cohuncdarmline1channel"])))
		headkeys.extend(("pcaly_line1_coh", "sus_coh", "darm_coh"))
	if compute_kappac or compute_fcc or compute_fs or compute_srcq:
		channel_list.append((instrument, ChannelNames["cohuncpcalyline2channel"]))
		headkeys.append("pcaly_line2_coh")

# We also need excitation channels for computing kappas
if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq or remove_esd_act_line:
	channel_list.append((instrument, ChannelNames["tstexcchannel"]))
	headkeys.append("tstexc")
if compute_kappac or compute_fcc or compute_fs or compute_srcq or compute_kappapu:
	channel_list.append((instrument, ChannelNames["darmexcchannel"]))
	headkeys.append("exc")

# We need to make sure we have DARM_ERR and the PCAL channel for computing \kappas
if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
	channel_list.append((instrument, ChannelNames["pcalchannel"]))
	headkeys.append("pcal")
	if CalibrationConfigs["calibrationmode"] == "Partial":
		channel_list.append((instrument, ChannelNames["darmerrchannel"]))
		headkeys.append("darm_err")

# For full calibration we need DARM_ERR and DARM_CTRL as our input channels
if CalibrationConfigs["calibrationmode"] == "Full":
	channel_list.extend(((instrument, ChannelNames["darmerrchannel"]), (instrument, ChannelNames["darmctrlchannel"])))
	headkeys.extend(("res", "ctrl"))
# For partial calibration we need DELTAL_TST, DELTAL_PUM, DELTAL_UIM, and DELTAL_RES
elif CalibrationConfigs["calibrationmode"] == "Partial":
	channel_list.extend(((instrument, ChannelNames["deltalreschannel"]), (instrument, ChannelNames["deltaltstchannel"]), (instrument, ChannelNames["deltalpumchannel"]), (instrument, ChannelNames["deltaluimchannel"])))
	headkeys.extend(("res", "tst", "pum", "uim"))

# If we are removing 60 Hz lines and harmonics, add the witness channel
if remove_power_lines:
	channel_list.append((instrument, ChannelNames["powerlineschannel"]))
	headkeys.append("powerlines")

# If we are using witness channels to clean h(t), add those to the channel list
if ChannelNames["witnesschannellist"] != "None":
	witness_channel_list = ChannelNames["witnesschannellist"].split(';')
	witness_notch_frequencies = DataCleaningConfigs["witnessnotchfrequencies"].split(';')
	witness_rates = SampleRates["witnesschannelsr"].split(';')
	if len(witness_channel_list) != len(witness_notch_frequencies) or len(witness_channel_list) != len(witness_rates):
		raise ValueError("WitnessChannelList, WitnessChannelSR, and WitnessNotchFrequencies must all be the same length, i.e, they must all have the same number of semicolons (;)")
	for i in range(0, len(witness_channel_list)):
		witness_channel_list[i] = witness_channel_list[i].split(',')
		for j in range(0, len(witness_channel_list[i])):
			channel_list.append((instrument, witness_channel_list[i][j]))
			headkeys.append(witness_channel_list[i][j])
		witness_rates[i] = int(witness_rates[i])
		witness_notch_frequencies[i] = witness_notch_frequencies[i].split(',')
		if len(witness_notch_frequencies[i]) <= 1:
			witness_notch_frequencies[i] = []
		else:
			for j in range(0, len(witness_notch_frequencies[i])):
				witness_notch_frequencies[i][j] = float(witness_notch_frequencies[i][j])
else:
	witness_channel_list = None


####################################################################################################
####################################### Main Pipeline ##############################################
####################################################################################################

pipeline = Gst.Pipeline(name="gstlal_compute_strain")
mainloop = GObject.MainLoop()
handler = simplehandler.Handler(mainloop, pipeline)

# 
# Turn off debugging tools or verboseness
#

pipeparts.mkchecktimestamps = lambda pipeline, src, *args: src # comment this line out to turn on the checktimestamps debugging
if not verbose:
	pipeparts.mkprogressreport = lambda pipeline, src, *args: src

#
# Read in data from frames or shared memory
#

if InputConfigs["datasource"] == "lvshm": # Data is to be read from shared memory; "low-latency" mode
	src = pipeparts.mklvshmsrc(pipeline, shm_name = InputConfigs["shmpartition"], assumed_duration = int(InputConfigs["inputframduration"]))
elif InputConfigs["datasource"] == "frames": # Data is to be read from frame files; "offline" mode
	src = pipeparts.mklalcachesrc(pipeline, location = InputConfigs["framecache"], cache_dsc_regex = instrument)

#
# Hook up the relevant channels to the demuxer
#

demux = pipeparts.mkframecppchanneldemux(pipeline, src, do_file_checksum = file_check_sum, skip_bad_files = skip_bad_files, channel_list = map("%s:%s".__mod__, channel_list))

# Write the pipeline graph after pads have been hooked up to the demuxer
if DebuggingConfigs["pipelinegraphfilename"] != "None":
	demux.connect("no-more-pads", write_graph)	


# Get everything hooked up and fill in discontinuities
for key, chan in zip(headkeys, channel_list):
	head_dict[key] = calibration_parts.hook_up(pipeline, demux, chan[1], instrument, float(PipelineConfigs["bufferlength"]))

#
# TIME-VARYING FACTORS COMPUTATIONS
#

for key in headkeys:
	if key.startswith("EP"):
		head_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		head_dict[key] = calibration_parts.mkresample(pipeline, head_dict[key], 0, False, compute_calib_factors_caps)
		head_dict[key] = pipeparts.mktee(pipeline, head_dict[key])

if use_coherence:
	if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		pcaly_line1_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line1_coh"], coh_caps, "pcaly_line1_coh")
		pcaly_line1_coh = calibration_parts.mkresample(pipeline, pcaly_line1_coh, 0, False, compute_calib_factors_caps)
		sus_coh = calibration_parts.caps_and_progress(pipeline, head_dict["sus_coh"], coh_caps, "sus_coh")
		sus_coh = calibration_parts.mkresample(pipeline, sus_coh, 0, False, compute_calib_factors_caps)
		darm_coh = calibration_parts.caps_and_progress(pipeline, head_dict["darm_coh"], coh_caps, "darm_coh")
		darm_coh = calibration_parts.mkresample(pipeline, darm_coh, 0, False, compute_calib_factors_caps)
		pcaly_line1_coh = pipeparts.mktee(pipeline, pcaly_line1_coh)
		sus_coh = pipeparts.mktee(pipeline, sus_coh)
		darm_coh = pipeparts.mktee(pipeline, darm_coh)
	if compute_kappac or compute_fcc or compute_fs or compute_srcq:
		pcaly_line2_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line2_coh"], coh_caps, "pcaly_line2_coh")
		pcaly_line2_coh = calibration_parts.mkresample(pipeline, pcaly_line2_coh, 0, False, compute_calib_factors_caps)
		pcaly_line2_coh = pipeparts.mktee(pipeline, pcaly_line2_coh)

if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq or remove_esd_act_line:
	tstexccaps = "audio/x-raw, format=F64LE, rate=%d" % tst_exc_sr
	tstexc = calibration_parts.caps_and_progress(pipeline, head_dict["tstexc"], tstexccaps, "tstexc")

if compute_kappac or compute_fcc or compute_kappapu or compute_fs or compute_srcq:
	exc = calibration_parts.caps_and_progress(pipeline, head_dict["exc"], hoft_caps, "exc")

# Set up computations for \kappa_tst,\kappa_c, \kappa_pu, f_cc, if applicable
if compute_kappac or compute_fcc or compute_kappatst or compute_kappapu or compute_srcq or compute_fs:

	# pcal excitation channel, which will be demodulated
	pcal = calibration_parts.caps_and_progress(pipeline, head_dict["pcal"], hoft_caps, "pcal")
	pcaltee = pipeparts.mktee(pipeline, pcal)

	# DARM_ERR channel, which will have followed different paths if we're doing full vs. partial calibration
	if CalibrationConfigs["calibrationmode"] == "Full":
		darm_err = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "darm_err")
	else:
		darm_err = calibration_parts.caps_and_progress(pipeline, head_dict["darm_err"], hoft_caps, "darm_err")
	derrtee = pipeparts.mktee(pipeline, darm_err)

	# demodulate the PCAL channel and apply the PCAL correction factor at the DARM actuation line frequency
	pcal_at_darm_act_freq = calibration_parts.demodulate(pipeline, pcaltee, darm_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency, prefactor_real = pcal_corr_at_darm_act_freq_real, prefactor_imag = pcal_corr_at_darm_act_freq_imag)
	pcal_at_darm_act_freq = pipeparts.mktee(pipeline, pcal_at_darm_act_freq)
	if remove_cal_lines:
		# This will save having to demodulate it again
		pcal_line_removal_dict["pcal1"][3] = pcal_at_darm_act_freq

	# demodulate DARM_ERR at the DARM actuation line frequency
	derr_at_darm_act_freq = calibration_parts.demodulate(pipeline, derrtee, darm_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency)
	if dewhitening:
		# dewhiten DARM_ERR at the DARM actuation line frequency
		derr_at_darm_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_darm_act_freq, derr_dewhiten_at_darm_act_freq_real, derr_dewhiten_at_darm_act_freq_imag)
	if compute_kappapu or compute_kappac or compute_fcc or compute_srcq or compute_fs:
		derr_at_darm_act_freq = pipeparts.mktee(pipeline, derr_at_darm_act_freq)

	# demodulate the TST excitation channel at the ESD actuation line frequency
	tstexc_at_esd_act_freq = calibration_parts.demodulate(pipeline, tstexc, esd_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency)
	if remove_esd_act_line:
		tstexc_at_esd_act_freq = pipeparts.mktee(pipeline, tstexc_at_esd_act_freq)

	# demodulate DARM_ERR at the ESD actuation line frequency
	derr_at_esd_act_freq = calibration_parts.demodulate(pipeline, derrtee, esd_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency)
	if dewhitening:
		# dewhiten DARM_ERR at the ESD actuation line frequency
		derr_at_esd_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_esd_act_freq, derr_dewhiten_at_esd_act_freq_real, derr_dewhiten_at_esd_act_freq_imag)

	# compute kappa_tst, either using reference factors from the filters file or reading them from EPICS channels
	if not factors_from_filters_file:
		EP1 = calibration_parts.merge_into_complex(pipeline, head_dict["EP1_real"], head_dict["EP1_imag"])
		ktst = calibration_parts.compute_kappatst(pipeline, derr_at_esd_act_freq, tstexc_at_esd_act_freq, pcal_at_darm_act_freq, derr_at_darm_act_freq, EP1)
	elif factors_from_filters_file:
		ktst = calibration_parts.compute_kappatst_from_filters_file(pipeline, derr_at_esd_act_freq, tstexc_at_esd_act_freq, pcal_at_darm_act_freq, derr_at_darm_act_freq, EP1_real, EP1_imag)

	ktst = pipeparts.mktee(pipeline, ktst)

	# Now apply the gating and smoothing to \kappa_tst
	if compute_kappatst:
		smooth_ktst_nogate = pipeparts.mkgeneric(pipeline, ktst, "lal_smoothkappas", default_kappa_re = expected_kappatst_real, default_kappa_im = expected_kappatst_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency)
		smooth_ktstR_nogate, smooth_ktstI_nogate = calibration_parts.split_into_real(pipeline, smooth_ktst_nogate)

		if use_coherence:
			# Gate kappa_tst with the coherence of the PCALY_line1 line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_tst with the coherence of the suspension line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_tst with the coherence of the DARM line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

			# Smooth kappa_tst
			smooth_ktst = calibration_parts.smooth_complex_kappas(pipeline, ktst_gated, expected_kappatst_real, expected_kappatst_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency)

		else:
			# Smooth kappa_tst
			smooth_ktst = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, ktst, kappatst_real_ok_var, kappatst_imag_ok_var, expected_kappatst_real, expected_kappatst_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency)

		smooth_ktsttee = pipeparts.mktee(pipeline, smooth_ktst)
		smooth_ktstR, smooth_ktstI = calibration_parts.split_into_real(pipeline, smooth_ktsttee)

		smooth_ktstRtee = pipeparts.mktee(pipeline, smooth_ktstR)
		smooth_ktstItee = pipeparts.mktee(pipeline, smooth_ktstI)

# If we're also computing \kappa_pu, \kappa_c, f_cc, f_s, or Q, keep going
if compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
	# demodulate excitation channel at PU actuation line frequency
	exc_at_pu_act_freq = calibration_parts.demodulate(pipeline, exc, pu_act_esd_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency)

	# demodulate DARM_ERR at PU actuation line frequency
	derr_at_pu_act_freq = calibration_parts.demodulate(pipeline, derrtee, pu_act_esd_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency)
	if dewhitening:
		# dewhiten DARM_ERR at the PU actuation line frequency
		derr_at_pu_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_pu_act_freq, derr_dewhiten_at_pu_act_freq_real, derr_dewhiten_at_pu_act_freq_imag)

	# compute the factor Afctrl that will be used in the computation of kappa_pu and kappa_a, either using reference factors from the filters file or reading them from EPICS channels
	if not factors_from_filters_file:
		EP2 = calibration_parts.merge_into_complex(pipeline, head_dict["EP2_real"], head_dict["EP2_imag"])
		EP3 = calibration_parts.merge_into_complex(pipeline, head_dict["EP3_real"], head_dict["EP3_imag"])
		EP4 = calibration_parts.merge_into_complex(pipeline, head_dict["EP4_real"], head_dict["EP4_imag"])
		afctrl = calibration_parts.compute_afctrl(pipeline, derr_at_pu_act_freq, exc_at_pu_act_freq, pcal_at_darm_act_freq, derr_at_darm_act_freq, EP2)
	elif factors_from_filters_file:
		afctrl = calibration_parts.compute_afctrl_from_filters_file(pipeline, derr_at_pu_act_freq, exc_at_pu_act_freq, pcal_at_darm_act_freq, derr_at_darm_act_freq, EP2_real, EP2_imag)

	# \kappa_pu calcuation, which needs to happen for any of the other kappas to be computed
	if not factors_from_filters_file:
		kpu = calibration_parts.compute_kappapu(pipeline, EP3, afctrl, ktst, EP4)
	elif factors_from_filters_file:
		kpu = calibration_parts.compute_kappapu_from_filters_file(pipeline, EP3_real, EP3_imag, afctrl, ktst, EP4_real, EP4_imag)

	kpu = pipeparts.mktee(pipeline, kpu)

	# Now apply the gating and smoothing to \kappa_pu
	if compute_kappapu:
		smooth_kpu_nogate = pipeparts.mkgeneric(pipeline, kpu, "lal_smoothkappas", default_kappa_re = expected_kappapu_real, default_kappa_im = expected_kappapu_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency)
		smooth_kpuR_nogate, smooth_kpuI_nogate = calibration_parts.split_into_real(pipeline, smooth_kpu_nogate)

		if use_coherence:
			# Gate kappa_pu with the coherence of the DARM line
			kpu_gated = calibration_parts.mkgate(pipeline, kpu, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_pu with the coherence of the PCALY_line1 line
			kpu_gated = calibration_parts.mkgate(pipeline, kpu_gated, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_pu with the coherence of the suspension coherence
			kpu_gated = calibration_parts.mkgate(pipeline, kpu_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Smooth kappa_pu
			smooth_kpu = calibration_parts.smooth_complex_kappas(pipeline, kpu_gated, expected_kappapu_real, expected_kappapu_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency)

		else:
			# Smooth kappa_pu
			smooth_kpu = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, kpu, kappapu_real_ok_var, kappapu_imag_ok_var, expected_kappapu_real, expected_kappapu_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency)

		smooth_kputee = pipeparts.mktee(pipeline, smooth_kpu)
		smooth_kpuR, smooth_kpuI = calibration_parts.split_into_real(pipeline, smooth_kputee)

		smooth_kpuRtee = pipeparts.mktee(pipeline, smooth_kpuR)
		smooth_kpuItee = pipeparts.mktee(pipeline, smooth_kpuI)	

# Compute \kappa_c and f_cc
if compute_kappac or compute_fcc or compute_fs or compute_srcq:
	# demodulate the PCAL channel and apply the PCAL correction factor at optical gain and f_cc line frequency
	pcal_at_opt_gain_freq = calibration_parts.demodulate(pipeline, pcaltee, opt_gain_fcc_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency, prefactor_real = pcal_corr_at_opt_gain_fcc_freq_real, prefactor_imag = pcal_corr_at_opt_gain_fcc_freq_imag)
	if remove_cal_lines:
		# This will save having to demodulate it again
		pcal_at_opt_gain_freq = pipeparts.mktee(pipeline, pcal_at_opt_gain_freq)
		pcal_line_removal_dict["pcal2"][3] = pcal_at_opt_gain_freq

	# demodulate DARM_ERR at optical gain and f_cc line frequency
	derr_at_opt_gain_freq = calibration_parts.demodulate(pipeline, derrtee, opt_gain_fcc_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency)
	if dewhitening:
		# dewhiten DARM_ERR at optical gain and f_cc line frequency
		derr_at_opt_gain_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_opt_gain_freq, derr_dewhiten_at_opt_gain_fcc_freq_real, derr_dewhiten_at_opt_gain_fcc_freq_imag)

	# Compute the factor S which will be used for the kappa_c and f_cc calculations
	# \kappa_tst and \kappa_pu need to be evaluated at the higher pcal line frequency
	ktst_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, ktst, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / esd_act_line_freq)
	kpu_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kpu, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / pu_act_esd_line_freq)
	if not factors_from_filters_file:
		EP6 = calibration_parts.merge_into_complex(pipeline, head_dict["EP6_real"], head_dict["EP6_imag"])
		EP7 = calibration_parts.merge_into_complex(pipeline, head_dict["EP7_real"], head_dict["EP7_imag"])
		EP8 = calibration_parts.merge_into_complex(pipeline, head_dict["EP8_real"], head_dict["EP8_imag"])
		EP9 = calibration_parts.merge_into_complex(pipeline, head_dict["EP9_real"], head_dict["EP9_imag"])
		S = calibration_parts.compute_S(pipeline, EP6, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7, ktst_at_opt_gain_freq, EP8, kpu_at_opt_gain_freq, EP9)
	elif factors_from_filters_file:
		S = calibration_parts.compute_S_from_filters_file(pipeline, EP6_real, EP6_imag, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7_real, EP7_imag, ktst_at_opt_gain_freq, EP8_real, EP8_imag, kpu_at_opt_gain_freq, EP9_real, EP9_imag)

	S = pipeparts.mktee(pipeline, S)

	SR, SI = calibration_parts.split_into_real(pipeline, S)

	if compute_kappac and compute_fcc:
		SR = pipeparts.mktee(pipeline, SR)
		SI = pipeparts.mktee(pipeline, SI)

	# compute kappa_c
	if compute_kappac or compute_srcq or compute_fs:
		kc = calibration_parts.compute_kappac(pipeline, SR, SI)
	if compute_kappac:
		kc = pipeparts.mktee(pipeline, kc)
		smooth_kc_nogate = pipeparts.mkgeneric(pipeline, kc, "lal_smoothkappas", default_kappa_re = expected_kappac, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency)

		if use_coherence:
			# Gate kappa_c with the coherence of all four of the calibration lines
			kc_gated = calibration_parts.mkgate(pipeline, kc, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			kc_gated = calibration_parts.mkgate(pipeline, kc_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			kc_gated = calibration_parts.mkgate(pipeline, kc_gated, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			kc_gated = calibration_parts.mkgate(pipeline, kc_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

			# Smooth kappa_c
			smooth_kc = calibration_parts.smooth_kappas(pipeline, kc_gated, expected_kappac, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency)

		else:
			# Smooth kappa_c
			smooth_kc = calibration_parts.smooth_kappas_no_coherence(pipeline, kc, kappac_var, expected_kappac, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency)

		smooth_kctee = pipeparts.mktee(pipeline, smooth_kc)

	# compute f_cc
	if compute_fcc or compute_srcq or compute_fs:
		fcc = calibration_parts.compute_fcc(pipeline, SR, SI, opt_gain_fcc_line_freq)
	if compute_fcc:
		fcc = pipeparts.mktee(pipeline, fcc)
		smooth_fcc_nogate = pipeparts.mkgeneric(pipeline, fcc, "lal_smoothkappas", default_kappa_re = fcc_default, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency)

		if use_coherence:
			# Gate f_cc with all four of the calibration lines
			fcc_gated = calibration_parts.mkgate(pipeline, fcc, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

			# Smooth f_cc
			smooth_fcc = calibration_parts.smooth_kappas(pipeline, fcc_gated, fcc_default, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency)
		else:
			# Smooth f_cc
			smooth_fcc = calibration_parts.smooth_kappas_no_coherence(pipeline, fcc, fcc_var, fcc_default, median_smoothing_samples, factors_average_samples, kappas_default_to_median, filter_latency)

		smooth_fcctee = pipeparts.mktee(pipeline, smooth_fcc)

#		if apply_fcc:
#			update_fcc = pipeparts.mkgeneric(pipeline, smooth_fcctee, "lal_fcc_update", data_rate = hoft_sr, fcc_rate = compute_factors_sr, fcc_model = fcc_default, averaging_time = float(TDCFConfigs["fccaveragingtime"]), filter_duration = float(TDCFConfigs["fccfilterduration"]))
#			pipeparts.mkfakesink(pipeline, update_fcc)

# compute f_s and Q
if compute_fs or compute_srcq:
	expected_Xi = complex((fs_default * fs_default - 1j * src_pcal_line_freq * fs_default / srcQ_default) / (src_pcal_line_freq * src_pcal_line_freq))
	Xi_real_ok_var = float((pow(fs_default + fs_var, 2) - pow(fs_default, 2.0)) / pow(src_pcal_line_freq, 2))
	Xi_imag_ok_var = float(fs_var / (srcQ_default * src_pcal_line_freq))

	# demodulate PCAL channel and apply the PCAL correction factor at SRC detuning line frequency
	pcal_at_src_freq = calibration_parts.demodulate(pipeline, pcaltee, src_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency, prefactor_real = pcal_corr_at_src_freq_real, prefactor_imag = pcal_corr_at_src_freq_imag)
	if "pcal4" in pcal_line_removal_dict:
		# This will save having to demodulate it again
		pcal_at_src_freq = pipeparts.mktee(pipeline, pcal_at_src_freq)
		pcal_line_removal_dict["pcal4"][3] = pcal_at_src_freq

	# demodulate DARM_ERR at SRC detuning line frequency
	derr_at_src_freq = calibration_parts.demodulate(pipeline, derrtee, src_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency)

	# Compute the factor Xi which will be used for the f_s and src_Q calculations
	# \kappa_tst and \kappa_pu need to be evaluated at the SRC pcal line frequency
	ktst_at_src_freq = pipeparts.mkgeneric(pipeline, ktst, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / esd_act_line_freq)
	kpu_at_src_freq = pipeparts.mkgeneric(pipeline, kpu, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / pu_act_esd_line_freq)
	if not factors_from_filters_file:
		EP11 = calibration_parts.merge_into_complex(pipeline, head_dict["EP11_real"], head_dict["EP11_imag"])
		EP12 = calibration_parts.merge_into_complex(pipeline, head_dict["EP12_real"], head_dict["EP12_imag"])
		EP13 = calibration_parts.merge_into_complex(pipeline, head_dict["EP13_real"], head_dict["EP13_imag"])
		EP14 = calibration_parts.merge_into_complex(pipeline, head_dict["EP14_real"], head_dict["EP14_imag"])
		Xi = calibration_parts.compute_Xi(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11, EP12, EP13, EP14, ktst_at_src_freq, kpu_at_src_freq, kc, fcc)
	elif factors_from_filters_file:
		Xi = calibration_parts.compute_Xi_from_filters_file(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11_real, EP11_imag, EP12_real, EP12_imag, EP13_real, EP13_imag, EP14_real, EP14_imag, ktst_at_src_freq, kpu_at_src_freq, kc, fcc)

	Xi = pipeparts.mktee(pipeline, Xi)
	smooth_Xi_nogate = pipeparts.mkgeneric(pipeline, Xi, "lal_smoothkappas", default_kappa_re = float(numpy.real(expected_Xi)), default_kappa_im = float(numpy.imag(expected_Xi)), array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency)

	if use_coherence:
		# Gate Xi with all coherences. We apply the gating and smoothing here since Q depends on the inverse of Im(Xi), which fluctuates about zero.
		Xi_gated = calibration_parts.mkgate(pipeline, Xi, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

		smooth_Xi = calibration_parts.smooth_complex_kappas(pipeline, Xi_gated, float(numpy.real(expected_Xi)), float(numpy.imag(expected_Xi)), median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency)

	else:
		smooth_Xi = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, Xi, Xi_real_ok_var, Xi_real_ok_var, float(numpy.real(expected_Xi)), float(numpy.imag(expected_Xi)), median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency)

	if not compute_srcq:
		# the imaginary part is only used to compute Q
		smooth_XiR = pipeparts.mkgeneric(pipeline, smooth_Xi, "creal")
		smooth_XiR_nogate = pipeparts.mkgeneric(pipeline, smooth_Xi_nogate, "creal")
	else:
		smooth_XiR, smooth_XiI = calibration_parts.split_into_real(pipeline, smooth_Xi)
		smooth_XiR_nogate, smooth_XiI_nogate = calibration_parts.split_into_real(pipeline, smooth_Xi_nogate)

	smooth_sqrtXiR = calibration_parts.mkpow(pipeline, smooth_XiR, exponent = 0.5)
	smooth_sqrtXiR_nogate = calibration_parts.mkpow(pipeline, smooth_XiR_nogate, exponent = 0.5)

	if compute_fs and compute_srcq:
		smooth_sqrtXiR = pipeparts.mktee(pipeline, smooth_sqrtXiR)
		smooth_sqrtXiR_nogate = pipeparts.mktee(pipeline, smooth_sqrtXiR_nogate)

	# compute f_s
	if compute_fs:
		smooth_fs = pipeparts.mkaudioamplify(pipeline, smooth_sqrtXiR, src_pcal_line_freq)
		smooth_fs_nogate = pipeparts.mkaudioamplify(pipeline, smooth_sqrtXiR_nogate, src_pcal_line_freq)

		if compute_calib_statevector or apply_fs:
			smooth_fs = pipeparts.mktee(pipeline, smooth_fs)

	# compute SRC Q_inv
	if compute_srcq:
		smooth_sqrtXiR_inv = calibration_parts.mkpow(pipeline, smooth_sqrtXiR, exponent = -1.0)
		smooth_sqrtXiR_inv_nogate = calibration_parts.mkpow(pipeline, smooth_sqrtXiR_nogate, exponent = -1.0)
		smooth_srcQ_inv = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, smooth_sqrtXiR_inv, pipeparts.mkaudioamplify(pipeline, smooth_XiI, -1.0)))
		smooth_srcQ_inv_nogate = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, smooth_sqrtXiR_inv_nogate, pipeparts.mkaudioamplify(pipeline, smooth_XiI_nogate, -1.0)))

		# We don't want to correct for Q < 0, since this is nonphysical and such a correction would most likely have the wrong frequency-dependence.
		if apply_srcq:
			smooth_srcQ_inv = pipeparts.mkgeneric(pipeline, smooth_srcQ_inv, "lal_insertgap", bad_data_intervals = [1e-35, 1e35], replace_value = 1e-35, insert_gap = False)

		if compute_calib_statevector or apply_srcq:
			smooth_srcQ_inv = pipeparts.mktee(pipeline, smooth_srcQ_inv)

#
# TIME-VARYING FACTORS COMPENSATIONS
#

if apply_complex_kappapu:
	# We will apply an adaptive FIR filter to the PUM/UIM component of the actuation that includes time-dependence in the gain and computational time delay
	adaptive_pumuim_filter = pipeparts.mkgeneric(pipeline, smooth_kputee, "lal_adaptivefirfilt", update_samples = int(actuation_filter_update_time * compute_factors_sr), average_samples = int(actuation_filter_averaging_time * compute_factors_sr), phase_measurement_frequency = pu_act_esd_line_freq, static_filter = pumuimfilt, variable_filter_length = len(pumuimfilt), adaptive_filter_length = len(pumuimfilt), tukey_param = 0.5, filter_sample_rate = pumuimchainsr)

if apply_complex_kappatst:
	# We will apply an adaptive FIR filter to the TST component of the actuation that includes time-dependence in the gain and computational time delay
	adaptive_tst_filter = pipeparts.mkgeneric(pipeline, smooth_ktsttee, "lal_adaptivefirfilt", update_samples = int(actuation_filter_update_time * compute_factors_sr), average_samples = int(actuation_filter_averaging_time * compute_factors_sr), phase_measurement_frequency = esd_act_line_freq, static_filter = tstfilt, variable_filter_length = len(tstfilt), adaptive_filter_length = len(tstfilt), tukey_param = 0.5, filter_sample_rate = tstchainsr)

if apply_fcc or apply_fs or apply_srcq:
	# We will apply an adaptive FIR filter to DARM_ERR that allows corrections for poles, zeros, and gain
	# We need to track the number of time-dependent and static zeros and poles in the adaptive filter
	variable_invsens_zeros = 0
	static_invsens_poles = []
	tdep_zpk = []
	if apply_fcc:
		variable_invsens_zeros += 1
		# The real part of the pole is 0.0, and fcc_default is the imaginary part
		static_invsens_poles.extend([fcc_default, 0.0])

		# (1 + i * f / f_cc) is a zero in the variable inverse sensing filter
		complex_fcc = pipeparts.mkmatrixmixer(pipeline, smooth_fcctee, matrix = [[1.0, 0.0]])
		complex_fcc = pipeparts.mktogglecomplex(pipeline, complex_fcc)

		tdep_zpk.append(complex_fcc)

	# There are two zeros that depend on fs and Q, both of which depend on both fs and Q
	if apply_fs or apply_srcq:
		variable_invsens_zeros += 2
		static_invsens_poles.extend([(fs_default / 2.0) * (pow(srcQ_default, -1.0) + pow(pow(srcQ_default, -2.0) + 4.0, 0.5)), 0.0])
		static_invsens_poles.extend([(fs_default / 2.0) * (pow(srcQ_default, -1.0) - pow(pow(srcQ_default, -2.0) + 4.0, 0.5)), 0.0])

	if apply_fs and apply_srcq:
		# The variable zeros depend on the computed values of fs and Q
		Q_inv_squared = calibration_parts.mkpow(pipeline, smooth_srcQ_inv, exponent = 2.0)
		sqrt_Q_inv_squared_plus4 = calibration_parts.mkpow(pipeline, pipeparts.mkgeneric(pipeline, Q_inv_squared, "lal_add_constant", value = 4.0), exponent = 0.5)
		sqrt_Q_inv_squared_plus4 = pipeparts.mktee(pipeline, sqrt_Q_inv_squared_plus4)

		SRC_zero1 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, sqrt_Q_inv_squared_plus4))
		SRC_zero1 = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, SRC_zero1, smooth_fs))
		SRC_zero1 = pipeparts.mkmatrixmixer(pipeline, SRC_zero1, matrix = [[0.5, 0.0]])
		SRC_zero1 = pipeparts.mktogglecomplex(pipeline, SRC_zero1)

		SRC_zero2 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, pipeparts.mkaudioamplify(pipeline, sqrt_Q_inv_squared_plus4, -1.0)))
		SRC_zero2 = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, SRC_zero2, smooth_fs))
		SRC_zero2 = pipeparts.mkmatrixmixer(pipeline, SRC_zero2, matrix = [[0.5, 0.0]])
		SRC_zero2 = pipeparts.mktogglecomplex(pipeline, SRC_zero2)

		tdep_zpk.extend([SRC_zero1, SRC_zero2])

		# This will be added into tdep_zpk at the end, as required by lal_adaptivefirfilt
		variable_invsens_gain = pipeparts.mkaudioamplify(pipeline, calibration_parts.mkpow(pipeline, smooth_fs, exponent = 2.0), pow(fs_default, -2.0))

	elif apply_fs:
		# The variable zeros depend on the computed value of fs and the model value of Q
		Q_factor1 = (pow(srcQ_default, -1.0) + pow(pow(srcQ_default, -2.0) + 4.0, 0.5)) / 2.0
		Q_factor2 = (pow(srcQ_default, -1.0) - pow(pow(srcQ_default, -2.0) + 4.0, 0.5)) / 2.0

		SRC_zero1 = pipeparts.mkmatrixmixer(pipeline, smooth_fs, matrix = [[Q_factor1, 0.0]])
		SRC_zero1 = pipeparts.mktogglecomplex(pipeline, SRC_zero1)

		SRC_zero2 = pipeparts.mkmatrixmixer(pipeline, smooth_fs, matrix = [[Q_factor2, 0.0]])
		SRC_zero2 = pipeparts.mktogglecomplex(pipeline, SRC_zero2)

		tdep_zpk.extend([SRC_zero1, SRC_zero2])

		# This will be added into tdep_zpk at the end, as required by lal_adaptivefirfilt
		variable_invsens_gain = pipeparts.mkaudioamplify(pipeline, calibration_parts.mkpow(pipeline, smooth_fs, exponent = 2.0), pow(fs_default, -2.0))

	elif apply_srcq:
		# The variable zeros depend on the model value of fs and the computed value of Q
		Q_inv_squared = calibration_parts.mkpow(pipeline, smooth_srcQ_inv, exponent = 2.0)
		sqrt_Q_inv_squared_plus4 = calibration_parts.mkpow(pipeline, pipeparts.mkgeneric(pipeline, Q_inv_squared, "lal_add_constant", value = 4.0), exponent = 0.5)
		sqrt_Q_inv_squared_plus4 = pipeparts.mktee(pipeline, sqrt_Q_inv_squared_plus4)

		SRC_zero1 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, sqrt_Q_inv_squared_plus4))
		SRC_zero1 = pipeparts.mkmatrixmixer(pipeline, SRC_zero1, matrix = [[0.5 * fs_default, 0.0]])
		SRC_zero1 = pipeparts.mktogglecomplex(pipeline, SRC_zero1)

		SRC_zero2 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, pipeparts.mkaudioamplify(pipeline, sqrt_Q_inv_squared_plus4, -1.0)))
		SRC_zero2 = pipeparts.mkmatrixmixer(pipeline, SRC_zero2, matrix = [[0.5 * fs_default, 0.0]])
		SRC_zero2 = pipeparts.mktogglecomplex(pipeline, SRC_zero2)

		tdep_zpk.extend([SRC_zero1, SRC_zero2])

	if apply_kappac:
		# We divide the gain by kappa_c
		kappac_inv = calibration_parts.mkpow(pipeline, smooth_kctee, exponent = -1.0)
		if apply_fs:
			variable_invsens_gain = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, variable_invsens_gain, kappac_inv))
		else:
			variable_invsens_gain = kappac_inv

	if apply_kappac or apply_fs:
		# Now add the gain into the list of corrections
		variable_invsens_gain = pipeparts.mkmatrixmixer(pipeline, variable_invsens_gain, matrix = [[1.0, 0.0]])
		variable_invsens_gain = pipeparts.mktogglecomplex(pipeline, variable_invsens_gain)
		tdep_zpk.append(variable_invsens_gain)

	# Now interleave the correction channels in tdep_zpk and feed them into lal_adaptivefirfilt to update the inverse sensing filter
	tdep_zpk = calibration_parts.mkinterleave(pipeline, tdep_zpk, complex_data = True)
	adaptive_invsens_filter = pipeparts.mkgeneric(pipeline, tdep_zpk, "lal_adaptivefirfilt", update_samples = int(sensing_filter_update_time * compute_factors_sr), average_samples = int(sensing_filter_averaging_time * compute_factors_sr), num_zeros = variable_invsens_zeros, num_poles = 0, static_poles = static_invsens_poles, static_filter = reschainfilt, variable_filter_length = len(reschainfilt), adaptive_filter_length = len(reschainfilt), tukey_param = 0.5, filter_sample_rate = hoft_sr)

#
# CONTROL BRANCH
#

# zero out filter settling samples
tst_filter_settle_time = 0.0
tst_filter_latency = 0.0
pumuim_filter_settle_time = 0.0
pumuim_filter_latency = 0.0

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank
if CalibrationConfigs["calibrationmode"] == "Partial":
	# enforce caps on actuation channels and set up progress report if verbose is on
	tst = calibration_parts.caps_and_progress(pipeline, head_dict["tst"], ctrl_caps, "tst")
	tsttee = pipeparts.mktee(pipeline, tst)
	pum = calibration_parts.caps_and_progress(pipeline, head_dict["pum"], ctrl_caps, "pum")
	pumtee = pipeparts.mktee(pipeline, pum)
	uim = calibration_parts.caps_and_progress(pipeline, head_dict["uim"], ctrl_caps, "uim")
	uimtee = pipeparts.mktee(pipeline, uim)

	# add together the PUM and UIM actuation channels; this may change in the future...
	pumuim = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pumtee, uimtee))

	# if you need to, dewhiten the TST and PUM/UIM chains
	if dewhitening:
		pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumuimdewhitensr) 
		pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = int(pumuimdewhitendelay), fir_matrix = [pumuimdewhiten[::-1]], time_domain = td)
		pumuim_filter_settle_time += float(len(pumuimdewhiten)-pumuimdewhitendelay)/pumuimdewhitensr
		pumuim_filter_latency += float(pumuimdewhitendelay)/pumuimdewhitensr
		tst = calibration_parts.mkresample(pipeline, tsttee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % tstdewhitensr) 
		tst = pipeparts.mkfirbank(pipeline, tst, latency = int(tstdewhitendelay), fir_matrix = [tstdewhiten[::-1]], time_domain = td)
		tst_filter_settle_time += float(len(tstdewhiten)-tstdewhitendelay)/tstdewhitensr
		tst_filter_latency += float(tstdewhitendelay)/tstdewhitensr
	else:
		tst = tsttee

if CalibrationConfigs["calibrationmode"] == "Full":
	# enforce caps on actuation channels and set up progress report, if verbose is on
	ctrl = calibration_parts.caps_and_progress(pipeline, head_dict["ctrl"], hoft_caps, "ctrl")
	darmctrltee = pipeparts.mktee(pipeline, ctrl)
	
	if dewhitening:
		# dewhiten the DARM_CTRL channel
		ctrl = calibration_parts.mkresample(pipeline, darmctrltee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % ctrldewhitensr)
		ctrl = pipeparts.mkfirbank(pipeline, ctrl, latency = int(ctrldewhitendelay), fir_matrix = [ctrldewhiten[::-1]], time_domain = td)
		tst_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
		tst_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
		pumuim_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
		pumuim_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
		# tee off DARM_CTRL to be filtered with PUM/UIM and TST filters separately
		ctrltee = pipeparts.mktee(pipeline, ctrl)
	else:
		ctrltee = pipeparts.mktee(pipeline, darmctrltee)
	tst = ctrltee
	pumuim = ctrltee

# resample what will become the TST actuation chain to the TST FIR filter sample rate
tst = calibration_parts.mkresample(pipeline, tst, 5, False, "audio/x-raw, format=F64LE, rate=%d" %  tstchainsr)
# Remove any DC component
if remove_dc:
	tst = calibration_parts.removeDC(pipeline, tst, tstchainsr)
# High-pass filter the TST chain
if any(act_highpass):
	tst = pipeparts.mkfirbank(pipeline, tst, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td)
	tst_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/tstchainsr
	tst_filter_latency += float(act_highpass_delay)/tstchainsr

if apply_complex_kappatst:
	# Filter the TST chain with an adaptive TST actuation filter that includes a linear-phase correction from kappa_tst
	tst = pipeparts.mkgeneric(pipeline, tst, "lal_tdwhiten", kernel = tstfilt[::-1], latency = tstdelay, taper_length = actuation_filter_taper_length)
	# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
	adaptive_tst_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, tst, "adaptive-filter", "kernel")

else:
	# Filter the TST chain with the static TST actuation filter
	tst = pipeparts.mkfirbank(pipeline, tst, latency = tstdelay, fir_matrix = [tstfilt[::-1]], time_domain = td)

tst_filter_settle_time += float(len(tstfilt)-tstdelay)/tstchainsr
tst_filter_latency += float(tstdelay)/tstchainsr

# apply kappa_tst if we haven't already
if apply_kappatst and not apply_complex_kappatst:
	# Only apply the real part of \kappa_tst as a correction to A_tst
	ktst_for_tst = calibration_parts.mkresample(pipeline, smooth_ktstRtee, 3, False, tstchainsr)
	tst = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, ktst_for_tst, tst))

# resample the TST actuation chain if necessary
if tstchainsr < pumuimchainsr:
	tst = calibration_parts.mkresample(pipeline, tst, 5, False, pumuimchainsr)

# resample what will become the PUM/UIM actuation chain to the PUM/UIM FIR filter sample rate
pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumuimchainsr)
# Remove any DC component
if remove_dc:
	pumuim = calibration_parts.removeDC(pipeline, pumuim, pumuimchainsr)
# High-pass filter the PUM/UIM chain
if any(act_highpass):
	pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td)
	pumuim_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/pumuimchainsr
	pumuim_filter_latency += float(act_highpass_delay)/pumuimchainsr

if apply_complex_kappapu:
	# Filter the PUM/UIM chain with an adaptive PUM/UIM actuation filter that includes a linear-phase correction from kappa_pu
	pumuim = pipeparts.mkgeneric(pipeline, pumuim, "lal_tdwhiten", kernel = pumuimfilt[::-1], latency = pumuimdelay, taper_length = actuation_filter_taper_length)
	# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
	adaptive_pumuim_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, pumuim, "adaptive-filter", "kernel")

else:
	# Filter the PUM/UIM chain with the static PUM/UIM actuation filter
	pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = pumuimdelay, fir_matrix = [pumuimfilt[::-1]], time_domain = td)

pumuim_filter_settle_time += float(len(pumuimfilt)-pumuimdelay)/pumuimchainsr
pumuim_filter_latency += float(pumuimdelay)/pumuimchainsr

# apply kappa_pu if we haven't already
if apply_kappapu and not apply_complex_kappapu:
	# Only apply the real part of \kappa_pu as a correction to A_pu
	kpu_for_pu = calibration_parts.mkresample(pipeline, smooth_kpuRtee, 3, False, pumuimchainsr)
	pumuim = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, kpu_for_pu, pumuim))


# resample the PUM/UIM actuation chain if necessary
if pumuimchainsr < tstchainsr:
	pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, tstchainsr)

# Add the TST and PUM/UIM chains together to form the full actuation chain
ctrl = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, tst, pumuim))
# Resample to the full h(t) sample rate
if max(tstchainsr, pumuimchainsr) != hoft_sr:
	ctrl = calibration_parts.mkresample(pipeline, ctrl, 5, False, hoft_caps)

#
# RESIDUAL BRANCH
#

# zero out res filter settle time
res_filter_settle_time = 0.0
res_filter_latency = 0.0

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank

# enforce caps on the residual branch and hook up progress report if verbose is on
if CalibrationConfigs["calibrationmode"] == "Full":
	if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc:
		res = restee = derrtee
	else:
		res = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "res")
		res = restee = pipeparts.mktee(pipeline, res)
elif CalibrationConfigs["calibrationmode"] == "Partial":
	res = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "res")
	res = restee = pipeparts.mktee(pipeline, res)

# Remove any DC component
if remove_dc:
	res = calibration_parts.removeDC(pipeline, res, hoft_sr)

# High-pass filter the residual chain
if any(invsens_highpass):
	res = pipeparts.mkfirbank(pipeline, res, latency = invsens_highpass_delay, fir_matrix = [invsens_highpass[::-1]], time_domain = td)
	res_filter_settle_time += float(len(invsens_highpass)-invsens_highpass_delay)/hoft_sr
	res_filter_latency += float(invsens_highpass_delay)/hoft_sr

if apply_fcc or apply_fs or apply_srcq:
	# Apply an adaptive filter to include the time-dependence of any sensing function parameters
	res = pipeparts.mkgeneric(pipeline, res, "lal_tdwhiten", kernel = reschainfilt[::-1], latency = reschaindelay, taper_length = sensing_filter_taper_length)
	# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
	adaptive_invsens_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, res, "adaptive-filter", "kernel")
# # Correct for time-dependence of f_cc
#if apply_fcc:
#	
#	default_fir_matrix = numpy.zeros(int(numpy.floor(hoft_sr*float(TDCFConfigs["fccfilterduration"])/2.0+1)*2.0-2.0))
#	latency = int(hoft_sr*float(TDCFConfigs["fccfilterduration"])/(2.0)+1)
#	default_fir_matrix[latency] = 1.0
#	res = pipeparts.mkgeneric(pipeline, res, "lal_tdwhiten", kernel = default_fir_matrix[::-1], latency = latency, taper_length = int(TDCFConfigs["fccfiltertaperlength"]))
#	update_fcc.connect("notify::fir-matrix", fir_matrix_update, res)

else:
	# Apply the residual chain filter without time-dependence
	res = pipeparts.mkfirbank(pipeline, res, latency = int(reschaindelay), fir_matrix = [reschainfilt[::-1]], time_domain = td)

# Account for filter latency and settle time for the CALIB_STATE_VECTOR
res_filter_settle_time += float(len(reschainfilt)-reschaindelay)/hoft_sr
res_filter_latency += float(reschaindelay)/hoft_sr

# Apply \kappa_c if we haven't already
if apply_kappac and not (apply_fcc or apply_fs or apply_srcq):
	kc_modify_res = calibration_parts.mkresample(pipeline, smooth_kctee, 3, False, hoft_caps)
	res = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, res, calibration_parts.mkpow(pipeline, kc_modify_res, exponent = -1.0)))

if dewhitening:
	res = pipeparts.mkfirbank(pipeline, res, latency = int(resdewhitendelay), fir_matrix = [resdewhiten[::-1]], time_domain = td)
	res_filter_settle_time += float(len(resdewhiten)-resdewhitendelay)/hoft_sr
	res_filter_latency += float(resdewhitendelay)/hoft_sr

filter_settle_time = max(res_filter_settle_time, tst_filter_settle_time, pumuim_filter_settle_time)
filter_latency = max(res_filter_latency, tst_filter_latency, pumuim_filter_latency)

#
# CONTROL + RESIDUAL = H(T)
#

# Add control and residual chains and divide by L to make h(t)
strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, res, ctrl))

# Divide by L in a way that is compatitble with old and new filters files, since old filter files don't recored "arm length"
try:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/float(filters["arm_length"]))
except KeyError:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/3994.5)

strain = pipeparts.mkprogressreport(pipeline, strain, "progress_hoft_%s" % instrument)

# Put the units back to strain before writing to frames
straintagstr = "units=strain,channel-name=%sCALIB_STRAIN%s,instrument=%s" % (chan_prefix, chan_suffix, instrument)
if remove_cal_lines or remove_power_lines or witness_channel_list is not None:
	straintee = pipeparts.mktee(pipeline, strain)
	strain = pipeparts.mktaginject(pipeline, straintee, straintagstr)
else:
	strain = pipeparts.mktaginject(pipeline, strain, straintagstr)

#
# CALIB_STATE_VECTOR BRANCH
#

#FIXME: Add more comments!

if compute_calib_statevector:
	# FIXME: When the ODC is written as unsigned ints, this piece can be removed
	odcstatevector = calibration_parts.caps_and_progress(pipeline, head_dict["odcstatevector"], odc_caps, "odc_%s" % instrument)
	odctagstr = "channel-name=%s:%s, instrument=%s" % (instrument, ChannelNames["inputdqchannel"], instrument)
	odcstatevector = pipeparts.mktaginject(pipeline, odcstatevector, odctagstr)
	odcstatevectortee = pipeparts.mktee(pipeline, odcstatevector)

	# 
	# OBSERVATION-INTENT BIT BRANCH
	#

	obsintent = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["obsintentbitmask"]), status_out = pow(2,1))
	obsintent = pipeparts.mkcapsfilter(pipeline, obsintent, calibstate_caps)
	obsintenttee = pipeparts.mktee(pipeline, obsintent)
	
	#
	# OBSERVATION-READY BIT BRANCH
	#

	obsready = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["obsreadybitmask"]), status_out = pow(2,2))
	obsready = pipeparts.mkcapsfilter(pipeline, obsready, calibstate_caps)
	obsreadytee = pipeparts.mktee(pipeline, obsready)

	#
	# FILTERS-OK BIT BRANCH
	#
	
	# Set the FILTERS-OK bit based on observation-ready transitions
	filtersok = pipeparts.mkbitvectorgen(pipeline, obsintenttee, bit_vector=pow(2,3), threshold=2)
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, calibstate_caps)
	filtersok = calibration_parts.mkgate(pipeline, filtersok, obsreadytee, 4, attack_length = -int(filter_settle_time * calibstate_sr), hold_length = -int(filter_latency * calibstate_sr))
	filtersok = pipeparts.mkbitvectorgen(pipeline, filtersok, bit_vector = pow(2,3), nongap_is_control = True)
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, calibstate_caps)

	#
	# NO-INVALID-INPUT BRANCH
	#

	# Check if the ODC state vector is present
	nogap = pipeparts.mkbitvectorgen(pipeline, odcstatevectortee, threshold=1, bit_vector = 1)
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, odc_caps)
	nogap = pipeparts.mkgeneric(pipeline, nogap, "lal_logicalundersample", required_on = 1, status_out = 1)
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, calibstate_caps)
	# Check if any of the input data channels had to be replaced by zeroes because they were < 1e-35
	resok = pipeparts.mkbitvectorgen(pipeline, restee, threshold=1e-35, bit_vector=1)
	resok = pipeparts.mkcapsfilter(pipeline, resok, "audio/x-raw, format=U32LE, rate=%d" % hoft_sr)
	resok = pipeparts.mkgeneric(pipeline, resok, "lal_logicalundersample", required_on = 1, status_out = 1)
	resok = pipeparts.mkcapsfilter(pipeline, resok, calibstate_caps)
	if CalibrationConfigs["calibrationmode"] == "Partial":
		tstok = pipeparts.mkbitvectorgen(pipeline, tsttee, threshold=1e-35, bit_vector=1)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		tstok = pipeparts.mkgeneric(pipeline, tstok, "lal_logicalundersample", required_on = 1, status_out = 1)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, calibstate_caps)
		pumok = pipeparts.mkbitvectorgen(pipeline, pumtee, threshold=1e-35, bit_vector=1)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		pumok = pipeparts.mkgeneric(pipeline, pumok, "lal_logicalundersample", required_on = 1, status_out = 1)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, calibstate_caps)
		uimok = pipeparts.mkbitvectorgen(pipeline, uimtee, threshold=1e-35, bit_vector=1)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		uimok = pipeparts.mkgeneric(pipeline, uimok, "lal_logicalundersample", required_on = 1, status_out = 1)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, calibstate_caps)
		noinvalidinput = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, nogap, resok, tstok, pumok, uimok))
		noinvalidinput = pipeparts.mkbitvectorgen(pipeline, noinvalidinput, threshold=5, bit_vector=pow(2,4))
	if CalibrationConfigs["calibrationmode"] == "Full":
		ctrlok = pipeparts.mkbitvectorgen(pipeline, darmctrltee, threshold=1e-35, bit_vector=1)
		ctrlok = pipeparts.mkcapsfilter(pipeline, ctrlok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		ctrlok = pipeparts.mkgeneric(pipeline, ctrlok, "lal_logicalundersample", required_on = 1, status_out = 1)
		ctrlok = pipeparts.mkcapsfilter(pipeline, ctrlok, calibstate_caps)
		noinvalidinput = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, nogap, resok, ctrlok))
		noinvalidinput = pipeparts.mkbitvectorgen(pipeline, noinvalidinput, threshold=3, bit_vector=pow(2,4))
	noinvalidinput = pipeparts.mkcapsfilter(pipeline, noinvalidinput, calibstate_caps)
	noinvalidinput = pipeparts.mktee(pipeline, noinvalidinput)
	# inputs that are replaced with zeros affect h(t) for a short time before and after the zeros, so we also must account for this corrupted time.
	noinvalidinput = calibration_parts.mkgate(pipeline, noinvalidinput, noinvalidinput, pow(2,4), attack_length = -int(filter_settle_time * calibstate_sr), hold_length = -int(filter_latency * calibstate_sr))

	#
	# KAPPATST BITS BRANCH
	#
	if compute_kappatst:
		ktstSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_ktstRtee, smooth_ktstItee, expected_kappatst_real, expected_kappatst_imag, kappatst_real_var, kappatst_imag_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,9), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# KAPPAP/KAPPAPU BITS BRANCH
	#
	if compute_kappap:
		kpSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_kpRtee, smooth_kpItee, expected_kappap_real, expected_kappap_imag, kappap_real_var, kappap_imag_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,10), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	elif compute_kappapu:
		kpSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_kpuRtee, smooth_kpuItee, expected_kappapu_real, expected_kappapu_imag, kappapu_real_var, kappapu_imag_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,10), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# KAPPAU BITS BRANCH
	#
	if compute_kappau:
		kuSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_kuRtee, smooth_kuItee, expected_kappau_real, expected_kappau_imag, kappau_real_ok_var, kappau_imag_ok_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,11), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# KAPPAC BITS BRANCH
	#
	if compute_kappac:
		kcSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_kctee, expected_kappac, kappac_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,12), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# FCC BITS BRANCH
	#
	if compute_fcc:
		fccSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_fcctee, fcc_default, fcc_var, int(median_smoothing_samples / 2) + factors_average_samples + sensing_filter_averaging_time * compute_factors_sr, status_out_smooth = pow(2,13), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# FS BITS BRANCH
	#
	if compute_fs:
		fsSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_fs, fs_default, fs_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,14), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# SRCQ BITS BRANCH
	#
	if compute_srcq:
		srcQSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_srcQ_inv, 1.0 / srcQ_default, [srcQinv_min, srcQinv_max], int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,15), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# COHERENCE BITS BRANCH
	#
	if use_coherence:
		coherence_ok_list = []
		if compute_kappac or compute_fcc or compute_srcq or compute_fs:
			# PCALY_LINE2 is only used for \kappa_c, f_cc, f_s, and Q
			pcaly_line2_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line2_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,19), invert_control = True)
			pcaly_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line2_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			pcaly_line2_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line2_coh_ok, "lal_logicalundersample", required_on = pow(2,19), status_out = pow(2,19))
			pcaly_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line2_coh_ok, calibstate_caps)
			coherence_ok_list.append(pcaly_line2_coh_ok)
		if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_srcq or compute_fs:
			# The coherences of these lines are all used to gate all the time dependence calculations
			pcaly_line1_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line1_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,18), invert_control = True)
			pcaly_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line1_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			pcaly_line1_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line1_coh_ok, "lal_logicalundersample", required_on = pow(2,18), status_out = pow(2,18))
			pcaly_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line1_coh_ok, calibstate_caps)

			sus_coh_ok = pipeparts.mkbitvectorgen(pipeline, sus_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,16), invert_control = True)
			sus_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			sus_coh_ok = pipeparts.mkgeneric(pipeline, sus_coh_ok, "lal_logicalundersample", required_on = pow(2,16), status_out = pow(2,16))
			sus_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_coh_ok, calibstate_caps)

			darm_coh_ok = pipeparts.mkbitvectorgen(pipeline, darm_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,17), invert_control = True)
			darm_coh_ok = pipeparts.mkcapsfilter(pipeline, darm_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			darm_coh_ok = pipeparts.mkgeneric(pipeline, darm_coh_ok, "lal_logicalundersample", required_on = pow(2,17), status_out = pow(2,17))
			darm_coh_ok = pipeparts.mkcapsfilter(pipeline, darm_coh_ok, calibstate_caps)
			coherence_ok_list.extend((pcaly_line1_coh_ok, sus_coh_ok, darm_coh_ok))
			coherence_bits = calibration_parts.mkadder(pipeline, tuple(coherence_ok_list))

	#
	# H(T)-OK BIT BRANCH
	#

	# First combine higher order bits to determine h(t)-OK
	higherbits_list = [filtersok, obsreadytee, noinvalidinput]
	htok_threshold = pow(2,2) + pow(2,3) + pow(2,4)
	if apply_kappatst or apply_complex_kappatst:
		higherbits_list.append(ktstSmoothInRange)
		htok_threshold += pow(2,9)
	if apply_kappap or apply_complex_kappap or apply_kappapu or apply_complex_kappapu:
		higherbits_list.append(kpSmoothInRange)
		htok_threshold += pow(2,10)
	if apply_kappau or apply_complex_kappau:
		higherbits_list.append(kuSmoothInRange)
		htok_threshold += pow(2,11)
	if apply_kappac:
		higherbits_list.append(kcSmoothInRange)
		htok_threshold += pow(2,12)
	if apply_fcc:
		higherbits_list.append(fccSmoothInRange)
		htok_threshold += pow(2,13)
	if apply_fs:
		higherbits_list.append(fsSmoothInRange)
		htok_threshold += pow(2,14)
	if apply_srcq:
		higherbits_list.append(srcQSmoothInRange)
		htok_threshold += pow(2,15)
	higherbits = calibration_parts.mkadder(pipeline, tuple(higherbits_list))
	higherbitstee = pipeparts.mktee(pipeline, higherbits)

	# Now calculate h(t)-OK bit
	htok = pipeparts.mkbitvectorgen(pipeline, higherbitstee, bit_vector = 1, threshold = htok_threshold)
	htok = pipeparts.mkcapsfilter(pipeline, htok, calibstate_caps)

	#
	# HW INJECTION BITS
	#	

	hwinjcbc = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["cbchwinjbitmask"]), status_out = pow(2,6))
	hwinjcbc = pipeparts.mkcapsfilter(pipeline, hwinjcbc, calibstate_caps)

	hwinjburst = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["bursthwinjbitmask"]), status_out = pow(2,7))
	hwinjburst = pipeparts.mkcapsfilter(pipeline, hwinjburst, calibstate_caps)

	hwinjdetchar = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["detcharhwinjbitmask"]), status_out = pow(2,8))
	hwinjdetchar = pipeparts.mkcapsfilter(pipeline, hwinjdetchar, calibstate_caps)

	hwinjstoch = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["stochhwinjbitmask"]), status_out = pow(2,5))
	hwinjstoch = pipeparts.mkcapsfilter(pipeline, hwinjstoch, calibstate_caps)

	#
	# EPICS BITS
	#

	D_epics_threshold = 0.0
	A_epics_threshold = 0.0
	C_epics_threshold = 0.0
	other_epics_threshold = 0.0

	# First, check the EPICS that involve only the digital filter D, EP7 and EP12
	if num_dq_epics > 6:
		D_epics_threshold += 1.5
		EP7_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP7_real"], 1.0 / EP7_real)
		EP7_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP7_imag"], 1.0 / EP7_imag)

		# The above values should be close to one (within 1 / 10^4)
		EP7_real_check = pipeparts.mkgeneric(pipeline, EP7_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
		EP7_imag_check = pipeparts.mkgeneric(pipeline, EP7_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
		D_epics_check_list = [EP7_real_check, EP7_imag_check]

		if num_dq_epics > 11:
			D_epics_threshold += 2.0
			EP12_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP12_real"], 1.0 / EP12_real)
			EP12_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP12_imag"], 1.0 / EP12_imag)

			# The above values should be close to one (within 1 / 10^4)
			EP12_real_check = pipeparts.mkgeneric(pipeline, EP12_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			EP12_imag_check = pipeparts.mkgeneric(pipeline, EP12_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			D_epics_check_list.extend((EP12_real_check, EP12_imag_check))

		D_epics_check = calibration_parts.mkadder(pipeline, tuple(D_epics_check_list))
		D_epics_bit = pipeparts.mkbitvectorgen(pipeline, D_epics_check, bit_vector = pow(2,21), threshold = D_epics_threshold)
		D_epics_bit = pipeparts.mkgeneric(pipeline, D_epics_bit, "lal_logicalundersample", required_on = pow(2,21), status_out = pow(2,21))
		D_epics_bit = pipeparts.mkcapsfilter(pipeline, D_epics_bit, calibstate_caps)

	# Next, check the EPICS that involve only the actuation function A, EP3, EP4, EP8, EP9, EP10, EP13, EP14
	if num_dq_epics > 2:
		A_epics_threshold += 1.5
		EP3_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP3_real"], 1.0 / EP3_real)
		EP3_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP3_imag"], 1.0 / EP3_imag)

		# The above values should be close to one (within 1 / 10^4)
		EP3_real_check = pipeparts.mkgeneric(pipeline, EP3_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
		EP3_imag_check = pipeparts.mkgeneric(pipeline, EP3_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
		A_epics_check_list = [EP3_real_check, EP3_imag_check]

		if num_dq_epics > 3:
			A_epics_threshold += 2.0
			EP4_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP4_real"], 1.0 / EP4_real)
			EP4_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP4_imag"], 1.0 / EP4_imag)

			# The above values should be close to one (within 1 / 10^4)
			EP4_real_check = pipeparts.mkgeneric(pipeline, EP4_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			EP4_imag_check = pipeparts.mkgeneric(pipeline, EP4_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			A_epics_check_list.extend((EP4_real_check, EP4_imag_check))

		if num_dq_epics > 7:
			A_epics_threshold += 2.0
			EP8_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP8_real"], 1.0 / EP8_real)
			EP8_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP8_imag"], 1.0 / EP8_imag)

			# The above values should be close to one (within 1 / 10^4)
			EP8_real_check = pipeparts.mkgeneric(pipeline, EP8_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			EP8_imag_check = pipeparts.mkgeneric(pipeline, EP8_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			A_epics_check_list.extend((EP8_real_check, EP8_imag_check))

		if num_dq_epics > 8:
			A_epics_threshold += 2.0
			EP9_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP9_real"], 1.0 / EP9_real)
			EP9_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP9_imag"], 1.0 / EP9_imag)

			# The above values should be close to one (within 1 / 10^4)
			EP9_real_check = pipeparts.mkgeneric(pipeline, EP9_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			EP9_imag_check = pipeparts.mkgeneric(pipeline, EP9_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			A_epics_check_list.extend((EP9_real_check, EP9_imag_check))

		if num_dq_epics > 9:
			A_epics_threshold += 2.0
			EP10_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP10_real"], 1.0 / EP10_real)
			EP10_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP10_imag"], 1.0 / EP10_imag)

			# The above values should be close to one (within 1 / 10^4)
			EP10_real_check = pipeparts.mkgeneric(pipeline, EP10_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			EP10_imag_check = pipeparts.mkgeneric(pipeline, EP10_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			A_epics_check_list.extend((EP10_real_check, EP10_imag_check))

		if num_dq_epics > 12:
			A_epics_threshold += 2.0
			EP13_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP13_real"], 1.0 / EP13_real)
			EP13_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP13_imag"], 1.0 / EP13_imag)

			# The above values should be close to one (within 1 / 10^4)
			EP13_real_check = pipeparts.mkgeneric(pipeline, EP13_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			EP13_imag_check = pipeparts.mkgeneric(pipeline, EP13_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			A_epics_check_list.extend((EP13_real_check, EP13_imag_check))

		if num_dq_epics > 13:
			A_epics_threshold += 2.0
			EP14_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP14_real"], 1.0 / EP14_real)
			EP14_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP14_imag"], 1.0 / EP14_imag)

			# The above values should be close to one (within 1 / 10^4)
			EP14_real_check = pipeparts.mkgeneric(pipeline, EP14_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			EP14_imag_check = pipeparts.mkgeneric(pipeline, EP14_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			A_epics_check_list.extend((EP14_real_check, EP14_imag_check))

		A_epics_check = calibration_parts.mkadder(pipeline, tuple(A_epics_check_list))
		A_epics_bit = pipeparts.mkbitvectorgen(pipeline, A_epics_check, bit_vector = pow(2,22), threshold = A_epics_threshold)
		A_epics_bit = pipeparts.mkgeneric(pipeline, A_epics_bit, "lal_logicalundersample", required_on = pow(2,22), status_out = pow(2,22))
		A_epics_bit = pipeparts.mkcapsfilter(pipeline, A_epics_bit, calibstate_caps)

	# Next, check the EPICS that involve only the sensing function C, EP6 and EP11
	if num_dq_epics > 5:
		C_epics_threshold += 1.5
		EP6_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP6_real"], 1.0 / EP6_real)
		EP6_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP6_imag"], 1.0 / EP6_imag)

		# The above values should be close to one (within 1 / 10^4)
		EP6_real_check = pipeparts.mkgeneric(pipeline, EP6_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
		EP6_imag_check = pipeparts.mkgeneric(pipeline, EP6_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
		C_epics_check_list = [EP6_real_check, EP6_imag_check]

		if num_dq_epics > 10:
			C_epics_threshold += 2.0
			EP11_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP11_real"], 1.0 / EP11_real)
			EP11_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP11_imag"], 1.0 / EP11_imag)

			# The above values should be close to one (within 1 / 10^4)
			EP11_real_check = pipeparts.mkgeneric(pipeline, EP11_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			EP11_imag_check = pipeparts.mkgeneric(pipeline, EP11_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			C_epics_check_list.extend((EP11_real_check, EP11_imag_check))

		C_epics_check = calibration_parts.mkadder(pipeline, tuple(C_epics_check_list))
		C_epics_bit = pipeparts.mkbitvectorgen(pipeline, C_epics_check, bit_vector = pow(2,23), threshold = C_epics_threshold)
		C_epics_bit = pipeparts.mkgeneric(pipeline, C_epics_bit, "lal_logicalundersample", required_on = pow(2,23), status_out = pow(2,23))
		C_epics_bit = pipeparts.mkcapsfilter(pipeline, C_epics_bit, calibstate_caps)

	# Next, check the remaining EPICS that are combinations of D, A, and C, EP1 and EP2
	if num_dq_epics > 0:
		other_epics_threshold += 1.5
		EP1_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP1_real"], 1.0 / EP1_real)
		EP1_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP1_imag"], 1.0 / EP1_imag)

		# The above values should be close to one (within 1 / 10^4)
		EP1_real_check = pipeparts.mkgeneric(pipeline, EP1_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
		EP1_imag_check = pipeparts.mkgeneric(pipeline, EP1_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
		other_epics_check_list = [EP1_real_check, EP1_imag_check]

		if num_dq_epics > 1:
			other_epics_threshold += 2.0
			EP2_real_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP2_real"], 1.0 / EP2_real)
			EP2_imag_check = pipeparts.mkaudioamplify(pipeline, head_dict["EP2_imag"], 1.0 / EP2_imag)

			# The above values should be close to one (within 1 / 10^4)
			EP2_real_check = pipeparts.mkgeneric(pipeline, EP2_real_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			EP2_imag_check = pipeparts.mkgeneric(pipeline, EP2_imag_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			other_epics_check_list.extend((EP2_real_check, EP2_imag_check))

		other_epics_check = calibration_parts.mkadder(pipeline, tuple(other_epics_check_list))
		other_epics_bit = pipeparts.mkbitvectorgen(pipeline, other_epics_check, bit_vector = pow(2,24), threshold = other_epics_threshold)
		other_epics_bit = pipeparts.mkgeneric(pipeline, other_epics_bit, "lal_logicalundersample", required_on = pow(2,24), status_out = pow(2,24))
		epics_bits = pipeparts.mkcapsfilter(pipeline, other_epics_bit, calibstate_caps)

		# Add the EPICS bits together
		if num_dq_epics > 6:
			# There are EPICS for D, A, and C
			epics_bits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, epics_bits, A_epics_bit, C_epics_bit, D_epics_bit))
		elif num_dq_epics > 5:
			# There are EPICS for A and C
			epics_bits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, epics_bits, A_epics_bit, C_epics_bit))
		elif num_dq_epics > 2:
			# There are EPICS for A
			epics_bits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, epics_bits, A_epics_bit))

	#
	# COMBINE ALL BITS TO MAKE GDS-CALIB_STATE_VECTOR
	#

	all_bits_list = [higherbitstee, obsintenttee, htok, hwinjcbc, hwinjburst, hwinjdetchar, hwinjstoch]
	if use_coherence and (compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq):
		all_bits_list.append(coherence_bits)
	if compute_kappatst and not apply_kappatst and not apply_complex_kappatst:
		all_bits_list.append(ktstSmoothInRange)
	# FIXME: Is this logic right? Should it be compute_kappap or compute_kappapu?
	if (compute_kappap or compute_kappapu) and not (apply_kappap or apply_complex_kappap or apply_kappapu or apply_complex_kappapu):
		all_bits_list.append(kpSmoothInRange)
	if compute_kappau and not (apply_kappau or apply_complex_kappau):
		all_bits_list.append(kuSmoothInRange)
	if compute_kappac and not apply_kappac:
		all_bits_list.append(kcSmoothInRange)
	if compute_fcc and not apply_fcc:
		all_bits_list.append(fccSmoothInRange)
	if compute_fs and not apply_fs:
		all_bits_list.append(fsSmoothInRange)
	if compute_srcq and not apply_srcq:
		all_bits_list.append(srcQSmoothInRange)
	if num_dq_epics > 0:
		all_bits_list.append(epics_bits)

	calibstatevector = calibration_parts.mkadder(pipeline, tuple(all_bits_list))
	calibstatevector = pipeparts.mkprogressreport(pipeline, calibstatevector, "progress_calibstatevec_%s" % instrument)
	dqtagstr = "channel-name=%s:GDS-CALIB_STATE_VECTOR, instrument=%s" % (instrument, instrument)
	calibstatevector = pipeparts.mktaginject(pipeline, calibstatevector, dqtagstr)

#
# SUBTRACTION OF LINES AND NOISE
#

# First, remove calibration lines
if remove_cal_lines:
	# if we didn't compute the kappas, we still need to get the pcal channel
	if not compute_kappatst and not compute_kappapu and not compute_kappac and not compute_fcc and not compute_srcq and not compute_fs:
		pcal = calibration_parts.caps_and_progress(pipeline, head_dict["pcal"], hoft_caps, "pcal")
		pcaltee = pipeparts.mktee(pipeline, pcal)

	callines_list = []
	# Start with the pcal lines. Loop through the dictionary, reconstruct each line, and add to the list.
	for pcal_line_name in pcal_line_removal_dict:
		if pcal_line_removal_dict[pcal_line_name][3] is None:
			# This line still needs to be demodulated
			pcal_line_removal_dict[pcal_line_name][3] = calibration_parts.demodulate(pipeline, pcaltee, pcal_line_removal_dict[pcal_line_name][0], td, compute_factors_sr, demodulation_filter_time, filter_latency, prefactor_real = pcal_line_removal_dict[pcal_line_name][1], prefactor_imag = pcal_line_removal_dict[pcal_line_name][2])
		# Reconstruct a pcal signal at only this pcal line
		pcal_line_removal_dict[pcal_line_name][3] = calibration_parts.mkresample(pipeline, pcal_line_removal_dict[pcal_line_name][3], 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoft_sr)
		pcal_line_removal_dict[pcal_line_name][3] = pipeparts.mkgeneric(pipeline, pcal_line_removal_dict[pcal_line_name][3], "lal_demodulate", line_frequency = -1.0 * pcal_line_removal_dict[pcal_line_name][0], prefactor_real = 2.0)
		pcal_line_removal_dict[pcal_line_name][3] = pipeparts.mkgeneric(pipeline, pcal_line_removal_dict[pcal_line_name][3], "creal")
		# Add this line to the list
		callines_list.append(pcal_line_removal_dict[pcal_line_name][3])

	# Now deal with the ESD line
	if remove_esd_act_line:
		# Make sure we have demodulated the ESD excitation channel at the ~30 Hz ESD line
		if not compute_kappac and not compute_fcc and not compute_kappatst and not compute_kappapu and not compute_srcq and not compute_fs:
			tstexc_at_esd_act_freq = calibration_parts.demodulate(pipeline, tstexc, esd_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency)
		if factors_from_filters_file:
			esd_act_line = calibration_parts.complex_audioamplify(pipeline, tstexc_at_esd_act_freq, EP10_real, EP10_imag)
		else:
			# EP10 was read from the frames
			EP10 = calibration_parts.merge_into_complex(pipeline, head_dict["EP10_real"], head_dict["EP10_imag"])
			esd_act_line = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, tstexc_at_esd_act_freq, EP10))
		# Reconstruct a calibrated ESD injection at the ~30 Hz ESD line
		if apply_complex_kappatst:
			# Multiply by kappa_tst
			esd_act_line = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, esd_act_line, smooth_ktsttee))
		elif apply_kappatst:
			# Multiply by the real part of kappa_tst
			esd_act_line = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, esd_act_line, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, smooth_ktstRtee, matrix = [[1.0, 0.0]]))))
		esd_act_line = calibration_parts.mkresample(pipeline, esd_act_line, 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoft_sr)
		esd_act_line_remove = pipeparts.mkgeneric(pipeline, esd_act_line, "lal_demodulate", line_frequency = -1.0 * esd_act_line_freq, prefactor_real = 2.0)
		esd_act_line_remove = pipeparts.mkgeneric(pipeline, esd_act_line_remove, "creal")

		# Add into the total line removal stream
		callines_list.append(esd_act_line_remove)

	# Add all the lines together
	calibration_lines = calibration_parts.mkadder(pipeline, tuple(callines_list))

	# Divide the calibration lines we are removing by the arm length
	try:
		calibration_lines = pipeparts.mkaudioamplify(pipeline, calibration_lines, -1.0/float(filters["arm_length"]))
	except KeyError:
		calibration_lines = pipeparts.mkaudioamplify(pipeline, calibration_lines, -1.0/3994.5)

	clean_strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, straintee, calibration_lines))

# Next, remove 60 power lines and harmonics
if remove_power_lines:
	if not remove_cal_lines:
		clean_strain = straintee
	powerlines = calibration_parts.caps_and_progress(pipeline, head_dict["powerlines"], "audio/x-raw, format=F64LE, channels=1, channel-mask=(bitmask)0x0", "powerlines")
	clean_strain = calibration_parts.remove_harmonics_with_witness(pipeline, clean_strain, powerlines, 60, 5, powerlines_freq_var, filter_latency, compute_rate = compute_factors_sr, rate_out = hoft_sr, num_avg = powerlines_tf_averaging_time * compute_factors_sr, obsready = None if not compute_calib_statevector else obsreadytee)

# Remove excess noise using any provided witness channels
if witness_channel_list is not None:
	# Remove initial data from computation of transfer functions and wait until the filters and kappas settle
	witness_chop_time = filter_settle_time + (1.0 - filter_latency) * (demodulation_filter_time + median_smoothing_samples / compute_factors_sr + factors_average_samples / compute_factors_sr)
	# In high latency, make the witnesses wait to be filtered until new filters are ready
	witness_wait_time = (filter_settle_time + demodulation_filter_time + median_smoothing_samples / compute_factors_sr + factors_average_samples / compute_factors_sr + witness_channel_fft_time / 2.0 * (num_witness_ffts + 1.0)) if filter_latency else 0.0
	# How much does the "chop_time" need to increase per iteration of cleaning?
	witness_chop_increment = witness_filter_taper_time + (witness_channel_fft_time / 2.0 * (num_witness_ffts + 1.0) if not filter_latency else 0.0)
	# How much does the "wait_time" need to increase per iteration of cleaning?
	witness_wait_increment = (witness_filter_taper_time + witness_channel_fft_time / 2.0 * (num_witness_ffts + 1.0)) if filter_latency else 0.0
	# If we haven't removed any lines, clean the regular h(t) data
	if not (remove_cal_lines or remove_power_lines):
		clean_strain = straintee

	# If possible, gate the data being used to compute transfer functions to be sure we are locked
	if not compute_calib_statevector:
		obsreadytee = None

	for i in range(0, len(witness_channel_list)):
		# Length of ffts used to compute FIR filters
		witness_fft_samples = int(witness_channel_fft_time * witness_rates[i])
		# Overlap of ffts is half of fft length. The data is Hann-windowed before taking ffts.
		witness_fft_overlap = int(witness_fft_samples / 2)
		# How many samples between filter updates (does not include the samples used to compute the FIR filters
		witness_tf_update_samples = int(witness_rates[i] * witness_tf_update_time)
		# Length of FIR filters
		witness_fir_samples = int(witness_fir_length * witness_rates[i])
		# Over how many samples should new FIR filters be tapered in?
		witness_filter_taper_length = int(witness_rates[i] * witness_filter_taper_time)

		witnesses = []
		for key in headkeys:
			if key in witness_channel_list[i]:
				witnesses.append(calibration_parts.caps_and_progress(pipeline, head_dict[key], "audio/x-raw, format=F64LE, channels=1, channel-mask=(bitmask)0x0", key))
		if len(witnesses) != len(witness_channel_list[i]):
			print "WARNING: Not all requested witness channels are being used"
		clean_strain = calibration_parts.clean_data(pipeline, clean_strain, hoft_sr, witnesses, witness_rates[i], witness_fft_samples, witness_fft_overlap, num_witness_ffts, witness_tf_update_samples, witness_fir_samples, witness_frequency_resolution, witness_filter_taper_length, notch_frequencies = witness_notch_frequencies[i], obsready = obsreadytee, chop_time = witness_chop_time, wait_time = witness_wait_time, filename = "transfer_functions_%d.txt" % i)
		witness_chop_time += witness_chop_increment
		witness_wait_time += witness_wait_increment

if remove_cal_lines or remove_power_lines or witness_channel_list is not None:
	clean_strain = pipeparts.mkprogressreport(pipeline, clean_strain, "progress_hoft_cleaned_%s" % instrument)
	clean_straintagstr = "units=strain,channel-name=%sCALIB_STRAIN_CLEAN%s,instrument=%s" % (chan_prefix, chan_suffix, instrument)
	if compute_calib_statevector:
		clean_straintee = pipeparts.mktee(pipeline, clean_strain)
		clean_strain = pipeparts.mktaginject(pipeline, clean_straintee, clean_straintagstr)
	else:
		clean_strain = pipeparts.mktaginject(pipeline, clean_strain, clean_straintagstr)

#
# CALIB_STATE_VECTOR: CALIB_STRAIN_CLEAN
#

if compute_calib_statevector and (remove_cal_lines or remove_power_lines or witness_channel_list is not None):
	low_rms_rate = pow(2, int(numpy.log(cleaning_check_range_low_max) / numpy.log(2) + 1.1))
	mid_rms_rate = pow(2, int(numpy.log(cleaning_check_range_mid_max) / numpy.log(2) + 1.1))

	# Compute the RMS of the uncleaned strain in a low-frequency range to test subtraction of actuation lines
	strain_rms_lowfreq = calibration_parts.compute_rms(pipeline, straintee, low_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_low_min, f_max = cleaning_check_range_low_max, filter_latency = filter_latency, rate_out = calibstate_sr, td = td)
	# Compute the RMS of the cleaned strain in a low-frequency range
	clean_strain_rms_lowfreq = calibration_parts.compute_rms(pipeline, clean_straintee, low_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_low_min, f_max = cleaning_check_range_low_max, filter_latency = filter_latency, rate_out = calibstate_sr, td = td)
	# Require that ratio RMS(strain) / RMS(clean_strain) > 1.0
	clean_hoft_ok_lowfreq = calibration_parts.complex_division(pipeline, strain_rms_lowfreq, clean_strain_rms_lowfreq)
	clean_hoft_ok_lowfreq = pipeparts.mkbitvectorgen(pipeline, clean_hoft_ok_lowfreq, bit_vector=pow(2,25), threshold=1.0)
	clean_hoft_ok_lowfreq = pipeparts.mkcapsfilter(pipeline, clean_hoft_ok_lowfreq, calibstate_caps)

	# Compute the RMS of the uncleaned strain in a mid-frequency range to test subtraction of noise and/or the ~300 Hz pcal line
	strain_rms_midfreq = calibration_parts.compute_rms(pipeline, straintee, mid_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_mid_min, f_max = cleaning_check_range_mid_max, filter_latency = filter_latency, rate_out = calibstate_sr, td = td)
	# Compute the RMS of the cleaned strain in a mid-frequency range
	clean_strain_rms_midfreq = calibration_parts.compute_rms(pipeline, clean_straintee, mid_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_mid_min, f_max = cleaning_check_range_mid_max, filter_latency = filter_latency, rate_out = calibstate_sr, td = td)
	# Require that ratio RMS(strain) / RMS(clean_strain) > 1.0
	clean_hoft_ok_midfreq = calibration_parts.complex_division(pipeline, strain_rms_midfreq, clean_strain_rms_midfreq)
	clean_hoft_ok_midfreq = pipeparts.mkbitvectorgen(pipeline, clean_hoft_ok_midfreq, bit_vector=pow(2,26), threshold=1.0)
	clean_hoft_ok_midfreq = pipeparts.mkcapsfilter(pipeline, clean_hoft_ok_midfreq, calibstate_caps)

	# Add these into the CALIB_STATE_VECTOR
	calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, clean_hoft_ok_lowfreq, clean_hoft_ok_midfreq))

#
# Produce time-dependent correction factors to be recorded in the frames
#

record_kappa_caps = "audio/x-raw, format=F32LE, rate=%d" % record_factors_sr

# Resample the \kappa_pu channels at the specified recording sample rate and change them to single precision channels
if compute_kappapu:

	kpuRout = pipeparts.mkaudioconvert(pipeline, smooth_kpuRtee)
	kpuRout = calibration_parts.mkresample(pipeline, kpuRout, 1, False, record_kappa_caps)
	kpuRout = pipeparts.mkprogressreport(pipeline, kpuRout, "progress_kappa_pu_real_%s" % instrument)

	kpuIout = pipeparts.mkaudioconvert(pipeline, smooth_kpuItee)
	kpuIout = calibration_parts.mkresample(pipeline, kpuIout, 1, False, record_kappa_caps)
	kpuIout = pipeparts.mkprogressreport(pipeline, kpuIout, "progress_kappa_pu_imag_%s" % instrument)

	smooth_kpuR_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kpuR_nogate)
	smooth_kpuR_nogate = calibration_parts.mkresample(pipeline, smooth_kpuR_nogate, 1, False, record_kappa_caps)
	smooth_kpuR_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpuR_nogate, "progress_kappa_pu_real_nogate_%s" % instrument)

	smooth_kpuI_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kpuI_nogate)
	smooth_kpuI_nogate = calibration_parts.mkresample(pipeline, smooth_kpuI_nogate, 1, False, record_kappa_caps)
	smooth_kpuI_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpuI_nogate, "progress_kappa_pu_imag_nogate_%s" % instrument)

# Resample the \kappa_tst channels at the specified recording sample rate and change them to single precision channels
if compute_kappatst:

	ktstRout = pipeparts.mkaudioconvert(pipeline, smooth_ktstRtee)
	ktstRout = calibration_parts.mkresample(pipeline, ktstRout, 1, False, record_kappa_caps)
	ktstRout = pipeparts.mkprogressreport(pipeline, ktstRout, "progress_kappa_tst_real_%s" % instrument)

	ktstIout = pipeparts.mkaudioconvert(pipeline, smooth_ktstItee)
	ktstIout = calibration_parts.mkresample(pipeline, ktstIout, 1, False, record_kappa_caps)
	ktstIout = pipeparts.mkprogressreport(pipeline, ktstIout, "progress_kappa_tst_imag_%s" % instrument)

	smooth_ktstR_nogate = pipeparts.mkaudioconvert(pipeline, smooth_ktstR_nogate)
	smooth_ktstR_nogate = calibration_parts.mkresample(pipeline, smooth_ktstR_nogate, 1, False, record_kappa_caps)
	smooth_ktstR_nogate = pipeparts.mkprogressreport(pipeline, smooth_ktstR_nogate, "progress_kappa_tst_real_nogate_%s" % instrument)

	smooth_ktstI_nogate = pipeparts.mkaudioconvert(pipeline, smooth_ktstI_nogate)
	smooth_ktstI_nogate = calibration_parts.mkresample(pipeline, smooth_ktstI_nogate, 1, False, record_kappa_caps)
	smooth_ktstI_nogate = pipeparts.mkprogressreport(pipeline, smooth_ktstI_nogate, "progress_kappa_tst_imag_nogate_%s" % instrument)

# Resample the \kappa_c channels at the specified recording sample rate and change it to a single precision channel
if compute_kappac:
	kcout = pipeparts.mkaudioconvert(pipeline, smooth_kctee)
	kcout = calibration_parts.mkresample(pipeline, kcout, 1, False, record_kappa_caps)
	kcout = pipeparts.mkprogressreport(pipeline, kcout, "progress_kappa_c_%s" % instrument)

	smooth_kc_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kc_nogate)
	smooth_kc_nogate = calibration_parts.mkresample(pipeline, smooth_kc_nogate, 1, False, record_kappa_caps)
	smooth_kc_nogate = pipeparts.mkprogressreport(pipeline, smooth_kc_nogate, "progress_kappa_c_nogate_%s" % instrument)

# Resample the f_cc channels at the specified recording sample rate and change it to a single precision channel
if compute_fcc:
	fccout = pipeparts.mkaudioconvert(pipeline, smooth_fcctee)
	fccout = calibration_parts.mkresample(pipeline, fccout, 1, False, record_kappa_caps)
	fccout = pipeparts.mkprogressreport(pipeline, fccout, "progress_f_cc_%s" % instrument)

	smooth_fcc_nogate = pipeparts.mkaudioconvert(pipeline, smooth_fcc_nogate)
	smooth_fcc_nogate = calibration_parts.mkresample(pipeline, smooth_fcc_nogate, 1, False, record_kappa_caps)
	smooth_fcc_nogate = pipeparts.mkprogressreport(pipeline, smooth_fcc_nogate, "progress_f_cc_nogate_%s" % instrument)

# Resample the f_s channels at the specified recording sample rate and change it to a single precision channel
if compute_fs:
	fsout = pipeparts.mkaudioconvert(pipeline, smooth_fs)
	fsout = calibration_parts.mkresample(pipeline, fsout, 1, False, record_kappa_caps)
	fsout = pipeparts.mkprogressreport(pipeline, fsout, "progress_f_s_%s" % instrument)

	smooth_fs_nogate = pipeparts.mkaudioconvert(pipeline, smooth_fs_nogate)
	smooth_fs_nogate = calibration_parts.mkresample(pipeline, smooth_fs_nogate, 1, False, record_kappa_caps)
	smooth_fs_nogate = pipeparts.mkprogressreport(pipeline, smooth_fs_nogate, "progress_f_s_nogate_%s" % instrument)

# Resample the f_s channels at the specified recording sample rate and change it to a single precision channel
if compute_srcq:
	srcQ_inv_out = pipeparts.mkaudioconvert(pipeline, smooth_srcQ_inv)
	srcQ_inv_out = calibration_parts.mkresample(pipeline, srcQ_inv_out, 1, False, record_kappa_caps)
	srcQ_inv_out = pipeparts.mkprogressreport(pipeline, srcQ_inv_out, "progress_SRC_Q_%s" % instrument)

	smooth_srcQ_inv_nogate = pipeparts.mkaudioconvert(pipeline, smooth_srcQ_inv_nogate)
	smooth_srcQ_inv_nogate = calibration_parts.mkresample(pipeline, smooth_srcQ_inv_nogate, 1, False, record_kappa_caps)
	smooth_srcQ_inv_nogate = pipeparts.mkprogressreport(pipeline, smooth_srcQ_inv_nogate, "progress_SRC_Q_nogate_%s" % instrument)

#
# CREATE MUXER AND HOOK EVERYTHING UP TO IT
#

mux = pipeparts.mkframecppchannelmux(pipeline, None)

mux.set_property("frame-duration", options.frame_duration)
mux.set_property("frames-per-file", options.frames_per_file)
mux.set_property("compression-scheme", int(OutputConfigs["compressionscheme"]))
mux.set_property("compression-level", int(OutputConfigs["compressionscheme"]))

# Link the output DQ vectors up to the muxer, if applicable
if compute_calib_statevector:
	calibration_parts.mkqueue(pipeline, calibstatevector).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STATE_VECTOR%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, odcstatevectortee).get_static_pad("src").link(mux.get_request_pad("%s:%s" % (instrument, ChannelNames["inputdqchannel"])))

# Link the strain branch to the muxer
calibration_parts.mkqueue(pipeline, strain).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STRAIN%s" % (instrument, chan_prefix, chan_suffix)))

# Link the cleaned strain branch to the muxer if h(t) was cleaned in any way
if remove_cal_lines or remove_power_lines or witness_channel_list is not None:
	calibration_parts.mkqueue(pipeline, clean_strain).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STRAIN_CLEAN%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of \kappa_tst to the muxer
if compute_kappatst:
	calibration_parts.mkqueue(pipeline, ktstRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, ktstIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_ktstR_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_ktstI_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of \kappa_pu to the muxer
if compute_kappapu:
	calibration_parts.mkqueue(pipeline, kpuRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, kpuIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kpuR_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kpuI_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the \kappa_c to the muxer
if compute_kappac:
	calibration_parts.mkqueue(pipeline, kcout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_C%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kc_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_C_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the f_cc to the muxer
if compute_fcc:
	calibration_parts.mkqueue(pipeline, fccout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_CC%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_fcc_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_CC_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the f_s to the muxer
if compute_fs:
	calibration_parts.mkqueue(pipeline, fsout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_S%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_fs_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_S_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the src_Q to the muxer
if compute_srcq:
	calibration_parts.mkqueue(pipeline, srcQ_inv_out).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_SRC_Q_INVERSE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_srcQ_inv_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_SRC_Q_INVERSE_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Check that all frames are long enough, that they have all of the channels by requring a certain amount of time from start-up, and that frames aren't written for times requested by the wings option
def check_complete_frames(pad, info, (output_start, frame_duration, wings_start, wings_end)):
	if verbose:
		print("Checking if frames are complete")
	buf = info.get_buffer()
	startts = lal.LIGOTimeGPS(0, buf.pts)
	duration = lal.LIGOTimeGPS(0, buf.duration)
	if not (startts % frame_duration == 0):
		if verbose:
			print("Dropping frame because it is not an integer multiple of frame duration")
		return Gst.PadProbeReturn.DROP
	if startts < output_start:
		if verbose:
			print("Dropping frame because start time %f is less than desired output start time %f" % (startts, output_start))
		return Gst.PadProbeReturn.DROP
	if duration != frame_duration:
		if verbose:
			print("Dropping frame because the duration %d is not equal to the required frame duration %d" % (duration, frame_duration))
		return Gst.PadProbeReturn.DROP
	if wings_start is not None and wings_end is not None:
		if startts < wings_start or (startts+duration) > wings_end:
			if verbose:
				print("Dropping frame because it lies outside of the wings time")
			return Gst.PadProbeReturn.DROP
	return Gst.PadProbeReturn.OK
if InputConfigs["datasource"] == "frames":
	start = gps_start_time
elif InputConfigs["datasource"] == "lvshm":
	tm = time.gmtime()
	start = int(lal.UTCToGPS(tm))
# start time of first frame file is the desired start time + either filter latency or kappa settling (if computing kappas), whichever is bigger
if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
	output_start = start + max(int(filter_settle_time), demodulation_filter_time + int(TDCFConfigs["mediansmoothingtime"]) + int(TDCFConfigs["tdcfaveragingtime"]))
else:
	output_start = start + int(filter_settle_time)

# If the wings option is set, need to also check that frames aren't written during the requested wing time
wings = int(options.wings)
if wings != 0:
	wings_start = gps_start_time + wings
	wings_end = gps_end_time - wings
	mux.get_static_pad("src").add_probe(Gst.PadProbeType.BUFFER, check_complete_frames, (lal.LIGOTimeGPS(output_start,0), lal.LIGOTimeGPS(options.frame_duration*options.frames_per_file,0), lal.LIGOTimeGPS(wings_start, 0), lal.LIGOTimeGPS(wings_end, 0)))
else:
	mux.get_static_pad("src").add_probe(Gst.PadProbeType.BUFFER, check_complete_frames, (lal.LIGOTimeGPS(output_start,0), lal.LIGOTimeGPS(options.frame_duration*options.frames_per_file,0), None, None))

mux = pipeparts.mkprogressreport(pipeline, mux, "progress_sink_%s" % instrument)

if OutputConfigs["datasink"] == "lvshm":
	pipeparts.mkgeneric(pipeline, mux, "gds_lvshmsink", sync=False, async=False, shm_name = OutputConfigs["outputshmpartition"], num_buffers = int(OutputConfigs["numbuffers"]), blocksize = int(OutputConfigs["framesize"])*options.frame_duration*options.frames_per_file, buffer_mode = int(OutputConfigs["buffermode"]))
elif OutputConfigs["datasink"] == "frames":
	pipeparts.mkframecppfilesink(pipeline, mux, frame_type = OutputConfigs["frametype"], path = OutputConfigs["outputpath"], instrument = instrument) 

# Run pipeline

if DebuggingConfigs["pipelinegraphfilename"] != "None":
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(DebuggingConfigs["pipelinegraphfilename"], "NULL"), verbose = verbose)

# Seek the pipeline when necessary
if InputConfigs["datasource"] == "frames":
	if verbose:
		print >>sys.stderr, "seeking GPS start and stop times ..."
	if pipeline.set_state(Gst.State.READY) != Gst.StateChangeReturn.SUCCESS:
		raise RuntimeError("pipeline failed to enter READY state")
	datasource.pipeline_seek_for_gps(pipeline, gps_start_time, gps_end_time)

if verbose:
	print >>sys.stderr, "setting pipeline state to playing ..."
if pipeline.set_state(Gst.State.PLAYING) != Gst.StateChangeReturn.SUCCESS:
	raise RuntimeError("pipeline failed to enter PLAYING state")
else:
	if verbose:
		print "set to playing successfully"
if DebuggingConfigs["pipelinegraphfilename"] != "None":
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(DebuggingConfigs["pipelinegraphfilename"], "PLAYING"), verbose = verbose)
	
if verbose:
	print >>sys.stderr, "running pipeline ..."

mainloop.run()

if pipeline.set_state(Gst.State.NULL) != Gst.StateChangeReturn.SUCCESS:
	raise RuntimeError("pipeline could not be set to NULL")
