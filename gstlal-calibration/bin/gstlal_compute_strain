#!/usr/bin/env python
#
# Copyright (C) 2010-2015  Jordi Burguet-Castell, Madeline Wade, Aaron Viets
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


"""
This pipeline produces h(t) given DARM_ERR and DARM_CTRL or given DELTAL_RESIDUAL and DELTAL_CTRL. It can be run online in real-time or offline on frame files.  It can write h(t) frames to frame files or to a shared memory partition.

The differential arm length resulting from external sources is						

\Delta L_{ext} = ((f^2 + f_s^2 - i * f * f_s / Q) / f^2)							
* ((1 + i * f / f_cc) / (\kappa_c C_res)) * d_{err}							     
+ (A_tst * \kappa_tst + A_pu * \kappa_pu) * d_{ctrl}							    

where C is the static portion of the sensing function, A_tst is the TST actuation function, A_pu is the PUM+UIM actuation, \kappa_c is the time-dependent gain of the sensing function, \kappa_tst is the time-dependent gain of TST actuation, and \kappa_pu is the time-dependent gain of the PUM/UIM actuation.  \Delta L_{ext} is divided by the average arm length (4000 m) to obtain h(t), the external strain in the detectors,												

h(t) = \Delta L_{ext} / L .										  

The time-dependent gains (\kappa's) as well as the value for the coupled cavity pole f_cc and SRC detuning parameters f_s and Q are calcuated in this pipeline as well.

This pipeline will most often be run in a format where it picks up after part of the actuation and sensing functions have been applied to the appropriate channels.  In this mode, the input channels are \Delta L_{res} and \Delta L_{ctrl, i}.  This pipeline then applies further high frequency corrections to each of these channels, applies the appropriate time delay to each channel, adds the channels together, and divides by L.											

h(t) = (((f^2 + f_s^2 - i * f * f_s / Q) / f^2)							     
* ((1 + i * f / f_cc) / \kappa_c) * corrections * \Delta L_{res}						    
+ \kappa_tst * \Delta L_{ctrl, TST}										 
+ \kappa_pu * (\Delta L_{ctrl, P} + \Delta L_{ctrl, U})) / L							

Note: The actuation \kappa's are complex numbers.  Only the real part of the computed \kappa's are applied as time-dependent gain corrections.

Further documentation explaining the time domain calibration procedure can be found in LIGO DCC #T1400256 and #P1700236.

For a full list of example command lines that were used to create the O1 h(t) frames, see https://wiki.ligo.org/Calibration/GDSCalibrationConfigurationsO1.
For a full list of example command lines that were used to create the O2 h(t) frames, see https://wiki.ligo.org/Calibration/GDSCalibrationConfigurationsO2.

Type gstlal_compute_strain --help to see the full list of command line options.
"""

import os
import sys
import numpy
import time
import resource

from optparse import OptionParser, Option
import ConfigParser

import gi
gi.require_version('Gst', '1.0')
from gi.repository import GObject, Gst
GObject.threads_init()
Gst.init(None)

import lal

from gstlal import pipeparts
from gstlal import calibration_parts
from gstlal import simplehandler
from gstlal import datasource

from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
array.use_in(ligolw.LIGOLWContentHandler)
param.use_in(ligolw.LIGOLWContentHandler)
from glue.ligolw import utils
from ligo import segments

#
# Function definition for writing pipeline graph
#

def write_graph(demux):
	pipeparts.write_dump_dot(pipeline, "%s.%s" % (DebuggingConfigs["pipelinegraphfilename"], "PLAYING"), verbose = True)

#
# Make sure we have sufficient resources
# We allocate far more memory than we need, so this is okay
#

def setrlimit(res, lim):
	hard_lim = resource.getrlimit(res)[1]
	resource.setrlimit(res, (lim if lim is not None else hard_lim, hard_lim))
# set the number of processes and total set size up to hard limit and
# shrink the per-thread stack size (default is 10 MiB)
setrlimit(resource.RLIMIT_NPROC, None)
setrlimit(resource.RLIMIT_AS, None)
setrlimit(resource.RLIMIT_RSS, None)
setrlimit(resource.RLIMIT_STACK, 1024*1024)

#
# Function definition to obtain the current GPS time
#

def now():
	return lal.LIGOTimeGPS(lal.UTCToGPS(time.gmtime()), 0)
	

#
# Function to update FIR matrix property
#

def fir_matrix_update(elem, arg, filtered):
	filtered.set_property("kernel", elem.get_property("fir_matrix")[0][::-1])
	print("fir matrix updated")

#############################################################################
##################### Program Command Line Options ##########################
#############################################################################

parser = OptionParser(description = __doc__)

# Append program specific options

# These options should be used whether the pipeline runs in full calibration mode or partial calibration mode
parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the start time of the segment to analyze in GPS seconds. This is required iff --data-source=frames")
parser.add_option("--gps-end-time", metavar = "seconds", help = "Set the end time of the segment to analyze in GPS seconds. This is required iff --data-source=frames")
parser.add_option("--wings", metavar = "seconds", default = 0, type = "int", help = "Number of seconds to trim off of the beginning and end of the output. Should only be used if --data-source=frames.")
parser.add_option("--frame-duration", metavar = "seconds", type = "int", default = 4, help = "Set the number of seconds for each frame. (Default = 4)")
parser.add_option("--frames-per-file", metavar = "count", type = "int", default = 1, help = "Set the number of frames per frame file. (Default = 1)")
parser.add_option("--config-file", metavar = "name", help = "Full path to configuration file for running.")

# Parse options
options, filenames = parser.parse_args()

#############################################################################
######################### Config File Options  ##############################
#############################################################################

def ConfigSectionMap(section):
	dict1 = {}
	options = Config.options(section)
	for option in options:
		try:
			dict1[option] = Config.get(section, option)
			if dict1[option] == -1:
				DebugPrint("skip: %s" % option)
		except:
			print("exception on %s!" % option)
			dict[option] = None
	return dict1

Config = ConfigParser.ConfigParser()
Config.read(options.config_file)

InputConfigs = ConfigSectionMap("InputConfigurations")
OutputConfigs = ConfigSectionMap("OutputConfigurations")
CalibrationConfigs = ConfigSectionMap("CalibrationConfigurations")
DebuggingConfigs = ConfigSectionMap("DebuggingConfigurations")
TDCFConfigs = ConfigSectionMap("TDCFConfigurations")
ChannelNames = ConfigSectionMap("ChannelNames")
SampleRates = ConfigSectionMap("SampleRates")
Bitmasks = ConfigSectionMap("Bitmasks")
PipelineConfigs = ConfigSectionMap("PipelineConfigurations")
DataCleaningConfigs = ConfigSectionMap("DataCleaningConfigurations")

# Track the "version" of the config file, which tells us what variables are contained
config_version = int(InputConfigs["configversion"])


# Sanity checks for command line options
data_sources = set(("frames", "lvshm"))

if InputConfigs["datasource"] not in data_sources:
	raise ValueError("DataSource must be one of %s" % ",".join(data_sources))

if InputConfigs["datasource"] == "frames" and InputConfigs["framecache"] is None:
	raise ValueError("FrameCache must be specified when using DataSource: frames")

if int(options.wings != 0) and InputConfigs["datasource"] != "frames":
	raise ValueError("Wings can only be set when DataSource: frames")

if CalibrationConfigs["ifo"] is None:
	raise ValueError("must specify IFO")

if InputConfigs["datasource"] == "frames" and (options.gps_start_time is None or options.gps_end_time is None):
	raise ValueError("must specify --gps-start-time and --gps-end-time when DataSource: frames")

if (CalibrationConfigs["calibrationmode"] != "Full") and (CalibrationConfigs["calibrationmode"] != "Partial"):
	raise ValueError("must specify either Full or Partial for CalibrationMode")

if int(TDCFConfigs["recordfactorssr"]) > int(TDCFConfigs["computefactorssr"]):
	raise ValueError("RecordFactorsSR must be less than or equal to ComputeFactorsSR")

if (Config.getboolean("TDCFConfigurations", "applycomplexkappapum") or Config.getboolean("TDCFConfigurations", "applykappapum") or Config.getboolean("TDCFConfigurations", "applycomplexkappauim") or Config.getboolean("TDCFConfigurations", "applykappauim")) and (Config.getboolean("TDCFConfigurations", "applycomplexkappapu") or Config.getboolean("TDCFConfigurations", "applykappapu")):
	raise ValueError("Cannot apply any corrections for kappa_PU if corrections are already being applied for kappa_PUM or kappa_UIM")

if TDCFConfigs["factorsfromfiltersfile"] is "No" and (TDCFConfigs["computefs"] is "Yes" or TDCFConfigs["computesrcq"] is "Yes") and ((InputConfigs["datasource"] is "frames" and int(options.gps_start_time) < 1175954418)):
	raise ValueError("Cannot compute SRC detuning parameters as the needed EPICS channels are not in the frames until GPS time 1175954418. Set ComputeFs: No and ComputeSRCQ: No.")

if options.gps_start_time is not None:
	if options.gps_end_time is None:
		raise ValueError("must provide both --gps-start-time and --gps-end-time")
	if InputConfigs["datasource"] == "lvshm":
		raise ValueError("cannot set --gps-start-time or --gps-end-time with DataSource: lvshm")
	if int(options.gps_start_time) >= int(options.gps_end_time):
		raise ValueError("--gps-start-time must be < --gps-end-time: %s < %s" % (options.gps_start_time, options.gps_end_time))
elif options.gps_end_time is not None:
	raise ValueError("must provide both --gps-start-time and --gps-end-time")

###################################################################################################
######################################## Setup ####################################################
###################################################################################################

# Set up instrument and channel name info from command line options
instrument = CalibrationConfigs["ifo"]

if options.gps_start_time is not None and options.gps_end_time is not None:
	gps_start_time = int(options.gps_start_time)
	gps_end_time = int(options.gps_end_time)

# Set up short-cut names for each of the sample rates used throughout the pipeline and establish caps string shortcuts
hoft_sr = int(SampleRates["hoftsr"]) # Sample rate for h(t)
calibstate_sr = int(SampleRates["calibstatesr"]) # Sample rate for the CALIB_STATE_VECTOR
odc_sr = int(SampleRates["odcsr"]) # Sample rate of the ODC channel that is read in
ctrl_sr = int(SampleRates["ctrlsr"]) # Sample rate of the control channel (such as DARM_CTRL or DELTAL_CTRL)
tst_exc_sr = int(SampleRates["tstexcsr"])
pum_exc_sr = int(SampleRates["pumexcsr"])
uim_exc_sr = int(SampleRates["uimexcsr"])
coh_sr = int(SampleRates["cohsr"]) # Sample rate for the coherence uncertainty channels
epics_sr = int(SampleRates["epicsrefsr"]) # Sample rate for EPICS records used for TDCFs
compute_factors_sr = int(SampleRates["computefactorssr"]) # Sample rate for computing TDCFs
record_factors_sr = int(SampleRates["recordfactorssr"]) # Sample rate for recording TDCFs
hoft_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % hoft_sr
ctrl_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % ctrl_sr
calibstate_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % calibstate_sr
odc_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % odc_sr
coh_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % coh_sr
ref_factors_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % epics_sr
compute_calib_factors_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0X0" % compute_factors_sr
compute_calib_factors_complex_caps = "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % compute_factors_sr

# Short cut names for a few other items that appear numerous times
filter_latency_factor = float(PipelineConfigs["filterlatency"])
demodulation_filter_time = int(TDCFConfigs["demodulationfiltertime"])
coherence_unc_threshold = float(TDCFConfigs["coherenceuncthreshold"])
actuation_filter_update_time = float(TDCFConfigs["actuationfilterupdatetime"])
actuation_filter_averaging_time = float(TDCFConfigs["actuationfilteraveragingtime"])
actuation_filter_taper_length = int(TDCFConfigs["actuationfiltertaperlength"])
sensing_filter_update_time = float(TDCFConfigs["sensingfilterupdatetime"])
sensing_filter_averaging_time = float(TDCFConfigs["sensingfilteraveragingtime"])
sensing_filter_taper_length = int(TDCFConfigs["sensingfiltertaperlength"])
cleaning_check_rms_time = float(DataCleaningConfigs["cleaningcheckrmstime"])
cleaning_check_range_low_min = float(DataCleaningConfigs["cleaningcheckrangelowmin"])
cleaning_check_range_low_max = float(DataCleaningConfigs["cleaningcheckrangelowmax"])
cleaning_check_range_mid_min = float(DataCleaningConfigs["cleaningcheckrangemidmin"])
cleaning_check_range_mid_max = float(DataCleaningConfigs["cleaningcheckrangemidmax"])
powerlines_tf_averaging_time = float(DataCleaningConfigs["powerlinestfaveragingtime"])
powerlines_freq_var = float(DataCleaningConfigs["powerlinesfreqvar"])
witness_channel_fft_time = float(DataCleaningConfigs["witnesschannelffttime"])
num_witness_ffts = int(DataCleaningConfigs["numwitnessffts"])
min_witness_ffts = int(DataCleaningConfigs["minwitnessffts"])
witness_fir_length = float(DataCleaningConfigs["witnessfirlength"])
witness_frequency_resolution = float(DataCleaningConfigs["witnessfrequencyresolution"])
witness_tf_update_time = float(DataCleaningConfigs["witnesstfupdatetime"])
critical_lock_loss_time = float(DataCleaningConfigs["criticallocklosstime"])
witness_filter_taper_time = float(DataCleaningConfigs["witnessfiltertapertime"])

expected_kappatst_real = float(TDCFConfigs["expectedkappatstreal"])
expected_kappatst_imag = float(TDCFConfigs["expectedkappatstimag"])
expected_kappapu_real = float(TDCFConfigs["expectedkappapureal"])
expected_kappapu_imag = float(TDCFConfigs["expectedkappapuimag"])
expected_kappapum_real = float(TDCFConfigs["expectedkappapumreal"])
expected_kappapum_imag = float(TDCFConfigs["expectedkappapumimag"])
expected_kappauim_real = float(TDCFConfigs["expectedkappauimreal"])
expected_kappauim_imag = float(TDCFConfigs["expectedkappauimimag"])
expected_kappac = float(TDCFConfigs["expectedkappac"])
expected_fcc = float(TDCFConfigs["expectedfcc"])
expected_fs = float(TDCFConfigs["expectedfs"])
expected_srcq = float(TDCFConfigs["expectedsrcq"])
kappatst_real_var = float(TDCFConfigs["kappatstrealvar"])
kappatst_imag_var = float(TDCFConfigs["kappatstimagvar"])
kappapu_real_var = float(TDCFConfigs["kappapurealvar"])
kappapu_imag_var = float(TDCFConfigs["kappapuimagvar"])
kappapum_real_var = float(TDCFConfigs["kappapumrealvar"])
kappapum_imag_var = float(TDCFConfigs["kappapumimagvar"])
kappauim_real_var = float(TDCFConfigs["kappauimrealvar"])
kappauim_imag_var = float(TDCFConfigs["kappauimimagvar"])
kappac_var = float(TDCFConfigs["kappacvar"])
fcc_var = float(TDCFConfigs["fccvar"])
fs_var = float(TDCFConfigs["fsvar"])
srcQinv_min = float(TDCFConfigs["srcqinvmin"])
srcQinv_max = float(TDCFConfigs["srcqinvmax"])

# Set up smoothing, averaging and integration sample sizes for kappa calulations
integration_samples = demodulation_filter_time * compute_factors_sr
factors_average_samples = int(TDCFConfigs["tdcfaveragingtime"]) * compute_factors_sr
median_smoothing_samples = int(TDCFConfigs["mediansmoothingtime"]) * compute_factors_sr
kappa_gate_attack_length = -integration_samples * (1.0 - filter_latency_factor)
kappa_gate_hold_length = -integration_samples * filter_latency_factor - (filter_latency_factor != 0) * int(TDCFConfigs["coherencetime"]) * compute_factors_sr

# Set up string for the channels suffix and prefix as provided by the user
if OutputConfigs["chansuffix"] != "None":
	chan_suffix = OutputConfigs["chansuffix"]
else:
	chan_suffix = ""
chan_prefix = OutputConfigs["chanprefix"]

# Set up shortcut variables for boolean options
# Booleans for TDCFs
compute_kappatst = Config.getboolean("TDCFConfigurations", "computekappatst")
compute_kappapu = Config.getboolean("TDCFConfigurations", "computekappapu")
compute_kappapum = Config.getboolean("TDCFConfigurations", "computekappapum")
compute_kappauim = Config.getboolean("TDCFConfigurations", "computekappauim")
use_uim_line = Config.getboolean("TDCFConfigurations", "useuimline")
compute_kappac = Config.getboolean("TDCFConfigurations", "computekappac")
compute_fcc = Config.getboolean("TDCFConfigurations", "computefcc")
compute_fs = Config.getboolean("TDCFConfigurations", "computefs")
compute_srcq = Config.getboolean("TDCFConfigurations", "computesrcq")
apply_kappatst = Config.getboolean("TDCFConfigurations", "applykappatst")
apply_complex_kappatst = Config.getboolean("TDCFConfigurations", "applycomplexkappatst")
apply_kappapu = Config.getboolean("TDCFConfigurations", "applykappapu")
apply_complex_kappapu = Config.getboolean("TDCFConfigurations", "applycomplexkappapu")
apply_kappapum = Config.getboolean("TDCFConfigurations", "applykappapum")
apply_complex_kappapum = Config.getboolean("TDCFConfigurations", "applycomplexkappapum")
apply_kappauim = Config.getboolean("TDCFConfigurations", "applykappauim")
apply_complex_kappauim = Config.getboolean("TDCFConfigurations", "applycomplexkappauim")
apply_kappac = Config.getboolean("TDCFConfigurations", "applykappac")
apply_fcc = Config.getboolean("TDCFConfigurations", "applyfcc")
apply_srcq = Config.getboolean("TDCFConfigurations", "applysrcq")
apply_fs = Config.getboolean("TDCFConfigurations", "applyfs")
use_coherence = Config.getboolean("TDCFConfigurations", "usecoherence")
tdcf_default_to_median = Config.getboolean("TDCFConfigurations", "tdcfdefaulttomedian")
# Boolean for state vector computation
compute_calib_statevector = Config.getboolean("CalibrationConfigurations", "computecalibstatevector")
# Boolean for computing factors from filters file
factors_from_filters_file = Config.getboolean("TDCFConfigurations", "factorsfromfiltersfile")
# Boolean for removing calibration lines, power lines, DC component, using median in witness transfer functions
remove_cal_lines = Config.getboolean("DataCleaningConfigurations", "removecallines")
remove_power_lines = Config.getboolean("DataCleaningConfigurations", "removepowerlines")
remove_dc = Config.getboolean("DataCleaningConfigurations", "removedc")
witness_tf_use_median = Config.getboolean("DataCleaningConfigurations", "witnesstfusemedian")
# If td is true we will perform filtering in the time domain (direct convolution) in all FIR filtering routines below
td = not Config.getboolean("PipelineConfigurations", "frequencydomainfiltering")
# Boolean for dewhitening
dewhitening = Config.getboolean("PipelineConfigurations", "dewhitening")
# Boolean for verboseness
verbose = Config.getboolean("DebuggingConfigurations", "verbose")
# Boolean for file_check_sum
file_check_sum = Config.getboolean("InputConfigurations", "filechecksum")
skip_bad_files = Config.getboolean("InputConfigurations", "skipbadfiles")

#
# Load in the filters file that contains filter coefficients, etc.
#

# Search the directory tree for files with names matching the one we want.
filters_name = InputConfigs["filtersfilename"]
filters_paths = []
# Check the user's home directory
for dirpath, dirs, files in os.walk(os.environ['HOME']):
	if filters_name in files:
		# We prefer filters that came directly from a GDSFilters directory of the calibration SVN
		if dirpath.count("GDSFilters") > 0:
			filters_paths.insert(0, os.path.join(dirpath, filters_name))
		else:
			filters_paths.append(os.path.join(dirpath, filters_name))
# Check if there is a checkout of the entire calibration SVN
for dirpath, dirs, files in os.walk('/ligo/svncommon/CalSVN/aligocalibration/trunk/Runs/'):
	if filters_name in files:
		# We prefer filters that came directly from a GDSFilters directory of the calibration SVN
		if dirpath.count("GDSFilters") > 0:
			filters_paths.insert(0, os.path.join(dirpath, filters_name))
		else:
			filters_paths.append(os.path.join(dirpath, filters_name))
if not len(filters_paths):
	raise ValueError("Cannot find filters file %s in home directory %s or in /ligo/svncommon/CalSVN/aligocalibration/trunk/Runs/*/GDSFilters", (filters_name, os.environ['HOME']))
print "\nLoading calibration filters from %s\n" % filters_paths[0]
filters = numpy.load(filters_paths[0])

# In case we want to remove calibration lines, we will fill these dictionaries
pcal_line_removal_dict = {}
act_line_removal_dict = {}

# Load all of the calibration line frequencies and and pcal correction factors
try:
	act_pcal_line_freq = float(filters["ka_pcal_line_freq"])
	pcal_corr_at_act_freq_real = float(filters["ka_pcal_corr_re"])
	pcal_corr_at_act_freq_imag = float(filters["ka_pcal_corr_im"])
	if act_pcal_line_freq > 10:
		pcal_line_removal_dict["pcal1"] = [None, act_pcal_line_freq, pcal_corr_at_act_freq_real, pcal_corr_at_act_freq_imag, False]
except:
	if compute_kappatst or compute_kappapu or compute_kappauim or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		raise ValueError("Cannot compute any time-dependent correction factors, as the ~30 Hz pcal line frequency is not in the filters file")
try:
	darm_ctrl_line_freq = float(filters["ka_esd_line_freq"])
except:
	if(compute_kappapu or (compute_kappauim and not use_uim_line)):
		raise ValueError("Cannot compute kappa_U or kappa_PU using DARM ctrl line, because the specified filters do not have the DARM ctrl line frequency")
try:
	opt_gain_fcc_line_freq = float(filters["kc_pcal_line_freq"])
	pcal_corr_at_opt_gain_fcc_freq_real = float(filters["kc_pcal_corr_re"])
	pcal_corr_at_opt_gain_fcc_freq_imag = float(filters["kc_pcal_corr_im"])
	if opt_gain_fcc_line_freq > 10:
		pcal_line_removal_dict["pcal2"] = [None, opt_gain_fcc_line_freq, pcal_corr_at_opt_gain_fcc_freq_real, pcal_corr_at_opt_gain_fcc_freq_imag, False]
except:
	if compute_kappac or compute_fcc or compute_fs or compute_srcq:
		raise ValueError("Cannot compute kappa_C, f_cc, f_s, or Q, as the ~300 Hz pcal line is not in the filters file")
try:
	esd_act_line_freq = float(filters["ktst_esd_line_freq"])
	if esd_act_line_freq > 10:
		act_line_removal_dict["esd1"] = [None, esd_act_line_freq, "EP10_real", "EP10_imag", False, apply_complex_kappatst, apply_kappatst, None]
except:
	if compute_kappatst or compute_kappapu or (compute_kappauim and not use_uim_line) or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		raise ValueError("Cannot compute any time-dependent correction factors, as the ESD line frequency is not in the filters file")
try:
	pum_act_line_freq = float(filters["pum_act_line_freq"])
	if pum_act_line_freq > 10:
		act_line_removal_dict["pum1"] = [None, pum_act_line_freq, "EP23_real", "EP23_imag", False, apply_complex_kappapum, apply_kappapum, None]
except:
	if compute_kappapum:
		raise ValueError("Cannot compute kappa_PUM, as the specified filters file does not contain the needed calibration line frequency")
try:
	uim_act_line_freq = float(filters["uim_act_line_freq"])
	if uim_act_line_freq > 10:
		act_line_removal_dict["uim1"] = [None, uim_act_line_freq, "EP24_real", "EP24_imag", False, apply_complex_kappauim, apply_kappauim, None]
except:
	if compute_kappauim and use_uim_line:
		raise ValueError("Cannot compute kappa_UIM using the UIM actuation line, as the specified filters file does not contain that calibration line frequency")

try:
	src_pcal_line_freq = float(filters["src_pcal_line_freq"])
	pcal_corr_at_src_freq_real = float(filters["src_pcal_corr_re"])
	pcal_corr_at_src_freq_imag = float(filters["src_pcal_corr_im"])
	if src_pcal_line_freq > 10.0 and src_pcal_line_freq != act_pcal_line_freq:
		pcal_line_removal_dict["pcal4"] = [None, src_pcal_line_freq, pcal_corr_at_src_freq_real, pcal_corr_at_src_freq_imag, False]
except:
	if compute_srcq or compute_fs:
		raise ValueError("Cannot compute SRC spring frequency or Q, as the calibration line frequency is not contained in the specified filters file.")
try:
	high_pcal_line_freq = float(filters["high_pcal_line_freq"])
	pcal_corr_at_high_line_freq_real = float(filters["high_pcal_corr_re"])
	pcal_corr_at_high_line_freq_imag = float(filters["high_pcal_corr_im"])
	if high_pcal_line_freq > 10:
		pcal_line_removal_dict["pcal3"] = [None, high_pcal_line_freq, pcal_corr_at_high_line_freq_real, pcal_corr_at_high_line_freq_imag, False]
except Exception:
	pass
try:
	roaming_pcal_line_freq = float(filters["roaming_pcal_line_freq"])
	pcal_corr_at_roaming_line_real = float(filters["roaming_pcal_corr_re"])
	pcal_corr_at_roaming_line_imag = float(filters["roaming_pcal_corr_im"])
	if roaming_pcal_line_freq > 10:
		pcal_line_removal_dict["pcal5"] = [None, roaming_pcal_line_freq, pcal_corr_at_roaming_line_real, pcal_corr_at_roaming_line_imag, False]
except Exception:
	pass
try:
	fcc_default = float(filters["fcc"])
except:
	fcc_default = expected_fcc
try:
	fs_default = float(filters["fs"])
	srcQ_default = float(filters["srcQ"])
except:
	fs_default = expected_fs
	srcQ_default = expected_srcq

# Load kappa dewhitening factors
if dewhitening:
	try:
		derr_dewhiten_at_darm_act_freq_real = float(filters["ka_pcal_whitener_re"])
		derr_dewhiten_at_darm_act_freq_imag = float(filters["ka_pcal_whitener_im"])
		derr_dewhiten_at_pu_act_freq_real = float(filters["ka_esd_whitener_re"])
		derr_dewhiten_at_pu_act_freq_imag = float(filters["ka_esd_whitener_im"])
		derr_dewhiten_at_opt_gain_fcc_freq_real = float(filters["kc_pcal_whitener_re"])
		derr_dewhiten_at_opt_gain_fcc_freq_imag = float(filters["kc_pcal_whitener_im"])
		derr_dewhiten_at_esd_act_freq_real = float(filters["ktst_esd_whitener_re"])
		derr_dewhiten_at_esd_act_freq_imag = float(filters["ktst_esd_whitener_im"])
	except:
		derr_dewhiten_at_darm_act_freq_real = 1.0
		derr_dewhiten_at_darm_act_freq_imag = 0.0
		derr_dewhiten_at_pu_act_freq_real = 1.0
		derr_dewhiten_at_pu_act_freq_imag = 0.0
		derr_dewhiten_at_opt_gain_fcc_freq_real = 1.0
		derr_dewhiten_at_opt_gain_fcc_freq_imag = 0.0
		derr_dewhiten_at_esd_act_freq_real = 1.0
		derr_dewhiten_at_esd_act_freq_imag = 0.0

# If we're reading the reference model factors from the filters file or comparing them to the front-end factors, load them
if factors_from_filters_file or compute_calib_statevector:
	try:
		EP1_real = float(filters["EP1_real"])
		EP1_imag = float(filters["EP1_imag"])
		EP2_real = float(filters["EP2_real"])
		EP2_imag = float(filters["EP2_imag"])
		EP3_real = float(filters["EP3_real"])
		EP3_imag = float(filters["EP3_imag"])
		EP4_real = float(filters["EP4_real"])
		EP4_imag = float(filters["EP4_imag"])
		EP5_real = float(filters["EP5_real"])
		EP5_imag = float(filters["EP5_imag"])
		EP6_real = float(filters["EP6_real"])
		EP6_imag = float(filters["EP6_imag"])
		EP7_real = float(filters["EP7_real"])
		EP7_imag = float(filters["EP7_imag"])
		EP8_real = float(filters["EP8_real"])
		EP8_imag = float(filters["EP8_imag"])
		EP9_real = float(filters["EP9_real"])
		EP9_imag = float(filters["EP9_imag"])
	except:
		if factors_from_filters_file:
			raise ValueError("Cannot compute time-dependent correction factors, as the needed EPICS are not contained in the specified filters file.")
	try:
		EP10_real = float(filters["EP10_real"])
		EP10_imag = float(filters["EP10_imag"])
	except:
		if factors_from_filters_file and "esd1" in act_line_removal_dict.keys():
			del act_line_removal_dict["esd1"]
	try:
		EP11_real = float(filters["EP11_real"])
		EP11_imag = float(filters["EP11_imag"])
		EP12_real = float(filters["EP12_real"])
		EP12_imag = float(filters["EP12_imag"])
		EP13_real = float(filters["EP13_real"])
		EP13_imag = float(filters["EP13_imag"])
		EP14_real = float(filters["EP14_real"])
		EP14_imag = float(filters["EP14_imag"])
	except:
		if factors_from_filters_file and (compute_srcq or compute_fs):
			raise ValueError("Cannot compute SRC spring frequency or Q, as the needed EPICS are not contained in the specified filters file.")

	try:
		EP15_real = float(filters["EP15_real"])
		EP15_imag = float(filters["EP15_imag"])
		EP16_real = float(filters["EP16_real"])
		EP16_imag = float(filters["EP16_imag"])
		EP17_real = float(filters["EP17_real"])
		EP17_imag = float(filters["EP17_imag"])
		EP18_real = float(filters["EP18_real"])
		EP18_imag = float(filters["EP18_imag"])
		EP19_real = float(filters["EP19_real"])
		EP19_imag = float(filters["EP19_imag"])
		EP20_real = float(filters["EP20_real"])
		EP20_imag = float(filters["EP20_imag"])
		EP21_real = float(filters["EP21_real"])
		EP21_imag = float(filters["EP21_imag"])
		EP22_real = float(filters["EP22_real"])
		EP22_imag = float(filters["EP22_imag"])
		EP23_real = float(filters["EP23_real"])
		EP23_imag = float(filters["EP23_imag"])
		EP24_real = float(filters["EP24_real"])
		EP24_imag = float(filters["EP24_imag"])
	except:
		if factors_from_filters_file and (compute_kappapum or compute_kappauim):
			raise ValueError("Cannot compute kappa_PUM or kappa_UIM, as the needed EPICS are not contained in the specified filters file.")

# If we're performing partial calibration, load the deltal filters
if CalibrationConfigs["calibrationmode"] == "Partial":
	reschaindelay = int(filters["res_corr_delay"])
	reschainfilt = filters["res_corr_filter"]
	tstdelay = pumdelay = uimdelay = pumuimdelay = int(filters["ctrl_corr_delay"])
	tstfilt = pumfilt = uimfilt = pumuimfilt = filters["ctrl_corr_filter"]
	tstchainsr = pumchainsr = uimchainsr = pumuimchainsr = int(filters["ctrl_corr_sr"])
	if dewhitening:
		tstdewhitensr = int(filters["deltal_tst_dewhiten_sr"])
		tstdewhitendelay = int(filters["deltal_tst_dewhiten_delay"])
		tstdewhiten = filters["deltal_tst_dewhiten"]
		if apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim:
			pumdewhitensr = int(filters["deltal_pum_dewhiten_sr"])
			pumdewhitendelay = int(filters["deltal_pum_dewhiten_delay"])
			pumdewhiten = filters["deltal_pum_dewhiten"]
			uimdewhitensr = int(filters["deltal_uim_dewhiten_sr"])
			uimdewhitendelay = int(filters["deltal_uim_dewhiten_delay"])
			uimdewhiten = filters["deltal_uim_dewhiten"]
		else:
			pumuimdewhitensr = int(filters["deltal_pumuim_dewhiten_sr"])
			pumuimdewhitendelay = int(filters["deltal_pumuim_dewhiten_delay"])
			pumuimdewhiten = filters["deltal_pumuim_dewhiten"]
		resdewhitendelay = int(filters["deltal_res_dewhiten_delay"])
		resdewhiten = filters["deltal_res_dewhiten"]

	# Load the high-pass filter for h(t)
	try:
		act_highpass_delay = int(filters['ctrl_highpass_delay'])
		invsens_highpass_delay = int(filters['res_highpass_delay'])
		act_highpass = filters["ctrl_highpass"]
		invsens_highpass = filters["res_highpass"]
	except:
		act_highpass = []
		invsens_highpass = []
		invsens_highpass_delay = 0
		act_highpass_delay = 0

# If we're performing full calibration, load the actuation, sensing filters
if CalibrationConfigs["calibrationmode"] == "Full":
	tstchainsr = int(filters["actuation_tst_sr"])
	tstdelay = int(filters["actuation_tst_delay"])
	tstfilt = filters["actuation_tst"]
	try:
		pumchainsr = int(filters["actuation_pum_sr"])
		pumdelay = int(filters["actuation_pum_delay"])
		pumfilt = filters["actuation_pum"]
		uimchainsr = int(filters["actuation_uim_sr"])
		uimdelay = int(filters["actuation_uim_delay"])
		uimfilt = filters["actuation_uim"]
	except:
		if apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim:
			raise ValueError("PUM and UIM actuation filters are needed since the PUM and UIM stages are being split")
	try:
		pumuimchainsr = int(filters["actuation_pumuim_sr"])
		pumuimdelay = int(filters["actuation_pumuim_delay"])
		pumuimfilt = filters["actuation_pumuim"]
	except:
		if not (apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim):
			raise ValueError("PUM/UIM actuation filter is needed since the PUM and UIM stages are not being split")
	reschaindelay = int(filters["inv_sens_delay"])
	reschainfilt = filters["inv_sensing"]
	if dewhitening:
		ctrldewhitendelay = int(filters["dewhiten_ctrl_delay"])
		ctrldewhiten = filters["dewhiten_ctrl"]
		ctrldewhitensr = int(filters["dewhiten_ctrl_sr"])
		resdewhitendelay = int(filters["dewhiten_err_delay"])
		resdewhiten = filters["dewhiten_err"]

	# Load the high-pass filter for h(t)
	try:
		act_highpass_delay = int(filters['actuation_highpass_delay'])
		invsens_highpass_delay = int(filters['invsens_highpass_delay'])
		act_highpass = filters["actuation_highpass"]
		invsens_highpass = filters["inv_sensing_highpass"]
	except:
		act_highpass = []
		invsens_highpass = []

# If we are reading EPICS from the frames and want to remove calibration lines, account for the fact that not all EPICS were available at all times.
if not factors_from_filters_file and InputConfigs["datasource"] == "frames" and ((instrument == "H1" and gps_start_time < 1175976256) or (instrument == "L1" and gps_start_time < 1179588864)) and "esd1" in act_line_removal_dict.keys():
	del act_line_removal_dict["esd1"]

#
# Set up the appropriate channel list. In this section, we also fill a list called headkeys
# that will be the keys for the dictionary holding each pipeline branch name, and we set up
# a dictionary that will be populated with pipeline branch names based on the channel list.
#

head_dict = {}
channel_list = []
headkeys = []

# If we are computing the CALIB_STATE_VECTOR, we need the ODC state vector
if compute_calib_statevector:
	channel_list.append((instrument, ChannelNames["inputdqchannel"]))
	headkeys.append("odcstatevector")

# If we are using the front-end EPICS records to either compute the TDCFs or the CALIB_STATE_VECTOR, we need to add those channels
# Needed for kappa_tst, kappa_pum, kappa_uim, kappa_pu, kappa_c, f_cc, f_s, and Q
if not factors_from_filters_file or compute_calib_statevector:
	if (compute_kappatst or compute_kappapu or compute_kappapum or compute_kappauim or compute_kappac or compute_fcc or compute_fs or compute_srcq):
		channel_list.extend(((instrument, ChannelNames["ep1realchannel"]), (instrument, ChannelNames["ep1imagchannel"])))
		headkeys.extend(("EP1_real", "EP1_imag"))
	# These are needed for kappa_PUM
	if compute_kappapum or (compute_kappauim and (not use_uim_line or compute_kappac or compute_fcc or compute_fs or compute_srcq)):
		channel_list.extend(((instrument, ChannelNames["ep15realchannel"]), (instrument, ChannelNames["ep15imagchannel"])))
		headkeys.extend(("EP15_real", "EP15_imag"))
	# These are needed for kappa_UIM
	if compute_kappauim or (compute_kappapum and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
		if use_uim_line:
			channel_list.extend(((instrument, ChannelNames["ep22realchannel"]), (instrument, ChannelNames["ep22imagchannel"])))
			headkeys.extend(("EP22_real", "EP22_imag"))
		else:
			channel_list.extend(((instrument, ChannelNames["ep2realchannel"]), (instrument, ChannelNames["ep2imagchannel"]), (instrument, ChannelNames["ep4realchannel"]), (instrument, ChannelNames["ep4imagchannel"]), (instrument, ChannelNames["ep16realchannel"]), (instrument, ChannelNames["ep16imagchannel"]), (instrument, ChannelNames["ep17realchannel"]), (instrument, ChannelNames["ep17imagchannel"])))
			headkeys.extend(("EP2_real", "EP2_imag", "EP4_real", "EP4_imag", "EP16_real", "EP16_imag", "EP17_real", "EP17_imag"))
	# These are needed for kappa_PU
	if (compute_kappapu or ((compute_kappac or compute_fcc or compute_fs or compute_srcq) and not (compute_kappapum or compute_kappauim))):
		channel_list.extend(((instrument, ChannelNames["ep3realchannel"]), (instrument, ChannelNames["ep3imagchannel"])))
		headkeys.extend(("EP3_real", "EP3_imag"))
		# Additionally, if kappa_UIM is not calculated using the DARM line, we need these
		if use_uim_line or not (compute_kappauim or (compute_kappapum and (compute_kappac or compute_fcc or compute_fs or compute_srcq))):
			channel_list.extend(((instrument, ChannelNames["ep2realchannel"]), (instrument, ChannelNames["ep2imagchannel"]), (instrument, ChannelNames["ep4realchannel"]), (instrument, ChannelNames["ep4imagchannel"])))
			headkeys.extend(("EP2_real", "EP2_imag", "EP4_real", "EP4_imag"))
	# These are needed for kappa_C and f_cc
	if compute_kappac or compute_fcc or compute_fs or compute_srcq:
		if compute_kappapum or compute_kappauim:
			channel_list.extend(((instrument, ChannelNames["ep6realchannel"]), (instrument, ChannelNames["ep6imagchannel"]), (instrument, ChannelNames["ep7realchannel"]), (instrument, ChannelNames["ep7imagchannel"]), (instrument, ChannelNames["ep8realchannel"]), (instrument, ChannelNames["ep8imagchannel"]), (instrument, ChannelNames["ep18realchannel"]), (instrument, ChannelNames["ep18imagchannel"]), (instrument, ChannelNames["ep19realchannel"]), (instrument, ChannelNames["ep19imagchannel"])))
			headkeys.extend(("EP6_real", "EP6_imag", "EP7_real", "EP7_imag", "EP8_real", "EP8_imag", "EP18_real", "EP18_imag", "EP19_real", "EP19_imag"))
		else:
			channel_list.extend(((instrument, ChannelNames["ep6realchannel"]), (instrument, ChannelNames["ep6imagchannel"]), (instrument, ChannelNames["ep7realchannel"]), (instrument, ChannelNames["ep7imagchannel"]), (instrument, ChannelNames["ep8realchannel"]), (instrument, ChannelNames["ep8imagchannel"]), (instrument, ChannelNames["ep9realchannel"]), (instrument, ChannelNames["ep9imagchannel"])))
			headkeys.extend(("EP6_real", "EP6_imag", "EP7_real", "EP7_imag", "EP8_real", "EP8_imag", "EP9_real", "EP9_imag"))

	# These are needed if we compute the optical spring frequency and/or Q-factor of the Signal Recycling Cavity (SRC)
	if compute_fs or compute_srcq:
		if compute_kappapum or compute_kappauim:
			channel_list.extend(((instrument, ChannelNames["ep11realchannel"]), (instrument, ChannelNames["ep11imagchannel"]), (instrument, ChannelNames["ep12realchannel"]), (instrument, ChannelNames["ep12imagchannel"]), (instrument, ChannelNames["ep13realchannel"]), (instrument, ChannelNames["ep13imagchannel"]), (instrument, ChannelNames["ep20realchannel"]), (instrument, ChannelNames["ep20imagchannel"]), (instrument, ChannelNames["ep21realchannel"]), (instrument, ChannelNames["ep21imagchannel"])))
			headkeys.extend(("EP11_real", "EP11_imag", "EP12_real", "EP12_imag", "EP13_real", "EP13_imag", "EP20_real", "EP20_imag", "EP21_real", "EP21_imag"))
		else:
			channel_list.extend(((instrument, ChannelNames["ep11realchannel"]), (instrument, ChannelNames["ep11imagchannel"]), (instrument, ChannelNames["ep12realchannel"]), (instrument, ChannelNames["ep12imagchannel"]), (instrument, ChannelNames["ep13realchannel"]), (instrument, ChannelNames["ep13imagchannel"]), (instrument, ChannelNames["ep14realchannel"]), (instrument, ChannelNames["ep14imagchannel"])))
			headkeys.extend(("EP11_real", "EP11_imag", "EP12_real", "EP12_imag", "EP13_real", "EP13_imag", "EP14_real", "EP14_imag"))
	# EP10 is needed to remove the ESD line
	if remove_cal_lines and "esd1" in act_line_removal_dict.keys():
		channel_list.extend(((instrument, ChannelNames["ep10realchannel"]), (instrument, ChannelNames["ep10imagchannel"])))
		headkeys.extend(("EP10_real", "EP10_imag"))
	# EP23 is needed to remove the PUM line
	if remove_cal_lines and "pum1" in act_line_removal_dict.keys():
		channel_list.extend(((instrument, ChannelNames["ep23realchannel"]), (instrument, ChannelNames["ep23imagchannel"])))
		headkeys.extend(("EP23_real", "EP23_imag"))
	# EP24 is needed to remove the UIM line
	if remove_cal_lines and "uim1" in act_line_removal_dict.keys():
		channel_list.extend(((instrument, ChannelNames["ep24realchannel"]), (instrument, ChannelNames["ep24imagchannel"])))
		headkeys.extend(("EP24_real", "EP24_imag"))

	# If we are using pre-computed coherence to gate kappas
if use_coherence:
	if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		channel_list.extend(((instrument, ChannelNames["cohuncsusline1channel"]), (instrument, ChannelNames["cohuncpcalyline1channel"]), (instrument, ChannelNames["cohuncdarmline1channel"])))
		headkeys.extend(("pcaly_line1_coh", "sus_coh", "darm_coh"))
	if compute_kappac or compute_fcc or compute_fs or compute_srcq:
		channel_list.append((instrument, ChannelNames["cohuncpcalyline2channel"]))
		headkeys.append("pcaly_line2_coh")

# We also need excitation channels for computing kappas
if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq or (remove_cal_lines and "esd1" in act_line_removal_dict.keys()):
	channel_list.append((instrument, ChannelNames["tstexcchannel"]))
	headkeys.append("tstexc")
if compute_kappapum or (compute_kappauim and (compute_kappac or compute_fcc or compute_fs or compute_srcq)) or (remove_cal_lines and "pum1" in act_line_removal_dict.keys()):
	channel_list.append((instrument, ChannelNames["pumexcchannel"]))
	headkeys.append("pumexc")
if use_uim_line and (compute_kappauim or compute_kappapum and (compute_kappac or compute_fcc or compute_fs or compute_srcq)) or (remove_cal_lines and "uim1" in act_line_removal_dict.keys()):
	channel_list.append((instrument, ChannelNames["uimexcchannel"]))
	headkeys.append("uimexc")
if compute_kappapu or ((not use_uim_line or not (compute_kappapum or compute_kappauim)) and (compute_kappauim or compute_kappac or compute_fcc or compute_fs or compute_srcq)):
	channel_list.append((instrument, ChannelNames["darmexcchannel"]))
	headkeys.append("darmexc")

# We need the PCAL channel if we are computing \kappas or removing the calibration lines
if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq or remove_cal_lines:
	channel_list.append((instrument, ChannelNames["pcalchannel"]))
	headkeys.append("pcal")

# We also need DARM_ERR if we are computing the kappas
if (compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq) and CalibrationConfigs["calibrationmode"] == "Partial":
		channel_list.append((instrument, ChannelNames["darmerrchannel"]))
		headkeys.append("darm_err")

# For full calibration we need DARM_ERR and DARM_CTRL as our input channels
if CalibrationConfigs["calibrationmode"] == "Full":
	channel_list.extend(((instrument, ChannelNames["darmerrchannel"]), (instrument, ChannelNames["darmctrlchannel"])))
	headkeys.extend(("res", "ctrl"))
# For partial calibration we need DELTAL_TST, DELTAL_PUM, DELTAL_UIM, and DELTAL_RES
elif CalibrationConfigs["calibrationmode"] == "Partial":
	channel_list.extend(((instrument, ChannelNames["deltalreschannel"]), (instrument, ChannelNames["deltaltstchannel"]), (instrument, ChannelNames["deltalpumchannel"]), (instrument, ChannelNames["deltaluimchannel"])))
	headkeys.extend(("res", "tst", "pum", "uim"))

# If we are removing 60 Hz lines and harmonics, add the witness channel
if remove_power_lines:
	channel_list.append((instrument, ChannelNames["powerlineschannel"]))
	headkeys.append("powerlines")

# If we are using witness channels to clean h(t), add those to the channel list
if ChannelNames["witnesschannellist"] != "None":
	witness_channel_list = ChannelNames["witnesschannellist"].split(';')
	witness_notch_frequencies = DataCleaningConfigs["witnessnotchfrequencies"].split(';')
	witness_rates = SampleRates["witnesschannelsr"].split(';')
	if len(witness_channel_list) != len(witness_notch_frequencies) or len(witness_channel_list) != len(witness_rates):
		raise ValueError("WitnessChannelList, WitnessChannelSR, and WitnessNotchFrequencies must all be the same length, i.e, they must all have the same number of semicolons (;)")
	for i in range(0, len(witness_channel_list)):
		witness_channel_list[i] = witness_channel_list[i].split(',')
		for j in range(0, len(witness_channel_list[i])):
			channel_list.append((instrument, witness_channel_list[i][j]))
			headkeys.append(witness_channel_list[i][j])
		witness_rates[i] = int(witness_rates[i])
		witness_notch_frequencies[i] = witness_notch_frequencies[i].split(',')
		if len(witness_notch_frequencies[i]) <= 1:
			witness_notch_frequencies[i] = []
		else:
			for j in range(0, len(witness_notch_frequencies[i])):
				witness_notch_frequencies[i][j] = float(witness_notch_frequencies[i][j])
else:
	witness_channel_list = None


####################################################################################################
####################################### Main Pipeline ##############################################
####################################################################################################

pipeline = Gst.Pipeline(name="gstlal_compute_strain")
mainloop = GObject.MainLoop()
handler = simplehandler.Handler(mainloop, pipeline)

# 
# Turn off debugging tools or verboseness
#

pipeparts.mkchecktimestamps = lambda pipeline, src, *args: src # comment this line out to turn on the checktimestamps debugging
if not verbose:
	pipeparts.mkprogressreport = lambda pipeline, src, *args: src

#
# Read in data from frames or shared memory
#

if InputConfigs["datasource"] == "lvshm": # Data is to be read from shared memory; "low-latency" mode
	src = pipeparts.mklvshmsrc(pipeline, shm_name = InputConfigs["shmpartition"], assumed_duration = int(InputConfigs["inputframeduration"]))
elif InputConfigs["datasource"] == "frames": # Data is to be read from frame files; "offline" mode
	src = pipeparts.mklalcachesrc(pipeline, location = InputConfigs["framecache"], cache_dsc_regex = instrument)

if Config.getboolean("DebuggingConfigurations", "testlatency"):
	src = pipeparts.mkgeneric(pipeline, src, "splitcounter", filename = "gstlal_compute_strain_timestamps_in.txt")

#
# Hook up the relevant channels to the demuxer
#

demux = pipeparts.mkframecppchanneldemux(pipeline, src, do_file_checksum = file_check_sum, skip_bad_files = skip_bad_files, channel_list = map("%s:%s".__mod__, channel_list))

# Write the pipeline graph after pads have been hooked up to the demuxer
if DebuggingConfigs["pipelinegraphfilename"] != "None":
	demux.connect("no-more-pads", write_graph)	


# Get everything hooked up and fill in discontinuities
for key, chan in zip(headkeys, channel_list):
	head_dict[key] = calibration_parts.hook_up(pipeline, demux, chan[1], instrument, float(PipelineConfigs["bufferlength"]))

#
# TIME-VARYING FACTORS COMPUTATIONS
#

A_epics_dict = {}
D_epics_dict = {}
C_epics_dict = {}
misc_epics_dict = {}
for key in headkeys:
	if key.startswith("EP6_") or key.startswith("EP11_"):
		C_epics_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		C_epics_dict[key] = calibration_parts.mkresample(pipeline, C_epics_dict[key], 0, False, compute_calib_factors_caps)
		C_epics_dict[key] = (pipeparts.mktee(pipeline, C_epics_dict[key]), float(filters[key]))
	elif key.startswith("EP7_") or key.startswith("EP12_"):
		D_epics_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		D_epics_dict[key] = calibration_parts.mkresample(pipeline, D_epics_dict[key], 0, False, compute_calib_factors_caps)
		D_epics_dict[key] = (pipeparts.mktee(pipeline, D_epics_dict[key]), float(filters[key]))
	elif key.startswith("EP1_") or key.startswith("EP2_") or key.startswith("EP15_") or key.startswith("EP22_"):
		misc_epics_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		misc_epics_dict[key] = calibration_parts.mkresample(pipeline, misc_epics_dict[key], 0, False, compute_calib_factors_caps)
		misc_epics_dict[key] = (pipeparts.mktee(pipeline, misc_epics_dict[key]), float(filters[key]))
	elif key.startswith("EP"):
		A_epics_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		A_epics_dict[key] = calibration_parts.mkresample(pipeline, A_epics_dict[key], 0, False, compute_calib_factors_caps)
		A_epics_dict[key] = (pipeparts.mktee(pipeline, A_epics_dict[key]), float(filters[key]))

if use_coherence:
	if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		pcaly_line1_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line1_coh"], coh_caps, "pcaly_line1_coh")
		pcaly_line1_coh = calibration_parts.mkresample(pipeline, pcaly_line1_coh, 0, False, compute_calib_factors_caps)
		sus_coh = calibration_parts.caps_and_progress(pipeline, head_dict["sus_coh"], coh_caps, "sus_coh")
		sus_coh = calibration_parts.mkresample(pipeline, sus_coh, 0, False, compute_calib_factors_caps)
		darm_coh = calibration_parts.caps_and_progress(pipeline, head_dict["darm_coh"], coh_caps, "darm_coh")
		darm_coh = calibration_parts.mkresample(pipeline, darm_coh, 0, False, compute_calib_factors_caps)
		pcaly_line1_coh = pipeparts.mktee(pipeline, pcaly_line1_coh)
		sus_coh = pipeparts.mktee(pipeline, sus_coh)
		darm_coh = pipeparts.mktee(pipeline, darm_coh)
	if compute_kappac or compute_fcc or compute_fs or compute_srcq:
		pcaly_line2_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line2_coh"], coh_caps, "pcaly_line2_coh")
		pcaly_line2_coh = calibration_parts.mkresample(pipeline, pcaly_line2_coh, 0, False, compute_calib_factors_caps)
		pcaly_line2_coh = pipeparts.mktee(pipeline, pcaly_line2_coh)

if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq or (remove_cal_lines and "esd1" in act_line_removal_dict.keys()):
	tstexccaps = "audio/x-raw, format=F64LE, rate=%d" % tst_exc_sr
	tstexc = calibration_parts.caps_and_progress(pipeline, head_dict["tstexc"], tstexccaps, "tstexc")
	act_line_removal_dict["esd1"][0] = tstexc
if compute_kappapum or (compute_kappauim and (compute_kappac or compute_fcc or compute_fs or compute_srcq)) or (remove_cal_lines and "pum1" in act_line_removal_dict.keys()):
	pumexccaps = "audio/x-raw, format=F64LE, rate=%d" % pum_exc_sr
	pumexc = calibration_parts.caps_and_progress(pipeline, head_dict["pumexc"], pumexccaps, "pumexc")
	act_line_removal_dict["pum1"][0] = pumexc
if use_uim_line and (compute_kappauim or compute_kappapum and (compute_kappac or compute_fcc or compute_fs or compute_srcq)) or (remove_cal_lines and "uim1" in act_line_removal_dict.keys()):
	uimexccaps = "audio/x-raw, format=F64LE, rate=%d" % uim_exc_sr
	uimexc = calibration_parts.caps_and_progress(pipeline, head_dict["uimexc"], uimexccaps, "uimexc")
	act_line_removal_dict["uim1"][0] = uimexc

if compute_kappapu or ((not use_uim_line or not (compute_kappapum or compute_kappauim)) and (compute_kappauim or compute_kappac or compute_fcc or compute_fs or compute_srcq)):
	darmexc = calibration_parts.caps_and_progress(pipeline, head_dict["darmexc"], hoft_caps, "darmexc")

# Set up computations for kappa_tst, kappa_pum, kappa_uim, kappa_pu,kappa_c, f_cc, f_s, and Q, if applicable
if compute_kappac or compute_fcc or compute_kappatst or compute_kappapu or compute_srcq or compute_fs:

	# pcal excitation channel, which will be demodulated
	pcal = calibration_parts.caps_and_progress(pipeline, head_dict["pcal"], hoft_caps, "pcal")
	pcaltee = pipeparts.mktee(pipeline, pcal)
	for pcal_line_name in pcal_line_removal_dict.keys():
		pcal_line_removal_dict[pcal_line_name][0] = pcaltee

	# DARM_ERR channel, which will have followed different paths if we're doing full vs. partial calibration
	if CalibrationConfigs["calibrationmode"] == "Full":
		darm_err = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "darm_err")
	else:
		darm_err = calibration_parts.caps_and_progress(pipeline, head_dict["darm_err"], hoft_caps, "darm_err")
	derrtee = pipeparts.mktee(pipeline, darm_err)

	# demodulate the PCAL channel and apply the PCAL correction factor at the DARM actuation line frequency
	pcal_at_act_pcal_freq = calibration_parts.demodulate(pipeline, pcaltee, act_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, prefactor_real = pcal_corr_at_act_freq_real, prefactor_imag = pcal_corr_at_act_freq_imag)
	pcal_at_act_pcal_freq = pipeparts.mktee(pipeline, pcal_at_act_pcal_freq)
	if remove_cal_lines:
		# This will save having to demodulate it again
		pcal_line_removal_dict["pcal1"][0] = pcal_at_act_pcal_freq
		pcal_line_removal_dict["pcal1"][4] = True

	# demodulate DARM_ERR at the ~30 Hz pcal line frequency
	derr_at_act_pcal_freq = calibration_parts.demodulate(pipeline, derrtee, act_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
	if dewhitening:
		# dewhiten DARM_ERR at the ~30 Hz pcal line frequency
		derr_at_act_pcal_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_act_pcal_freq, derr_dewhiten_at_darm_act_freq_real, derr_dewhiten_at_darm_act_freq_imag)
	derr_at_act_pcal_freq = pipeparts.mktee(pipeline, derr_at_act_pcal_freq)

	# demodulate the TST excitation channel at the ESD actuation line frequency
	tstexc_at_esd_act_freq = calibration_parts.demodulate(pipeline, tstexc, esd_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
	if "esd1" in act_line_removal_dict.keys():
		tstexc_at_esd_act_freq = pipeparts.mktee(pipeline, tstexc_at_esd_act_freq)
		act_line_removal_dict["esd1"][0] = tstexc_at_esd_act_freq
		act_line_removal_dict["esd1"][4] = True

	# demodulate DARM_ERR at the ESD actuation line frequency
	derr_at_esd_act_freq = calibration_parts.demodulate(pipeline, derrtee, esd_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
	if dewhitening:
		# dewhiten DARM_ERR at the ESD actuation line frequency
		derr_at_esd_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_esd_act_freq, derr_dewhiten_at_esd_act_freq_real, derr_dewhiten_at_esd_act_freq_imag)

	# compute kappa_tst, either using reference factors from the filters file or reading them from EPICS channels
	if not factors_from_filters_file:
		EP1 = calibration_parts.merge_into_complex(pipeline, misc_epics_dict["EP1_real"][0], misc_epics_dict["EP1_imag"][0])
		ktst = calibration_parts.compute_kappatst(pipeline, derr_at_esd_act_freq, tstexc_at_esd_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP1)
	elif factors_from_filters_file:
		ktst = calibration_parts.compute_kappatst_from_filters_file(pipeline, derr_at_esd_act_freq, tstexc_at_esd_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP1_real, EP1_imag)

	ktst = pipeparts.mktee(pipeline, ktst)

	# Now apply the gating and smoothing to \kappa_tst
	if compute_kappatst:
		smooth_ktst_nogate = pipeparts.mkgeneric(pipeline, ktst, "lal_smoothkappas", default_kappa_re = expected_kappatst_real, default_kappa_im = expected_kappatst_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)
		smooth_ktstR_nogate, smooth_ktstI_nogate = calibration_parts.split_into_real(pipeline, smooth_ktst_nogate)

		if use_coherence:
			# Gate kappa_tst with the coherence of the PCALY_line1 line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_tst with the coherence of the suspension line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_tst with the coherence of the DARM line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

			# Smooth kappa_tst
			smooth_ktst = calibration_parts.smooth_complex_kappas(pipeline, ktst_gated, expected_kappatst_real, expected_kappatst_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		else:
			# Smooth kappa_tst
			smooth_ktst = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, ktst, kappatst_real_var, kappatst_imag_var, expected_kappatst_real, expected_kappatst_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		smooth_ktsttee = pipeparts.mktee(pipeline, smooth_ktst)
		smooth_ktstR, smooth_ktstI = calibration_parts.split_into_real(pipeline, smooth_ktsttee)

		smooth_ktstRtee = pipeparts.mktee(pipeline, smooth_ktstR)
		smooth_ktstItee = pipeparts.mktee(pipeline, smooth_ktstI)

		if "esd1" in act_line_removal_dict.keys():
			if apply_complex_kappatst:
				act_line_removal_dict["esd1"][7] = smooth_ktsttee
			elif apply_kappatst:
				act_line_removal_dict["esd1"][7] = smooth_ktstRtee

# Check if we need to compute kappa_pum
if compute_kappapum or compute_kappauim and (not use_uim_line or compute_kappac or compute_fcc or compute_fs or compute_srcq):
	# demodulate the PUM excitation channel at the PUM actuation line frequency
	pumexc_at_pum_act_freq = calibration_parts.demodulate(pipeline, pumexc, pum_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
	pumexc_at_pum_act_freq = pipeparts.mktee(pipeline, pumexc_at_pum_act_freq)
	act_line_removal_dict["pum1"][0] = pumexc_at_pum_act_freq
	act_line_removal_dict["pum1"][4] = True

	# demodulate DARM_ERR at the PUM actuation line frequency
	derr_at_pum_act_freq = calibration_parts.demodulate(pipeline, derrtee, pum_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)

	# Compute kappa_pum, either using reference factors from the filters file or reading them from EPICS channels
	if not factors_from_filters_file:
		EP15 = calibration_parts.merge_into_complex(pipeline, misc_epics_dict["EP15_real"][0], misc_epics_dict["EP15_imag"][0])
		kpum = calibration_parts.compute_kappapum(pipeline, derr_at_pum_act_freq, pumexc_at_pum_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP15)
	else:
		kpum = calibration_parts.compute_kappapum_from_filters_file(pipeline, derr_at_pum_act_freq, pumexc_at_pum_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP15_real, EP15_imag)

	kpum = pipeparts.mktee(pipeline, kpum)

	# Now apply the gating and smoothing to kappa_pum
	if compute_kappapum:
		smooth_kpum_nogate = pipeparts.mkgeneric(pipeline, kpum, "lal_smoothkappas", default_kappa_re = expected_kappapum_real, default_kappa_im = expected_kappapum_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)
		smooth_kpumR_nogate, smooth_kpumI_nogate = calibration_parts.split_into_real(pipeline, smooth_kpum_nogate)

		if use_coherence:
			# Gate kappa_pum with the coherence of the PCALY_line1 line
			kpum_gated = calibration_parts.mkgate(pipeline, kpum, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_pum with the coherence of the suspension line
			kpum_gated = calibration_parts.mkgate(pipeline, kpum_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_pum with the coherence of the DARM line
			kpum_gated = calibration_parts.mkgate(pipeline, kpum_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

			# Smooth kappa_pum
			smooth_kpum = calibration_parts.smooth_complex_kappas(pipeline, kpum_gated, expected_kappapum_real, expected_kappapum_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		else:
			# Smooth kappa_pum
			smooth_kpum = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, kpum, kappapum_real_var, kappapum_imag_var, expected_kappapum_real, expected_kappapum_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		smooth_kpumtee = pipeparts.mktee(pipeline, smooth_kpum)
		smooth_kpumR, smooth_kpumI = calibration_parts.split_into_real(pipeline, smooth_kpumtee)

		smooth_kpumRtee = pipeparts.mktee(pipeline, smooth_kpumR)
		smooth_kpumItee = pipeparts.mktee(pipeline, smooth_kpumI)

		if "pum1" in act_line_removal_dict.keys():
			if apply_complex_kappapum:
				act_line_removal_dict["pum1"][7] = smooth_kpumtee
			elif apply_kappapum:
				act_line_removal_dict["pum1"][7] = smooth_kpumRtee

# Check if we need to compute kappa_uim
if compute_kappauim or (compute_kappapum and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
	if use_uim_line:
		# Demodulate DARM_ERR and the UIM excitation channel at the UIM actuation line frequency
		derr_at_uim_act_freq = calibration_parts.demodulate(pipeline, derrtee, uim_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
		uimexc_at_uim_act_freq = calibration_parts.demodulate(pipeline, uimexc, uim_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
		uimexc_at_uim_act_freq = pipeparts.mktee(pipeline, uimexc_at_uim_act_freq)
		act_line_removal_dict["uim1"][0] = uimexc_at_uim_act_freq
		act_line_removal_dict["uim1"][4] = True

		# Compute kappa_uim, either using reference factors from the filters file or reading them from EPICS channels
		if not factors_from_filters_file:
			EP22 = calibration_parts.merge_into_complex(pipeline, misc_epics_dict["EP22_real"][0], misc_epics_dict["EP22_imag"][0])
			kuim = calibration_parts.compute_kappauim_uim_line(pipeline, derr_at_uim_act_freq, uimexc_at_uim_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP22)
		else:
			kuim = calibration_parts.compute_kappauim_from_filters_file_uim_line(pipeline, derr_at_uim_act_freq, uimexc_at_uim_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP22_real, EP22_imag)

	else:
		# Demodulate DARM_ERR and the darm excitation channel at the darm actuation line frequency
		derr_at_darm_act_freq = calibration_parts.demodulate(pipeline, derrtee, darm_ctrl_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
		darmexc_at_darm_act_freq = calibration_parts.demodulate(pipeline, darmexc, darm_ctrl_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
		if compute_kappapu:
			derr_at_darm_act_freq = pipeparts.mktee(pipeline, derr_at_darm_act_freq)
			darmexc_at_darm_act_freq = pipeparts.mktee(pipeline, darmexc_at_darm_act_freq)

		# Compute the factor A(fctrl) that will be used in the computation of kappa_uim, either using reference factors from the filters file or reading them from EPICS channels
		if not factors_from_filters_file:
			EP2 = calibration_parts.merge_into_complex(pipeline, misc_epics_dict["EP2_real"][0], misc_epics_dict["EP2_imag"][0])
			EP4 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP4_real"][0], A_epics_dict["EP4_imag"][0])
			EP16 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP16_real"][0], A_epics_dict["EP16_imag"][0])
			EP17 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP17_real"][0], A_epics_dict["EP17_imag"][0])
			afctrl = calibration_parts.compute_afctrl(pipeline, derr_at_darm_act_freq, darmexc_at_darm_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP2)
			kuim = calibration_parts.compute_kappauim(pipeline, EP16, afctrl, ktst, EP4, kpum, EP17)
		else:
			afctrl = calibration_parts.compute_afctrl_from_filters_file(pipeline, derr_at_darm_act_freq, darmexc_at_darm_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP2_real, EP2_imag)
			kuim = calibration_parts.compute_kappauim_from_filters_file(pipeline, EP16_real, EP16_imag, afctrl, ktst, EP4_real, EP4_imag, kpum, EP17_real, EP17_imag)

	kuim = pipeparts.mktee(pipeline, kuim)

	# Now apply the gating and smoothing to kappa_uim
	if compute_kappauim:
		smooth_kuim_nogate = pipeparts.mkgeneric(pipeline, kuim, "lal_smoothkappas", default_kappa_re = expected_kappauim_real, default_kappa_im = expected_kappauim_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)
		smooth_kuimR_nogate, smooth_kuimI_nogate = calibration_parts.split_into_real(pipeline, smooth_kuim_nogate)

		if use_coherence:
			# Gate kappa_uim with the coherence of the PCALY_line1 line
			kuim_gated = calibration_parts.mkgate(pipeline, kuim, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_uim with the coherence of the suspension line
			kuim_gated = calibration_parts.mkgate(pipeline, kuim_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_uim with the coherence of the DARM line
			kuim_gated = calibration_parts.mkgate(pipeline, kuim_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

			# Smooth kappa_uim
			smooth_kuim = calibration_parts.smooth_complex_kappas(pipeline, kuim_gated, expected_kappauim_real, expected_kappauim_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		else:
			# Smooth kappa_uim
			smooth_kuim = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, kuim, kappauim_real_var, kappauim_imag_var, expected_kappauim_real, expected_kappauim_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		smooth_kuimtee = pipeparts.mktee(pipeline, smooth_kuim)
		smooth_kuimR, smooth_kuimI = calibration_parts.split_into_real(pipeline, smooth_kuimtee)

		smooth_kuimRtee = pipeparts.mktee(pipeline, smooth_kuimR)
		smooth_kuimItee = pipeparts.mktee(pipeline, smooth_kuimI)

		if "uim1" in act_line_removal_dict.keys():
			if apply_complex_kappauim:
				act_line_removal_dict["uim1"][7] = smooth_kuimtee
			elif apply_kappauim:
				act_line_removal_dict["uim1"][7] = smooth_kuimRtee

# Check if we need to compute kappa_PU
if compute_kappapu or (compute_kappac or compute_fcc or compute_fs or compute_srcq) and not (compute_kappapum or compute_kappauim):
	if use_uim_line or not (compute_kappauim or (compute_kappapum and (compute_kappac or compute_fcc or compute_fs or compute_srcq))):
		# demodulate excitation channel at darm actuation line frequency
		darmexc_at_darm_act_freq = calibration_parts.demodulate(pipeline, darmexc, darm_ctrl_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)

		# demodulate DARM_ERR at the darm actuation line frequency
		derr_at_darm_act_freq = calibration_parts.demodulate(pipeline, derrtee, darm_ctrl_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
	if dewhitening:
		# dewhiten DARM_ERR at the darm actuation line frequency
		derr_at_darm_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_darm_act_freq, derr_dewhiten_at_pu_act_freq_real, derr_dewhiten_at_pu_act_freq_imag)

	# compute the factor A(fctrl) that will be used in the computation of kappa_pu, either using reference factors from the filters file or reading them from EPICS channels
	if not factors_from_filters_file:
		EP2 = calibration_parts.merge_into_complex(pipeline, misc_epics_dict["EP2_real"][0], misc_epics_dict["EP2_imag"][0])
		EP3 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP3_real"][0], A_epics_dict["EP3_imag"][0])
		EP4 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP4_real"][0], A_epics_dict["EP4_imag"][0])
		afctrl = calibration_parts.compute_afctrl(pipeline, derr_at_darm_act_freq, darmexc_at_darm_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP2)
		kpu = calibration_parts.compute_kappapu(pipeline, EP3, afctrl, ktst, EP4)
	else:
		afctrl = calibration_parts.compute_afctrl_from_filters_file(pipeline, derr_at_darm_act_freq, darmexc_at_darm_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP2_real, EP2_imag)
		kpu = calibration_parts.compute_kappapu_from_filters_file(pipeline, EP3_real, EP3_imag, afctrl, ktst, EP4_real, EP4_imag)

	kpu = pipeparts.mktee(pipeline, kpu)

	# Now apply the gating and smoothing to \kappa_pu
	if compute_kappapu:
		smooth_kpu_nogate = pipeparts.mkgeneric(pipeline, kpu, "lal_smoothkappas", default_kappa_re = expected_kappapu_real, default_kappa_im = expected_kappapu_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)
		smooth_kpuR_nogate, smooth_kpuI_nogate = calibration_parts.split_into_real(pipeline, smooth_kpu_nogate)

		if use_coherence:
			# Gate kappa_pu with the coherence of the DARM line
			kpu_gated = calibration_parts.mkgate(pipeline, kpu, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_pu with the coherence of the PCALY_line1 line
			kpu_gated = calibration_parts.mkgate(pipeline, kpu_gated, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_pu with the coherence of the suspension coherence
			kpu_gated = calibration_parts.mkgate(pipeline, kpu_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Smooth kappa_pu
			smooth_kpu = calibration_parts.smooth_complex_kappas(pipeline, kpu_gated, expected_kappapu_real, expected_kappapu_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		else:
			# Smooth kappa_pu
			smooth_kpu = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, kpu, kappapu_real_var, kappapu_imag_var, expected_kappapu_real, expected_kappapu_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		smooth_kputee = pipeparts.mktee(pipeline, smooth_kpu)
		smooth_kpuR, smooth_kpuI = calibration_parts.split_into_real(pipeline, smooth_kputee)

		smooth_kpuRtee = pipeparts.mktee(pipeline, smooth_kpuR)
		smooth_kpuItee = pipeparts.mktee(pipeline, smooth_kpuI)	

# Compute \kappa_c and f_cc
if compute_kappac or compute_fcc or compute_fs or compute_srcq:
	# demodulate the PCAL channel and apply the PCAL correction factor at optical gain and f_cc line frequency
	pcal_at_opt_gain_freq = calibration_parts.demodulate(pipeline, pcaltee, opt_gain_fcc_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, prefactor_real = pcal_corr_at_opt_gain_fcc_freq_real, prefactor_imag = pcal_corr_at_opt_gain_fcc_freq_imag)
	if remove_cal_lines:
		# This will save having to demodulate it again
		pcal_at_opt_gain_freq = pipeparts.mktee(pipeline, pcal_at_opt_gain_freq)
		pcal_line_removal_dict["pcal2"][0] = pcal_at_opt_gain_freq
		pcal_line_removal_dict["pcal2"][4] = True

	# demodulate DARM_ERR at optical gain and f_cc line frequency
	derr_at_opt_gain_freq = calibration_parts.demodulate(pipeline, derrtee, opt_gain_fcc_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
	if dewhitening:
		# dewhiten DARM_ERR at optical gain and f_cc line frequency
		derr_at_opt_gain_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_opt_gain_freq, derr_dewhiten_at_opt_gain_fcc_freq_real, derr_dewhiten_at_opt_gain_fcc_freq_imag)

	# Compute the factor S which will be used for the kappa_c and f_cc calculations
	# Tha actuation kappas need to be evaluated at the higher pcal line frequency
	ktst_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, ktst, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / esd_act_line_freq)
	if not factors_from_filters_file:
		EP6 = calibration_parts.merge_into_complex(pipeline, C_epics_dict["EP6_real"][0], C_epics_dict["EP6_imag"][0])
		EP7 = calibration_parts.merge_into_complex(pipeline, D_epics_dict["EP7_real"][0], D_epics_dict["EP7_imag"][0])
		EP8 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP8_real"][0], A_epics_dict["EP8_imag"][0])
		if compute_kappapum or compute_kappauim:
			kpum_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kpum, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / pum_act_line_freq)
			kuim_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kuim, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / (uim_act_line_freq if use_uim_line else darm_ctrl_line_freq))
			EP18 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP18_real"][0], A_epics_dict["EP18_imag"][0])
			EP19 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP19_real"][0], A_epics_dict["EP19_imag"][0])
			S = calibration_parts.compute_S_split_act(pipeline, EP6, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7, ktst_at_opt_gain_freq, EP8, kpum_at_opt_gain_freq, EP18, kuim_at_opt_gain_freq, EP19)
		else:
			kpu_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kpu, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / darm_ctrl_line_freq)
			EP9 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP9_real"][0], A_epics_dict["EP9_imag"][0])
			S = calibration_parts.compute_S(pipeline, EP6, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7, ktst_at_opt_gain_freq, EP8, kpu_at_opt_gain_freq, EP9)

	elif factors_from_filters_file:
		if compute_kappapum or compute_kappauim:
			kpum_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kpum, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / pum_act_line_freq)
			kuim_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kuim, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / (uim_act_line_freq if use_uim_line else darm_ctrl_line_freq))
			S = calibration_parts.compute_S_from_filters_file_split_act(pipeline, EP6_real, EP6_imag, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7_real, EP7_imag, ktst_at_opt_gain_freq, EP8_real, EP8_imag, kpum_at_opt_gain_freq, EP18_real, EP18_imag, kuim_at_opt_gain_freq, EP19_real, EP19_imag)
		else:
			kpu_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kpu, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / darm_ctrl_line_freq)
			S = calibration_parts.compute_S_from_filters_file(pipeline, EP6_real, EP6_imag, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7_real, EP7_imag, ktst_at_opt_gain_freq, EP8_real, EP8_imag, kpu_at_opt_gain_freq, EP9_real, EP9_imag)

	S = pipeparts.mktee(pipeline, S)

	SR, SI = calibration_parts.split_into_real(pipeline, S)

	if compute_kappac and compute_fcc:
		SR = pipeparts.mktee(pipeline, SR)
		SI = pipeparts.mktee(pipeline, SI)

	# compute kappa_c
	if compute_kappac or compute_srcq or compute_fs:
		kc = calibration_parts.compute_kappac(pipeline, SR, SI)
	if compute_kappac:
		kc = pipeparts.mktee(pipeline, kc)
		smooth_kc_nogate = pipeparts.mkgeneric(pipeline, kc, "lal_smoothkappas", default_kappa_re = expected_kappac, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)

		if use_coherence:
			# Gate kappa_c with the coherence of all four of the calibration lines
			kc_gated = calibration_parts.mkgate(pipeline, kc, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			kc_gated = calibration_parts.mkgate(pipeline, kc_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			kc_gated = calibration_parts.mkgate(pipeline, kc_gated, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			kc_gated = calibration_parts.mkgate(pipeline, kc_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

			# Smooth kappa_c
			smooth_kc = calibration_parts.smooth_kappas(pipeline, kc_gated, expected_kappac, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		else:
			# Smooth kappa_c
			smooth_kc = calibration_parts.smooth_kappas_no_coherence(pipeline, kc, kappac_var, expected_kappac, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		smooth_kctee = pipeparts.mktee(pipeline, smooth_kc)

	# compute f_cc
	if compute_fcc or compute_srcq or compute_fs:
		fcc = calibration_parts.compute_fcc(pipeline, SR, SI, opt_gain_fcc_line_freq)
	if compute_fcc:
		fcc = pipeparts.mktee(pipeline, fcc)
		smooth_fcc_nogate = pipeparts.mkgeneric(pipeline, fcc, "lal_smoothkappas", default_kappa_re = fcc_default, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)

		if use_coherence:
			# Gate f_cc with all four of the calibration lines
			fcc_gated = calibration_parts.mkgate(pipeline, fcc, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

			# Smooth f_cc
			smooth_fcc = calibration_parts.smooth_kappas(pipeline, fcc_gated, fcc_default, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)
		else:
			# Smooth f_cc
			smooth_fcc = calibration_parts.smooth_kappas_no_coherence(pipeline, fcc, fcc_var, fcc_default, median_smoothing_samples, factors_average_samples, kappas_default_to_median, filter_latency_factor)

		smooth_fcctee = pipeparts.mktee(pipeline, smooth_fcc)

#		if apply_fcc:
#			update_fcc = pipeparts.mkgeneric(pipeline, smooth_fcctee, "lal_fcc_update", data_rate = hoft_sr, fcc_rate = compute_factors_sr, fcc_model = fcc_default, averaging_time = float(TDCFConfigs["fccaveragingtime"]), filter_duration = float(TDCFConfigs["fccfilterduration"]))
#			pipeparts.mkfakesink(pipeline, update_fcc)

# compute f_s and Q
if compute_fs or compute_srcq:
	expected_Xi = complex((fs_default * fs_default - 1j * src_pcal_line_freq * fs_default / srcQ_default) / (src_pcal_line_freq * src_pcal_line_freq))
	Xi_real_var = float((pow(fs_default + fs_var, 2) - pow(fs_default, 2.0)) / pow(src_pcal_line_freq, 2))
	Xi_imag_var = float(fs_var / (srcQ_default * src_pcal_line_freq))

	# demodulate PCAL channel and apply the PCAL correction factor at SRC detuning line frequency
	if src_pcal_line_freq == act_pcal_line_freq:
		pcal_at_src_freq = pcal_at_act_pcal_freq
	else:
		pcal_at_src_freq = calibration_parts.demodulate(pipeline, pcaltee, src_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, prefactor_real = pcal_corr_at_src_freq_real, prefactor_imag = pcal_corr_at_src_freq_imag)
		pcal_at_src_freq = pipeparts.mktee(pipeline, pcal_at_src_freq)
	if "pcal4" in pcal_line_removal_dict:
		# This will save having to demodulate it again
		pcal_line_removal_dict["pcal4"][0] = pcal_at_src_freq
		pcal_line_removal_dict["pcal4"][4] = True

	# demodulate DARM_ERR at SRC detuning line frequency
	if src_pcal_line_freq == act_pcal_line_freq:
		derr_at_src_freq = derr_at_act_pcal_freq
	else:
		derr_at_src_freq = calibration_parts.demodulate(pipeline, derrtee, src_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)

	# Compute the factor Xi which will be used for the f_s and src_Q calculations
	# The actuation kappas need to be evaluated at the SRC pcal line frequency
	ktst_at_src_freq = pipeparts.mkgeneric(pipeline, ktst, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / esd_act_line_freq)
	if not factors_from_filters_file:
		EP11 = calibration_parts.merge_into_complex(pipeline, C_epics_dict["EP11_real"][0], C_epics_dict["EP11_imag"][0])
		EP12 = calibration_parts.merge_into_complex(pipeline, D_epics_dict["EP12_real"][0], D_epics_dict["EP12_imag"][0])
		EP13 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP13_real"][0], A_epics_dict["EP13_imag"][0])
		if compute_kappapum or compute_kappauim:
			kpum_at_src_freq = pipeparts.mkgeneric(pipeline, kpum, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / pum_act_line_freq)
			kuim_at_src_freq = pipeparts.mkgeneric(pipeline, kuim, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / (uim_act_line_freq if use_uim_line else darm_ctrl_line_freq))
			EP20 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP20_real"][0], A_epics_dict["EP20_imag"][0])
			EP21 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP21_real"][0], A_epics_dict["EP21_imag"][0])
			Xi = calibration_parts.compute_Xi_split_act(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11, EP12, EP13, EP20, EP21, ktst_at_src_freq, kpum_at_src_freq, kuim_at_src_freq, kc, fcc)
		else:
			kpu_at_src_freq = pipeparts.mkgeneric(pipeline, kpu, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / darm_ctrl_line_freq)
			EP14 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP14_real"][0], A_epics_dict["EP14_imag"][0])
			Xi = calibration_parts.compute_Xi(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11, EP12, EP13, EP14, ktst_at_src_freq, kpu_at_src_freq, kc, fcc)
	else:
		if compute_kappapum or compute_kappauim:
			kpum_at_src_freq = pipeparts.mkgeneric(pipeline, kpum, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / pum_act_line_freq)
			kuim_at_src_freq = pipeparts.mkgeneric(pipeline, kuim, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / (uim_act_line_freq if use_uim_line else darm_ctrl_line_freq))
			Xi = calibration_parts.compute_Xi_from_filters_file_split_act(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11_real, EP11_imag, EP12_real, EP12_imag, EP13_real, EP13_imag, EP20_real, EP20_imag, EP21_real, EP21_imag, ktst_at_src_freq, kpum_at_src_freq, kuim_at_src_freq, kc, fcc)
		else:
			kpu_at_src_freq = pipeparts.mkgeneric(pipeline, kpu, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / darm_ctrl_line_freq)
			Xi = calibration_parts.compute_Xi_from_filters_file(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11_real, EP11_imag, EP12_real, EP12_imag, EP13_real, EP13_imag, EP14_real, EP14_imag, ktst_at_src_freq, kpu_at_src_freq, kc, fcc)

	Xi = pipeparts.mktee(pipeline, Xi)
	smooth_Xi_nogate = pipeparts.mkgeneric(pipeline, Xi, "lal_smoothkappas", default_kappa_re = float(numpy.real(expected_Xi)), default_kappa_im = float(numpy.imag(expected_Xi)), array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)

	if use_coherence:
		# Gate Xi with all coherences. We apply the gating and smoothing here since Q depends on the inverse of Im(Xi), which fluctuates about zero.
		Xi_gated = calibration_parts.mkgate(pipeline, Xi, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, sus_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

		smooth_Xi = calibration_parts.smooth_complex_kappas(pipeline, Xi_gated, float(numpy.real(expected_Xi)), float(numpy.imag(expected_Xi)), median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	else:
		smooth_Xi = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, Xi, Xi_real_var, Xi_real_var, float(numpy.real(expected_Xi)), float(numpy.imag(expected_Xi)), median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	if not compute_srcq:
		# the imaginary part is only used to compute Q
		smooth_XiR = pipeparts.mkgeneric(pipeline, smooth_Xi, "creal")
		smooth_XiR_nogate = pipeparts.mkgeneric(pipeline, smooth_Xi_nogate, "creal")
	else:
		smooth_XiR, smooth_XiI = calibration_parts.split_into_real(pipeline, smooth_Xi)
		smooth_XiR_nogate, smooth_XiI_nogate = calibration_parts.split_into_real(pipeline, smooth_Xi_nogate)

	smooth_sqrtXiR = calibration_parts.mkpow(pipeline, smooth_XiR, exponent = 0.5)
	smooth_sqrtXiR_nogate = calibration_parts.mkpow(pipeline, smooth_XiR_nogate, exponent = 0.5)

	if compute_fs and compute_srcq:
		smooth_sqrtXiR = pipeparts.mktee(pipeline, smooth_sqrtXiR)
		smooth_sqrtXiR_nogate = pipeparts.mktee(pipeline, smooth_sqrtXiR_nogate)

	# compute f_s
	if compute_fs:
		smooth_fs = pipeparts.mkaudioamplify(pipeline, smooth_sqrtXiR, src_pcal_line_freq)
		smooth_fs_nogate = pipeparts.mkaudioamplify(pipeline, smooth_sqrtXiR_nogate, src_pcal_line_freq)

		if compute_calib_statevector or apply_fs:
			smooth_fs = pipeparts.mktee(pipeline, smooth_fs)

	# compute SRC Q_inv
	if compute_srcq:
		smooth_sqrtXiR_inv = calibration_parts.mkpow(pipeline, smooth_sqrtXiR, exponent = -1.0)
		smooth_sqrtXiR_inv_nogate = calibration_parts.mkpow(pipeline, smooth_sqrtXiR_nogate, exponent = -1.0)
		smooth_srcQ_inv = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, smooth_sqrtXiR_inv, pipeparts.mkaudioamplify(pipeline, smooth_XiI, -1.0)))
		smooth_srcQ_inv_nogate = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, smooth_sqrtXiR_inv_nogate, pipeparts.mkaudioamplify(pipeline, smooth_XiI_nogate, -1.0)))

		# We don't want to correct for Q < 0, since this is nonphysical and such a correction would most likely have the wrong frequency-dependence.
		if apply_srcq:
			smooth_srcQ_inv = pipeparts.mkgeneric(pipeline, smooth_srcQ_inv, "lal_insertgap", bad_data_intervals = [1e-35, 1e35], replace_value = 1e-35, insert_gap = False)

		if compute_calib_statevector or apply_srcq:
			smooth_srcQ_inv = pipeparts.mktee(pipeline, smooth_srcQ_inv)

#
# TIME-VARYING FACTORS COMPENSATIONS
#

if apply_complex_kappatst:
	# We will apply an adaptive FIR filter to the TST component of the actuation that includes time-dependence in the gain and computational time delay
	adaptive_tst_filter = pipeparts.mkgeneric(pipeline, smooth_ktsttee, "lal_adaptivefirfilt", update_samples = int(actuation_filter_update_time * compute_factors_sr), average_samples = int(actuation_filter_averaging_time * compute_factors_sr), phase_measurement_frequency = esd_act_line_freq, static_filter = tstfilt, variable_filter_length = len(tstfilt), adaptive_filter_length = len(tstfilt), tukey_param = 0.5, filter_sample_rate = tstchainsr)

if apply_complex_kappapum:
	# We will apply an adaptive FIR filter to the PUM component of the actuation that includes time-dependence in the gain and computational time delay
	adaptive_pum_filter = pipeparts.mkgeneric(pipeline, smooth_kpumtee, "lal_adaptivefirfilt", update_samples = int(actuation_filter_update_time * compute_factors_sr), average_samples = int(actuation_filter_averaging_time * compute_factors_sr), phase_measurement_frequency = esd_act_line_freq, static_filter = pumfilt, variable_filter_length = len(pumfilt), adaptive_filter_length = len(pumfilt), tukey_param = 0.5, filter_sample_rate = pumchainsr)

if apply_complex_kappauim:
	# We will apply an adaptive FIR filter to the UIM component of the actuation that includes time-dependence in the gain and computational time delay
	adaptive_uim_filter = pipeparts.mkgeneric(pipeline, smooth_kuimtee, "lal_adaptivefirfilt", update_samples = int(actuation_filter_update_time * compute_factors_sr), average_samples = int(actuation_filter_averaging_time * compute_factors_sr), phase_measurement_frequency = esd_act_line_freq, static_filter = uimfilt, variable_filter_length = len(uimfilt), adaptive_filter_length = len(uimfilt), tukey_param = 0.5, filter_sample_rate = uimchainsr)

if apply_complex_kappapu:
	# We will apply an adaptive FIR filter to the PUM/UIM component of the actuation that includes time-dependence in the gain and computational time delay
	adaptive_pumuim_filter = pipeparts.mkgeneric(pipeline, smooth_kputee, "lal_adaptivefirfilt", update_samples = int(actuation_filter_update_time * compute_factors_sr), average_samples = int(actuation_filter_averaging_time * compute_factors_sr), phase_measurement_frequency = darm_ctrl_line_freq, static_filter = pumuimfilt, variable_filter_length = len(pumuimfilt), adaptive_filter_length = len(pumuimfilt), tukey_param = 0.5, filter_sample_rate = pumuimchainsr)

if apply_fcc or apply_fs or apply_srcq:
	# We will apply an adaptive FIR filter to DARM_ERR that allows corrections for poles, zeros, and gain
	# We need to track the number of time-dependent and static zeros and poles in the adaptive filter
	variable_invsens_zeros = 0
	static_invsens_poles = []
	tdep_zpk = []
	if apply_fcc:
		variable_invsens_zeros += 1
		# The real part of the pole is 0.0, and fcc_default is the imaginary part
		static_invsens_poles.extend([fcc_default, 0.0])

		# (1 + i * f / f_cc) is a zero in the variable inverse sensing filter
		complex_fcc = pipeparts.mkmatrixmixer(pipeline, smooth_fcctee, matrix = [[1.0, 0.0]])
		complex_fcc = pipeparts.mktogglecomplex(pipeline, complex_fcc)

		tdep_zpk.append(complex_fcc)

	# There are two zeros that depend on fs and Q, both of which depend on both fs and Q
	if apply_fs or apply_srcq:
		variable_invsens_zeros += 2
		static_invsens_poles.extend([(fs_default / 2.0) * (pow(srcQ_default, -1.0) + pow(pow(srcQ_default, -2.0) + 4.0, 0.5)), 0.0])
		static_invsens_poles.extend([(fs_default / 2.0) * (pow(srcQ_default, -1.0) - pow(pow(srcQ_default, -2.0) + 4.0, 0.5)), 0.0])

	if apply_fs and apply_srcq:
		# The variable zeros depend on the computed values of fs and Q
		Q_inv_squared = calibration_parts.mkpow(pipeline, smooth_srcQ_inv, exponent = 2.0)
		sqrt_Q_inv_squared_plus4 = calibration_parts.mkpow(pipeline, pipeparts.mkgeneric(pipeline, Q_inv_squared, "lal_add_constant", value = 4.0), exponent = 0.5)
		sqrt_Q_inv_squared_plus4 = pipeparts.mktee(pipeline, sqrt_Q_inv_squared_plus4)

		SRC_zero1 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, sqrt_Q_inv_squared_plus4))
		SRC_zero1 = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, SRC_zero1, smooth_fs))
		SRC_zero1 = pipeparts.mkmatrixmixer(pipeline, SRC_zero1, matrix = [[0.5, 0.0]])
		SRC_zero1 = pipeparts.mktogglecomplex(pipeline, SRC_zero1)

		SRC_zero2 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, pipeparts.mkaudioamplify(pipeline, sqrt_Q_inv_squared_plus4, -1.0)))
		SRC_zero2 = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, SRC_zero2, smooth_fs))
		SRC_zero2 = pipeparts.mkmatrixmixer(pipeline, SRC_zero2, matrix = [[0.5, 0.0]])
		SRC_zero2 = pipeparts.mktogglecomplex(pipeline, SRC_zero2)

		tdep_zpk.extend([SRC_zero1, SRC_zero2])

		# This will be added into tdep_zpk at the end, as required by lal_adaptivefirfilt
		variable_invsens_gain = pipeparts.mkaudioamplify(pipeline, calibration_parts.mkpow(pipeline, smooth_fs, exponent = 2.0), pow(fs_default, -2.0))

	elif apply_fs:
		# The variable zeros depend on the computed value of fs and the model value of Q
		Q_factor1 = (pow(srcQ_default, -1.0) + pow(pow(srcQ_default, -2.0) + 4.0, 0.5)) / 2.0
		Q_factor2 = (pow(srcQ_default, -1.0) - pow(pow(srcQ_default, -2.0) + 4.0, 0.5)) / 2.0

		SRC_zero1 = pipeparts.mkmatrixmixer(pipeline, smooth_fs, matrix = [[Q_factor1, 0.0]])
		SRC_zero1 = pipeparts.mktogglecomplex(pipeline, SRC_zero1)

		SRC_zero2 = pipeparts.mkmatrixmixer(pipeline, smooth_fs, matrix = [[Q_factor2, 0.0]])
		SRC_zero2 = pipeparts.mktogglecomplex(pipeline, SRC_zero2)

		tdep_zpk.extend([SRC_zero1, SRC_zero2])

		# This will be added into tdep_zpk at the end, as required by lal_adaptivefirfilt
		variable_invsens_gain = pipeparts.mkaudioamplify(pipeline, calibration_parts.mkpow(pipeline, smooth_fs, exponent = 2.0), pow(fs_default, -2.0))

	elif apply_srcq:
		# The variable zeros depend on the model value of fs and the computed value of Q
		Q_inv_squared = calibration_parts.mkpow(pipeline, smooth_srcQ_inv, exponent = 2.0)
		sqrt_Q_inv_squared_plus4 = calibration_parts.mkpow(pipeline, pipeparts.mkgeneric(pipeline, Q_inv_squared, "lal_add_constant", value = 4.0), exponent = 0.5)
		sqrt_Q_inv_squared_plus4 = pipeparts.mktee(pipeline, sqrt_Q_inv_squared_plus4)

		SRC_zero1 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, sqrt_Q_inv_squared_plus4))
		SRC_zero1 = pipeparts.mkmatrixmixer(pipeline, SRC_zero1, matrix = [[0.5 * fs_default, 0.0]])
		SRC_zero1 = pipeparts.mktogglecomplex(pipeline, SRC_zero1)

		SRC_zero2 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, pipeparts.mkaudioamplify(pipeline, sqrt_Q_inv_squared_plus4, -1.0)))
		SRC_zero2 = pipeparts.mkmatrixmixer(pipeline, SRC_zero2, matrix = [[0.5 * fs_default, 0.0]])
		SRC_zero2 = pipeparts.mktogglecomplex(pipeline, SRC_zero2)

		tdep_zpk.extend([SRC_zero1, SRC_zero2])

	if apply_kappac:
		# We divide the gain by kappa_c
		kappac_inv = calibration_parts.mkpow(pipeline, smooth_kctee, exponent = -1.0)
		if apply_fs:
			variable_invsens_gain = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, variable_invsens_gain, kappac_inv))
		else:
			variable_invsens_gain = kappac_inv

	if apply_kappac or apply_fs:
		# Now add the gain into the list of corrections
		variable_invsens_gain = pipeparts.mkmatrixmixer(pipeline, variable_invsens_gain, matrix = [[1.0, 0.0]])
		variable_invsens_gain = pipeparts.mktogglecomplex(pipeline, variable_invsens_gain)
		tdep_zpk.append(variable_invsens_gain)

	# Now interleave the correction channels in tdep_zpk and feed them into lal_adaptivefirfilt to update the inverse sensing filter
	tdep_zpk = calibration_parts.mkinterleave(pipeline, tdep_zpk, complex_data = True)
	adaptive_invsens_filter = pipeparts.mkgeneric(pipeline, tdep_zpk, "lal_adaptivefirfilt", update_samples = int(sensing_filter_update_time * compute_factors_sr), average_samples = int(sensing_filter_averaging_time * compute_factors_sr), num_zeros = variable_invsens_zeros, num_poles = 0, static_poles = static_invsens_poles, static_filter = reschainfilt, variable_filter_length = len(reschainfilt), adaptive_filter_length = len(reschainfilt), tukey_param = 0.5, filter_sample_rate = hoft_sr)

#
# CONTROL BRANCH
#

# zero out filter settling samples
tst_filter_settle_time = 0.0
tst_filter_latency = 0.0
pum_filter_settle_time = 0.0
pum_filter_latency = 0.0
uim_filter_settle_time = 0.0
uim_filter_latency = 0.0
pumuim_filter_settle_time = 0.0
pumuim_filter_latency = 0.0

actsr = max(tstchainsr, pumchainsr, uimchainsr) if (apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim) else max (tstchainsr, pumuimchainsr)

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank
if CalibrationConfigs["calibrationmode"] == "Partial":
	# enforce caps on actuation channels and set up progress report if verbose is on
	tst = calibration_parts.caps_and_progress(pipeline, head_dict["tst"], ctrl_caps, "tst")
	tsttee = pipeparts.mktee(pipeline, tst)
	pum = calibration_parts.caps_and_progress(pipeline, head_dict["pum"], ctrl_caps, "pum")
	pumtee = pipeparts.mktee(pipeline, pum)
	uim = calibration_parts.caps_and_progress(pipeline, head_dict["uim"], ctrl_caps, "uim")
	uimtee = pipeparts.mktee(pipeline, uim)

	# If processing the PUM and UIM actuation channels together, add them here
	if not (apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim):
		pumuim = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pumtee, uimtee))

	# if you need to, dewhiten the TST and PUM/UIM chains
	if dewhitening:
		tst = calibration_parts.mkresample(pipeline, tsttee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % tstdewhitensr) 
		tst = pipeparts.mkfirbank(pipeline, tst, latency = int(tstdewhitendelay), fir_matrix = [tstdewhiten[::-1]], time_domain = td)
		tst_filter_settle_time += float(len(tstdewhiten)-tstdewhitendelay)/tstdewhitensr
		tst_filter_latency += float(tstdewhitendelay)/tstdewhitensr
		if apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim:
			pum = calibration_parts.mkresample(pipeline, pum, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumdewhitensr)
			pum = pipeparts.mkfirbank(pipeline, pum, latency = int(pumdewhitendelay), fir_matrix = [pumdewhiten[::-1]], time_domain = td)
			pum_filter_settle_time += float(len(pumdewhiten)-pumdewhitendelay)/pumdewhitensr
			pum_filter_latency += float(pumdewhitendelay)/pumdewhitensr
			uim = calibration_parts.mkresample(pipeline, uim, 5, False, "audio/x-raw, format=F64LE, rate=%d" % uimdewhitensr)
			uim = pipeparts.mkfirbank(pipeline, uim, latency = int(uimdewhitendelay), fir_matrix = [uimdewhiten[::-1]], time_domain = td)
			uim_filter_settle_time += float(len(uimdewhiten)-uimdewhitendelay)/uimdewhitensr
			uim_filter_latency += float(uimdewhitendelay)/uimdewhitensr
		else:
			pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumuimdewhitensr)
			pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = int(pumuimdewhitendelay), fir_matrix = [pumuimdewhiten[::-1]], time_domain = td)
			pumuim_filter_settle_time += float(len(pumuimdewhiten)-pumuimdewhitendelay)/pumuimdewhitensr
			pumuim_filter_latency += float(pumuimdewhitendelay)/pumuimdewhitensr
	else:
		tst = tsttee

if CalibrationConfigs["calibrationmode"] == "Full":
	# enforce caps on actuation channels and set up progress report, if verbose is on
	ctrl = calibration_parts.caps_and_progress(pipeline, head_dict["ctrl"], hoft_caps, "ctrl")
	darmctrltee = pipeparts.mktee(pipeline, ctrl)
	
	if dewhitening:
		# dewhiten the DARM_CTRL channel
		ctrl = calibration_parts.mkresample(pipeline, darmctrltee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % ctrldewhitensr)
		ctrl = pipeparts.mkfirbank(pipeline, ctrl, latency = int(ctrldewhitendelay), fir_matrix = [ctrldewhiten[::-1]], time_domain = td)
		tst_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
		tst_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
		if apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim:
			pum_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
			pum_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
			uim_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
			uim_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
		else:
			pumuim_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
			pumuim_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
		# tee DARM_CTRL, which will be filtered with PUM, UIM, and TST filters separately
		ctrltee = pipeparts.mktee(pipeline, ctrl)
	else:
		ctrltee = darmctrltee
	tst = ctrltee
	pumtee = ctrltee
	uimtee = ctrltee
	pumuim = ctrltee

# resample what will become the TST actuation chain to the TST FIR filter sample rate
tst = calibration_parts.mkresample(pipeline, tst, 5, False, "audio/x-raw, format=F64LE, rate=%d" %  tstchainsr)
# Remove any DC component
if remove_dc:
	tst = calibration_parts.removeDC(pipeline, tst, tstchainsr)
# High-pass filter the TST chain
if any(act_highpass):
	tst = pipeparts.mkfirbank(pipeline, tst, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td)
	tst_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/tstchainsr
	tst_filter_latency += float(act_highpass_delay)/tstchainsr

if apply_complex_kappatst:
	# Filter the TST chain with an adaptive TST actuation filter that includes a linear-phase correction from kappa_tst
	tst = pipeparts.mkgeneric(pipeline, tst, "lal_tdwhiten", kernel = tstfilt[::-1], latency = tstdelay, taper_length = actuation_filter_taper_length)
	# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
	adaptive_tst_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, tst, "adaptive-filter", "kernel")

else:
	# Filter the TST chain with the static TST actuation filter
	tst = pipeparts.mkfirbank(pipeline, tst, latency = tstdelay, fir_matrix = [tstfilt[::-1]], time_domain = td)

tst_filter_settle_time += float(len(tstfilt)-tstdelay)/tstchainsr
tst_filter_latency += float(tstdelay)/tstchainsr

# apply kappa_tst if we haven't already
if apply_kappatst and not apply_complex_kappatst:
	# Only apply the real part of \kappa_tst as a correction to A_tst
	ktst_for_tst = calibration_parts.mkresample(pipeline, smooth_ktstRtee, 3, False, tstchainsr)
	tst = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, ktst_for_tst, tst))

# resample the TST actuation chain if necessary
if tstchainsr < actsr:
	tst = calibration_parts.mkresample(pipeline, tst, 5, False, actsr)

# Check whether we need to filter the PUM and UIM stages separately or together
if apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim:
	# resample what will become the PUM and UIM actuation paths to the PUM and UIM FIR filter sample rates
	pum = calibration_parts.mkresample(pipeline, pumtee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumchainsr)
	uim = calibration_parts.mkresample(pipeline, uimtee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % uimchainsr)
	# Remove any DC component
	if remove_dc:
		pum = calibration_parts.removeDC(pipeline, pum, pumchainsr)
		uim = calibration_parts.removeDC(pipeline, uim, uimchainsr)
	# High-pass filter the PUM and UIM paths
	if any(act_highpass):
		pum = pipeparts.mkfirbank(pipeline, pum, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td)
		pum_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/pumchainsr
		pum_filter_latency += float(act_highpass_delay)/pumchainsr
		uim = pipeparts.mkfirbank(pipeline, uim, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td) 
		uim_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/uimchainsr
		uim_filter_latency += float(act_highpass_delay)/uimchainsr

	if apply_complex_kappapum:
		# Filter the PUM chain with an adaptive PUM actuation filter that includes a linear-phase correction from kappa_pum
		pum = pipeparts.mkgeneric(pipeline, pum, "lal_tdwhiten", kernel = pumfilt[::-1], latency = pumdelay, taper_length = actuation_filter_taper_length)
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_pum_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, pum, "adaptive-filter", "kernel")
	else:
		# Filter the PUM chain with the static PUM actuation filter
		pum = pipeparts.mkfirbank(pipeline, pum, latency = pumdelay, fir_matrix = [pumfilt[::-1]], time_domain = td)

	if apply_complex_kappauim:
		# Filter the UIM chain with an adaptive UIM actuation filter that includes a linear-phase correction from kappa_uim
		uim = pipeparts.mkgeneric(pipeline, uim, "lal_tdwhiten", kernel = uimfilt[::-1], latency = uimdelay, taper_length = actuation_filter_taper_length)
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_uim_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, uim, "adaptive-filter", "kernel")
	else:
		# Filter the UIM chain with the static UIM actuation filter
		uim = pipeparts.mkfirbank(pipeline, uim, latency = uimdelay, fir_matrix = [uimfilt[::-1]], time_domain = td)

	pum_filter_settle_time += float(len(pumfilt)-pumdelay)/pumchainsr
	pum_filter_latency += float(pumdelay)/pumchainsr
	uim_filter_settle_time += float(len(uimfilt)-uimdelay)/uimchainsr
	uim_filter_latency += float(uimdelay)/uimchainsr

	# apply kappa_pum if we haven't already
	if apply_kappapum and not apply_complex_kappapum:
		# Only apply the real part of kappa_pum as a correction to A_pum
		kpum_for_pum = calibration_parts.mkresample(pipeline, smooth_kpumRtee, 3, False, pumchainsr)
		pum = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, kpum_for_pum, pum))
	# apply kappa_uim if we haven't already
	if apply_kappauim and not apply_complex_kappauim:
		# Only apply the real part of kappa_uim as a correction to A_uim
		kuim_for_uim = calibration_parts.mkresample(pipeline, smooth_kuimRtee, 3, False, uimchainsr)
		uim = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, kuim_for_uim, uim))

	# resample the PUM actuation path if necessary
	if pumchainsr < actsr:
		pum = calibration_parts.mkresample(pipeline, pum, 5, False, actsr)

	# resample the UIM actuation path if necessary
	if uimchainsr < actsr:
		uim = calibration_parts.mkresample(pipeline, uim, 5, False, actsr)

	# Add the TST, PUM, and UIM paths together to form the full actuation path
	ctrl = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, tst, pum, uim))
else:
	# resample what will become the PUM/UIM actuation chain to the PUM/UIM FIR filter sample rate
	pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumuimchainsr)
	# Remove any DC component
	if remove_dc:
		pumuim = calibration_parts.removeDC(pipeline, pumuim, pumuimchainsr)
	# High-pass filter the PUM/UIM chain
	if any(act_highpass):
		pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td)
		pumuim_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/pumuimchainsr
		pumuim_filter_latency += float(act_highpass_delay)/pumuimchainsr

	if apply_complex_kappapu:
		# Filter the PUM/UIM chain with an adaptive PUM/UIM actuation filter that includes a linear-phase correction from kappa_pu
		pumuim = pipeparts.mkgeneric(pipeline, pumuim, "lal_tdwhiten", kernel = pumuimfilt[::-1], latency = pumuimdelay, taper_length = actuation_filter_taper_length)
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_pumuim_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, pumuim, "adaptive-filter", "kernel")

	else:
		# Filter the PUM/UIM chain with the static PUM/UIM actuation filter
		pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = pumuimdelay, fir_matrix = [pumuimfilt[::-1]], time_domain = td)

	pumuim_filter_settle_time += float(len(pumuimfilt)-pumuimdelay)/pumuimchainsr
	pumuim_filter_latency += float(pumuimdelay)/pumuimchainsr

	# apply kappa_pu if we haven't already
	if apply_kappapu and not apply_complex_kappapu:
		# Only apply the real part of \kappa_pu as a correction to A_pu
		kpu_for_pu = calibration_parts.mkresample(pipeline, smooth_kpuRtee, 3, False, pumuimchainsr)
		pumuim = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, kpu_for_pu, pumuim))


	# resample the PUM/UIM actuation chain if necessary
	if pumuimchainsr < actsr:
		pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, actsr)

	# Add the TST and PUM/UIM chains together to form the full actuation chain
	ctrl = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, tst, pumuim))

# Resample \DeltaL_ctrl to the full h(t) sample rate
if actsr != hoft_sr:
	ctrl = calibration_parts.mkresample(pipeline, ctrl, 5, False, hoft_caps)

#
# RESIDUAL BRANCH
#

# zero out res filter settle time
res_filter_settle_time = 0.0
res_filter_latency = 0.0

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank

# enforce caps on the residual branch and hook up progress report if verbose is on
if CalibrationConfigs["calibrationmode"] == "Full":
	if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc:
		res = restee = derrtee
	else:
		res = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "res")
		res = restee = pipeparts.mktee(pipeline, res)
elif CalibrationConfigs["calibrationmode"] == "Partial":
	res = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "res")
	res = restee = pipeparts.mktee(pipeline, res)

# Remove any DC component
if remove_dc:
	res = calibration_parts.removeDC(pipeline, res, hoft_sr)

# High-pass filter the residual chain
if any(invsens_highpass):
	res = pipeparts.mkfirbank(pipeline, res, latency = invsens_highpass_delay, fir_matrix = [invsens_highpass[::-1]], time_domain = td)
	res_filter_settle_time += float(len(invsens_highpass)-invsens_highpass_delay)/hoft_sr
	res_filter_latency += float(invsens_highpass_delay)/hoft_sr

if apply_fcc or apply_fs or apply_srcq:
	# Apply an adaptive filter to include the time-dependence of any sensing function parameters
	res = pipeparts.mkgeneric(pipeline, res, "lal_tdwhiten", kernel = reschainfilt[::-1], latency = reschaindelay, taper_length = sensing_filter_taper_length)
	# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
	adaptive_invsens_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, res, "adaptive-filter", "kernel")
# # Correct for time-dependence of f_cc
#if apply_fcc:
#	
#	default_fir_matrix = numpy.zeros(int(numpy.floor(hoft_sr*float(TDCFConfigs["fccfilterduration"])/2.0+1)*2.0-2.0))
#	latency = int(hoft_sr*float(TDCFConfigs["fccfilterduration"])/(2.0)+1)
#	default_fir_matrix[latency] = 1.0
#	res = pipeparts.mkgeneric(pipeline, res, "lal_tdwhiten", kernel = default_fir_matrix[::-1], latency = latency, taper_length = int(TDCFConfigs["fccfiltertaperlength"]))
#	update_fcc.connect("notify::fir-matrix", fir_matrix_update, res)

else:
	# Apply the residual chain filter without time-dependence
	res = pipeparts.mkfirbank(pipeline, res, latency = int(reschaindelay), fir_matrix = [reschainfilt[::-1]], time_domain = td)

# Account for filter latency and settle time for the CALIB_STATE_VECTOR
res_filter_settle_time += float(len(reschainfilt)-reschaindelay)/hoft_sr
res_filter_latency += float(reschaindelay)/hoft_sr

# Apply \kappa_c if we haven't already
if apply_kappac and not (apply_fcc or apply_fs or apply_srcq):
	kc_modify_res = calibration_parts.mkresample(pipeline, smooth_kctee, 3, False, hoft_caps)
	res = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, res, calibration_parts.mkpow(pipeline, kc_modify_res, exponent = -1.0)))

if dewhitening:
	res = pipeparts.mkfirbank(pipeline, res, latency = int(resdewhitendelay), fir_matrix = [resdewhiten[::-1]], time_domain = td)
	res_filter_settle_time += float(len(resdewhiten)-resdewhitendelay)/hoft_sr
	res_filter_latency += float(resdewhitendelay)/hoft_sr

filter_settle_time = max(res_filter_settle_time, tst_filter_settle_time, pumuim_filter_settle_time)
filter_latency = max(res_filter_latency, tst_filter_latency, pumuim_filter_latency)

#
# CONTROL + RESIDUAL = H(T)
#

# Add control and residual chains and divide by L to make h(t)
strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, res, ctrl))

# Divide by L in a way that is compatitble with old and new filters files, since old filter files don't recored "arm length"
try:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/float(filters["arm_length"]))
except KeyError:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/3994.5)

strain = pipeparts.mkprogressreport(pipeline, strain, "progress_hoft_%s" % instrument)

# Put the units back to strain before writing to frames
straintagstr = "units=strain,channel-name=%sCALIB_STRAIN%s,instrument=%s" % (chan_prefix, chan_suffix, instrument)
if remove_cal_lines or remove_power_lines or witness_channel_list is not None:
	straintee = pipeparts.mktee(pipeline, strain)
	strain = pipeparts.mktaginject(pipeline, straintee, straintagstr)
else:
	strain = pipeparts.mktaginject(pipeline, strain, straintagstr)

#
# CALIB_STATE_VECTOR BRANCH
#

#FIXME: Add more comments!

if compute_calib_statevector:
	# FIXME: When the ODC is written as unsigned ints, this piece can be removed
	odcstatevector = calibration_parts.caps_and_progress(pipeline, head_dict["odcstatevector"], odc_caps, "odc_%s" % instrument)
	odctagstr = "channel-name=%s:%s, instrument=%s" % (instrument, ChannelNames["inputdqchannel"], instrument)
	odcstatevector = pipeparts.mktaginject(pipeline, odcstatevector, odctagstr)
	odcstatevectortee = pipeparts.mktee(pipeline, odcstatevector)

	# 
	# OBSERVATION-INTENT BIT BRANCH
	#

	obsintent = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["obsintentbitmask"]), status_out = pow(2,1))
	obsintent = pipeparts.mkcapsfilter(pipeline, obsintent, calibstate_caps)
	obsintenttee = pipeparts.mktee(pipeline, obsintent)
	
	#
	# OBSERVATION-READY BIT BRANCH
	#

	obsready = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["obsreadybitmask"]), status_out = pow(2,2))
	obsready = pipeparts.mkcapsfilter(pipeline, obsready, calibstate_caps)
	obsreadytee = pipeparts.mktee(pipeline, obsready)

	#
	# FILTERS-OK BIT BRANCH
	#
	
	# Set the FILTERS-OK bit based on observation-ready transitions
	filtersok = pipeparts.mkbitvectorgen(pipeline, obsintenttee, bit_vector=pow(2,3), threshold=2)
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, calibstate_caps)
	filtersok = calibration_parts.mkgate(pipeline, filtersok, obsreadytee, 4, attack_length = -int(filter_settle_time * calibstate_sr), hold_length = -int(filter_latency * calibstate_sr))
	filtersok = pipeparts.mkbitvectorgen(pipeline, filtersok, bit_vector = pow(2,3), nongap_is_control = True)
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, calibstate_caps)

	#
	# NO-INVALID-INPUT BRANCH
	#

	# Check if the ODC state vector is present
	nogap = pipeparts.mkbitvectorgen(pipeline, odcstatevectortee, threshold=1, bit_vector = 1)
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, odc_caps)
	nogap = pipeparts.mkgeneric(pipeline, nogap, "lal_logicalundersample", required_on = 1, status_out = 1)
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, calibstate_caps)
	# Check if any of the input data channels had to be replaced by zeroes because they were < 1e-35
	resok = pipeparts.mkbitvectorgen(pipeline, restee, threshold=1e-35, bit_vector=1)
	resok = pipeparts.mkcapsfilter(pipeline, resok, "audio/x-raw, format=U32LE, rate=%d" % hoft_sr)
	resok = pipeparts.mkgeneric(pipeline, resok, "lal_logicalundersample", required_on = 1, status_out = 1)
	resok = pipeparts.mkcapsfilter(pipeline, resok, calibstate_caps)
	if CalibrationConfigs["calibrationmode"] == "Partial":
		tstok = pipeparts.mkbitvectorgen(pipeline, tsttee, threshold=1e-35, bit_vector=1)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		tstok = pipeparts.mkgeneric(pipeline, tstok, "lal_logicalundersample", required_on = 1, status_out = 1)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, calibstate_caps)
		pumok = pipeparts.mkbitvectorgen(pipeline, pumtee, threshold=1e-35, bit_vector=1)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		pumok = pipeparts.mkgeneric(pipeline, pumok, "lal_logicalundersample", required_on = 1, status_out = 1)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, calibstate_caps)
		uimok = pipeparts.mkbitvectorgen(pipeline, uimtee, threshold=1e-35, bit_vector=1)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		uimok = pipeparts.mkgeneric(pipeline, uimok, "lal_logicalundersample", required_on = 1, status_out = 1)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, calibstate_caps)
		noinvalidinput = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, nogap, resok, tstok, pumok, uimok))
		noinvalidinput = pipeparts.mkbitvectorgen(pipeline, noinvalidinput, threshold=5, bit_vector=pow(2,4))
	if CalibrationConfigs["calibrationmode"] == "Full":
		ctrlok = pipeparts.mkbitvectorgen(pipeline, darmctrltee, threshold=1e-35, bit_vector=1)
		ctrlok = pipeparts.mkcapsfilter(pipeline, ctrlok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		ctrlok = pipeparts.mkgeneric(pipeline, ctrlok, "lal_logicalundersample", required_on = 1, status_out = 1)
		ctrlok = pipeparts.mkcapsfilter(pipeline, ctrlok, calibstate_caps)
		noinvalidinput = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, nogap, resok, ctrlok))
		noinvalidinput = pipeparts.mkbitvectorgen(pipeline, noinvalidinput, threshold=3, bit_vector=pow(2,4))
	noinvalidinput = pipeparts.mkcapsfilter(pipeline, noinvalidinput, calibstate_caps)
	noinvalidinput = pipeparts.mktee(pipeline, noinvalidinput)
	# inputs that are replaced with zeros affect h(t) for a short time before and after the zeros, so we also must account for this corrupted time.
	noinvalidinput = calibration_parts.mkgate(pipeline, noinvalidinput, noinvalidinput, pow(2,4), attack_length = -int(filter_settle_time * calibstate_sr), hold_length = -int(filter_latency * calibstate_sr))

	#
	# KAPPATST BITS BRANCH
	#
	if compute_kappatst:
		ktstSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_ktstRtee, smooth_ktstItee, expected_kappatst_real, expected_kappatst_imag, kappatst_real_var, kappatst_imag_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,9), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# KAPPAPUM/KAPPAPU BITS BRANCH
	#
	if compute_kappapum:
		kpumSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_kpumRtee, smooth_kpumItee, expected_kappapum_real, expected_kappapum_imag, kappapum_real_var, kappapum_imag_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,10), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	elif compute_kappapu:
		kpumSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_kpuRtee, smooth_kpuItee, expected_kappapu_real, expected_kappapu_imag, kappapu_real_var, kappapu_imag_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,10), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# KAPPAUIM BITS BRANCH
	#
	if compute_kappauim:
		kuimSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_kuimRtee, smooth_kuimItee, expected_kappauim_real, expected_kappauim_imag, kappauim_real_var, kappauim_imag_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,11), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# KAPPAC BITS BRANCH
	#
	if compute_kappac:
		kcSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_kctee, expected_kappac, kappac_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,12), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# FCC BITS BRANCH
	#
	if compute_fcc:
		fccSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_fcctee, fcc_default, fcc_var, int(median_smoothing_samples / 2) + factors_average_samples + sensing_filter_averaging_time * compute_factors_sr, status_out_smooth = pow(2,13), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# FS BITS BRANCH
	#
	if compute_fs:
		fsSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_fs, fs_default, fs_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,14), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# SRCQ BITS BRANCH
	#
	if compute_srcq:
		srcQSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_srcQ_inv, 1.0 / srcQ_default, [srcQinv_min, srcQinv_max], int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = pow(2,15), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# COHERENCE BITS BRANCH
	#
	if use_coherence:
		coherence_ok_list = []
		if compute_kappac or compute_fcc or compute_srcq or compute_fs:
			# PCALY_LINE2 is only used for \kappa_c, f_cc, f_s, and Q
			pcaly_line2_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line2_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,19), invert_control = True)
			pcaly_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line2_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			pcaly_line2_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line2_coh_ok, "lal_logicalundersample", required_on = pow(2,19), status_out = pow(2,19))
			pcaly_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line2_coh_ok, calibstate_caps)
			coherence_ok_list.append(pcaly_line2_coh_ok)
		if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_srcq or compute_fs:
			# The coherences of these lines are all used to gate all the time dependence calculations
			pcaly_line1_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line1_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,18), invert_control = True)
			pcaly_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line1_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			pcaly_line1_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line1_coh_ok, "lal_logicalundersample", required_on = pow(2,18), status_out = pow(2,18))
			pcaly_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line1_coh_ok, calibstate_caps)

			sus_coh_ok = pipeparts.mkbitvectorgen(pipeline, sus_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,16), invert_control = True)
			sus_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			sus_coh_ok = pipeparts.mkgeneric(pipeline, sus_coh_ok, "lal_logicalundersample", required_on = pow(2,16), status_out = pow(2,16))
			sus_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_coh_ok, calibstate_caps)

			darm_coh_ok = pipeparts.mkbitvectorgen(pipeline, darm_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,17), invert_control = True)
			darm_coh_ok = pipeparts.mkcapsfilter(pipeline, darm_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			darm_coh_ok = pipeparts.mkgeneric(pipeline, darm_coh_ok, "lal_logicalundersample", required_on = pow(2,17), status_out = pow(2,17))
			darm_coh_ok = pipeparts.mkcapsfilter(pipeline, darm_coh_ok, calibstate_caps)
			coherence_ok_list.extend((pcaly_line1_coh_ok, sus_coh_ok, darm_coh_ok))
			coherence_bits = calibration_parts.mkadder(pipeline, tuple(coherence_ok_list))

	#
	# H(T)-OK BIT BRANCH
	#

	# First combine higher order bits to determine h(t)-OK
	higherbits_list = [filtersok, obsreadytee, noinvalidinput]
	htok_threshold = pow(2,2) + pow(2,3) + pow(2,4)
	if apply_kappatst or apply_complex_kappatst:
		higherbits_list.append(ktstSmoothInRange)
		htok_threshold += pow(2,9)
	if apply_kappapum or apply_complex_kappapum or apply_kappapu or apply_complex_kappapu:
		higherbits_list.append(kpumSmoothInRange)
		htok_threshold += pow(2,10)
	if apply_kappauim or apply_complex_kappauim:
		higherbits_list.append(kuimSmoothInRange)
		htok_threshold += pow(2,11)
	if apply_kappac:
		higherbits_list.append(kcSmoothInRange)
		htok_threshold += pow(2,12)
	if apply_fcc:
		higherbits_list.append(fccSmoothInRange)
		htok_threshold += pow(2,13)
	if apply_fs:
		higherbits_list.append(fsSmoothInRange)
		htok_threshold += pow(2,14)
	if apply_srcq:
		higherbits_list.append(srcQSmoothInRange)
		htok_threshold += pow(2,15)
	higherbits = calibration_parts.mkadder(pipeline, tuple(higherbits_list))
	higherbitstee = pipeparts.mktee(pipeline, higherbits)

	# Now calculate h(t)-OK bit
	htok = pipeparts.mkbitvectorgen(pipeline, higherbitstee, bit_vector = 1, threshold = htok_threshold)
	htok = pipeparts.mkcapsfilter(pipeline, htok, calibstate_caps)

	#
	# HW INJECTION BITS
	#	

	hwinjcbc = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["cbchwinjbitmask"]), status_out = pow(2,6))
	hwinjcbc = pipeparts.mkcapsfilter(pipeline, hwinjcbc, calibstate_caps)

	hwinjburst = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["bursthwinjbitmask"]), status_out = pow(2,7))
	hwinjburst = pipeparts.mkcapsfilter(pipeline, hwinjburst, calibstate_caps)

	hwinjdetchar = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["detcharhwinjbitmask"]), status_out = pow(2,8))
	hwinjdetchar = pipeparts.mkcapsfilter(pipeline, hwinjdetchar, calibstate_caps)

	hwinjstoch = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(Bitmasks["stochhwinjbitmask"]), status_out = pow(2,5))
	hwinjstoch = pipeparts.mkcapsfilter(pipeline, hwinjstoch, calibstate_caps)

	#
	# EPICS BITS
	#

	D_epics_threshold = 0.5 + len(D_epics_dict)
	A_epics_threshold = 0.5 + len(A_epics_dict)
	C_epics_threshold = 0.5 + len(C_epics_dict)
	misc_epics_threshold = 0.5 + len(misc_epics_dict)
	epics_bits_list = []

	# First, check the EPICS that involve only the digital filter D, EP7 and EP12
	if(len(D_epics_dict)):
		D_epics_check_list = []
		for EP_key in D_epics_dict:
			D_epics_check = pipeparts.mkaudioamplify(pipeline, D_epics_dict[EP_key][0], 1.0 / D_epics_dict[EP_key][1])
			# The above values should be close to one (within 1 / 10^4)
			D_epics_check = pipeparts.mkgeneric(pipeline, D_epics_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			D_epics_check_list.append(D_epics_check)
		D_epics_check = calibration_parts.mkadder(pipeline, tuple(D_epics_check_list))
		D_epics_bit = pipeparts.mkbitvectorgen(pipeline, D_epics_check, bit_vector = pow(2,21), threshold = D_epics_threshold)
		D_epics_bit = pipeparts.mkgeneric(pipeline, D_epics_bit, "lal_logicalundersample", required_on = pow(2,21), status_out = pow(2,21))
		D_epics_bit = pipeparts.mkcapsfilter(pipeline, D_epics_bit, calibstate_caps)
		epics_bits_list.append(D_epics_bit)

	# Next, check the EPICS that involve only the actuation function A: EP3, EP4, EP8, EP9, EP10, EP13, EP14, EP16, EP17, EP18, EP19, EP20, EP21, EP23, and EP24
	if(len(A_epics_dict)):
		A_epics_check_list = []
		for EP_key in A_epics_dict:
			A_epics_check = pipeparts.mkaudioamplify(pipeline, A_epics_dict[EP_key][0], 1.0 / A_epics_dict[EP_key][1])
			# The above values should be close to one (within 1 / 10^4)
			A_epics_check = pipeparts.mkgeneric(pipeline, A_epics_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			A_epics_check_list.append(A_epics_check)
		A_epics_check = calibration_parts.mkadder(pipeline, tuple(A_epics_check_list))
		A_epics_bit = pipeparts.mkbitvectorgen(pipeline, A_epics_check, bit_vector = pow(2,22), threshold = A_epics_threshold)
		A_epics_bit = pipeparts.mkgeneric(pipeline, A_epics_bit, "lal_logicalundersample", required_on = pow(2,22), status_out = pow(2,22))
		A_epics_bit = pipeparts.mkcapsfilter(pipeline, A_epics_bit, calibstate_caps)
		epics_bits_list.append(A_epics_bit)

	# Next, check the EPICS that involve only the sensing function C, EP6 and EP11
	if(len(C_epics_dict)):
		C_epics_check_list = []
		for EP_key in C_epics_dict:
			C_epics_check = pipeparts.mkaudioamplify(pipeline, C_epics_dict[EP_key][0], 1.0 / C_epics_dict[EP_key][1])
			# The above values should be close to one (within 1 / 10^4)
			C_epics_check = pipeparts.mkgeneric(pipeline, C_epics_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			C_epics_check_list.append(C_epics_check)
		C_epics_check = calibration_parts.mkadder(pipeline, tuple(C_epics_check_list))
		C_epics_bit = pipeparts.mkbitvectorgen(pipeline, C_epics_check, bit_vector = pow(2,23), threshold = C_epics_threshold)
		C_epics_bit = pipeparts.mkgeneric(pipeline, C_epics_bit, "lal_logicalundersample", required_on = pow(2,23), status_out = pow(2,23))
		C_epics_bit = pipeparts.mkcapsfilter(pipeline, C_epics_bit, calibstate_caps)
		epics_bits_list.append(C_epics_bit)

	# Next, check the remaining EPICS that are combinations of D, A, and C: EP1, EP2, EP15, EP22
	if(len(misc_epics_dict)):
		misc_epics_check_list = []
		for EP_key in misc_epics_dict:
			misc_epics_check = pipeparts.mkaudioamplify(pipeline, misc_epics_dict[EP_key][0], 1.0 / misc_epics_dict[EP_key][1])
			# The above values should be close to one (within 1 / 10^4)
			misc_epics_check = pipeparts.mkgeneric(pipeline, misc_epics_check, "lal_insertgap", bad_data_intervals = [0.9999, 1.0001], replace_value = 0.0, insert_gap = False)
			misc_epics_check_list.append(misc_epics_check)
		misc_epics_check = calibration_parts.mkadder(pipeline, tuple(misc_epics_check_list))
		misc_epics_bit = pipeparts.mkbitvectorgen(pipeline, misc_epics_check, bit_vector = pow(2,24), threshold = misc_epics_threshold)
		misc_epics_bit = pipeparts.mkgeneric(pipeline, misc_epics_bit, "lal_logicalundersample", required_on = pow(2,24), status_out = pow(2,24))
		misc_epics_bit = pipeparts.mkcapsfilter(pipeline, misc_epics_bit, calibstate_caps)
		epics_bits_list.append(misc_epics_bit)

	#
	# COMBINE ALL BITS TO MAKE GDS-CALIB_STATE_VECTOR
	#

	all_bits_list = [higherbitstee, obsintenttee, htok, hwinjcbc, hwinjburst, hwinjdetchar, hwinjstoch]
	if use_coherence and (compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq):
		all_bits_list.append(coherence_bits)
	if compute_kappatst and not apply_kappatst and not apply_complex_kappatst:
		all_bits_list.append(ktstSmoothInRange)
	if (compute_kappapum or compute_kappapu) and not (apply_kappapum or apply_complex_kappapum or apply_kappapu or apply_complex_kappapu):
		all_bits_list.append(kpumSmoothInRange)
	if compute_kappauim and not (apply_kappauim or apply_complex_kappauim):
		all_bits_list.append(kuimSmoothInRange)
	if compute_kappac and not apply_kappac:
		all_bits_list.append(kcSmoothInRange)
	if compute_fcc and not apply_fcc:
		all_bits_list.append(fccSmoothInRange)
	if compute_fs and not apply_fs:
		all_bits_list.append(fsSmoothInRange)
	if compute_srcq and not apply_srcq:
		all_bits_list.append(srcQSmoothInRange)
	all_bits_list.extend(epics_bits_list)

	calibstatevector = calibration_parts.mkadder(pipeline, tuple(all_bits_list))
	calibstatevector = pipeparts.mkprogressreport(pipeline, calibstatevector, "progress_calibstatevec_%s" % instrument)
	dqtagstr = "channel-name=%s:GDS-CALIB_STATE_VECTOR, instrument=%s" % (instrument, instrument)
	calibstatevector = pipeparts.mktaginject(pipeline, calibstatevector, dqtagstr)

#
# SUBTRACTION OF LINES AND NOISE
#

# First, remove calibration lines
if remove_cal_lines:
	# if we didn't compute the kappas, we still need to get the pcal channel
	if not compute_kappatst and not compute_kappapu and not compute_kappac and not compute_fcc and not compute_srcq and not compute_fs:
		pcal = calibration_parts.caps_and_progress(pipeline, head_dict["pcal"], hoft_caps, "pcal")
		pcaltee = pipeparts.mktee(pipeline, pcal)

	callines_list = []
	# Start with the pcal lines. Loop through the dictionary, reconstruct each line, and add to the list.
	for pcal_line_name in pcal_line_removal_dict:
		if not pcal_line_removal_dict[pcal_line_name][4]:
			# This line still needs to be demodulated
			pcal_line_removal_dict[pcal_line_name][0] = calibration_parts.demodulate(pipeline, pcal_line_removal_dict[pcal_line_name][0], pcal_line_removal_dict[pcal_line_name][1], td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, prefactor_real = pcal_line_removal_dict[pcal_line_name][2], prefactor_imag = pcal_line_removal_dict[pcal_line_name][3])
		# Reconstruct a pcal signal at only this pcal line
		pcal_line_removal_dict[pcal_line_name][0] = calibration_parts.mkresample(pipeline, pcal_line_removal_dict[pcal_line_name][0], 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoft_sr)
		pcal_line_removal_dict[pcal_line_name][0] = pipeparts.mkgeneric(pipeline, pcal_line_removal_dict[pcal_line_name][0], "lal_demodulate", line_frequency = -1.0 * pcal_line_removal_dict[pcal_line_name][1], prefactor_real = 2.0)
		pcal_line_removal_dict[pcal_line_name][0] = pipeparts.mkgeneric(pipeline, pcal_line_removal_dict[pcal_line_name][0], "creal")
		# Add this line to the list
		callines_list.append(pcal_line_removal_dict[pcal_line_name][0])

	# Now deal with the actuation lines. Loop through the dictionary, reconstruct each line, and add to the list.
	for act_line_name in act_line_removal_dict:
		if not act_line_removal_dict[act_line_name][4]:
			# This line still needs to be demodulated
			act_line_removal_dict[act_line_name][0] = calibration_parts.demodulate(pipeline, act_line_removal_dict[act_line_name][0], act_line_removal_dict[act_line_name][1], td, compute_factors_sr, demodulation_filter_time, filter_latency_factor)
		if factors_from_filters_file:
			# EPICS records were read from the filters file
			act_line_removal_dict[act_line_name][0] = calibration_parts.complex_audioamplify(pipeline, act_line_removal_dict[act_line_name][0], A_epics_dict[act_line_removal_dict[act_line_name][2]][1], A_epics_dict[act_line_removal_dict[act_line_name][3]][1])
		else:
			# EPICS records are read from the frames
			EPICS = calibration_parts.merge_into_complex(pipeline, A_epics_dict[act_line_removal_dict[act_line_name][2]][0], A_epics_dict[act_line_removal_dict[act_line_name][3]][0])
			act_line_removal_dict[act_line_name][0] = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, act_line_removal_dict[act_line_name][0], EPICS))
		if act_line_removal_dict[act_line_name][5]:
			# Apply a complex time-dependent correction factor
			act_line_removal_dict[act_line_name][0] = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, act_line_removal_dict[act_line_name][0], act_line_removal_dict[act_line_name][7]))
		elif act_line_removal_dict[act_line_name][6]:
			# Apply the real part of a time-dependent correction factor
			act_line_removal_dict[act_line_name][0] = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, act_line_removal_dict[act_line_name][0], pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, act_line_removal_dict[act_line_name][7]), matrix = [[1.0, 0.0]])))

		# Reconstruct a signal at only this actuation line
		act_line_removal_dict[act_line_name][0] = calibration_parts.mkresample(pipeline, act_line_removal_dict[act_line_name][0], 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoft_sr)
		act_line_removal_dict[act_line_name][0] = pipeparts.mkgeneric(pipeline, act_line_removal_dict[act_line_name][0], "lal_demodulate", line_frequency = -1.0 * act_line_removal_dict[act_line_name][1], prefactor_real = 2.0)
		act_line_removal_dict[act_line_name][0] = pipeparts.mkgeneric(pipeline, act_line_removal_dict[act_line_name][0], "creal")
		# Add this line to the list
		callines_list.append(act_line_removal_dict[act_line_name][0])

	# Add all the lines together
	calibration_lines = calibration_parts.mkadder(pipeline, tuple(callines_list))

	# Divide the calibration lines we are removing by the arm length
	try:
		calibration_lines = pipeparts.mkaudioamplify(pipeline, calibration_lines, -1.0/float(filters["arm_length"]))
	except KeyError:
		calibration_lines = pipeparts.mkaudioamplify(pipeline, calibration_lines, -1.0/3994.5)

	clean_strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, straintee, calibration_lines))

# Next, remove 60 Hz power lines and harmonics
if remove_power_lines:
	if not remove_cal_lines:
		clean_strain = straintee
	powerlines = calibration_parts.caps_and_progress(pipeline, head_dict["powerlines"], "audio/x-raw, format=F64LE, channels=1, channel-mask=(bitmask)0x0", "powerlines")
	clean_strain = calibration_parts.remove_harmonics_with_witness(pipeline, clean_strain, powerlines, 60, 5, powerlines_freq_var, filter_latency_factor, compute_rate = compute_factors_sr, rate_out = hoft_sr, num_avg = powerlines_tf_averaging_time * compute_factors_sr, obsready = None if not compute_calib_statevector else obsreadytee)

# Remove excess noise using any provided witness channels
if witness_channel_list is not None:
	# Remove initial data from computation of transfer functions and wait until the filters and kappas settle
	witness_delay_time = filter_settle_time + (1.0 - filter_latency_factor) * (demodulation_filter_time + median_smoothing_samples / compute_factors_sr + factors_average_samples / compute_factors_sr)
	# In high latency, make the witnesses wait to be filtered until new filters are ready
	witness_wait_time = (filter_settle_time + demodulation_filter_time + median_smoothing_samples / compute_factors_sr + factors_average_samples / compute_factors_sr + witness_channel_fft_time / 2.0 * (num_witness_ffts + 1.0)) if filter_latency_factor else 0.0
	# How much does the "delay_time" need to increase per iteration of cleaning?
	witness_delay_increment = witness_filter_taper_time + (witness_channel_fft_time / 2.0 * (num_witness_ffts + 1.0) if not filter_latency_factor else 0.0)
	# How much does the "wait_time" need to increase per iteration of cleaning?
	witness_wait_increment = (witness_filter_taper_time + witness_channel_fft_time / 2.0 * (num_witness_ffts + 1.0)) if filter_latency_factor else 0.0
	# If we haven't removed any lines, clean the regular h(t) data
	if not (remove_cal_lines or remove_power_lines):
		clean_strain = straintee

	# If possible, gate the data being used to compute transfer functions to be sure we are locked
	if not compute_calib_statevector:
		obsreadytee = None

	for i in range(0, len(witness_channel_list)):
		# Length of ffts used to compute FIR filters
		witness_fft_samples = int(witness_channel_fft_time * witness_rates[i])
		# Overlap of ffts is half of fft length. The data is Hann-windowed before taking ffts.
		witness_fft_overlap = int(witness_fft_samples / 2)
		# How many samples between filter updates (does not include the samples used to compute the FIR filters
		witness_tf_update_samples = int(witness_rates[i] * witness_tf_update_time)
		# Length of FIR filters
		witness_fir_samples = int(witness_fir_length * witness_rates[i])
		# Over how many samples should new FIR filters be tapered in?
		witness_filter_taper_length = int(witness_rates[i] * witness_filter_taper_time)

		witnesses = []
		for key in headkeys:
			if key in witness_channel_list[i]:
				witnesses.append(calibration_parts.caps_and_progress(pipeline, head_dict[key], "audio/x-raw, format=F64LE, channels=1, channel-mask=(bitmask)0x0", key))
		if len(witnesses) != len(witness_channel_list[i]):
			print "WARNING: Not all requested witness channels are being used"
		clean_strain = calibration_parts.clean_data(pipeline, clean_strain, hoft_sr, witnesses, witness_rates[i], witness_fft_samples, witness_fft_overlap, num_witness_ffts, min_witness_ffts, witness_tf_update_samples, witness_fir_samples, witness_frequency_resolution, witness_filter_taper_length, use_median = witness_tf_use_median, notch_frequencies = witness_notch_frequencies[i], obsready = obsreadytee, delay_time = witness_delay_time, wait_time = witness_wait_time, critical_lock_loss_time = critical_lock_loss_time, filename = "transfer_functions_%d.txt" % i)
		witness_delay_time += witness_delay_increment
		witness_wait_time += witness_wait_increment

if remove_cal_lines or remove_power_lines or witness_channel_list is not None:
	clean_strain = pipeparts.mkprogressreport(pipeline, clean_strain, "progress_hoft_cleaned_%s" % instrument)
	clean_straintagstr = "units=strain,channel-name=%sCALIB_STRAIN_CLEAN%s,instrument=%s" % (chan_prefix, chan_suffix, instrument)
	if compute_calib_statevector:
		clean_straintee = pipeparts.mktee(pipeline, clean_strain)
		clean_strain = pipeparts.mktaginject(pipeline, clean_straintee, clean_straintagstr)
	else:
		clean_strain = pipeparts.mktaginject(pipeline, clean_strain, clean_straintagstr)

#
# CALIB_STATE_VECTOR: CALIB_STRAIN_CLEAN
#

if compute_calib_statevector and (remove_cal_lines or remove_power_lines or witness_channel_list is not None):
	low_rms_rate = pow(2, int(numpy.log(cleaning_check_range_low_max) / numpy.log(2) + 1.1))
	mid_rms_rate = pow(2, int(numpy.log(cleaning_check_range_mid_max) / numpy.log(2) + 1.1))

	# Compute the RMS of the uncleaned strain in a low-frequency range to test subtraction of actuation lines
	strain_rms_lowfreq = calibration_parts.compute_rms(pipeline, straintee, low_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_low_min, f_max = cleaning_check_range_low_max, filter_latency = filter_latency_factor, rate_out = calibstate_sr, td = td)
	# Compute the RMS of the cleaned strain in a low-frequency range
	clean_strain_rms_lowfreq = calibration_parts.compute_rms(pipeline, clean_straintee, low_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_low_min, f_max = cleaning_check_range_low_max, filter_latency = filter_latency_factor, rate_out = calibstate_sr, td = td)
	# Require that ratio RMS(strain) / RMS(clean_strain) > 1.0
	clean_hoft_ok_lowfreq = calibration_parts.complex_division(pipeline, strain_rms_lowfreq, clean_strain_rms_lowfreq)
	clean_hoft_ok_lowfreq = pipeparts.mkbitvectorgen(pipeline, clean_hoft_ok_lowfreq, bit_vector=pow(2,25), threshold=1.0)
	clean_hoft_ok_lowfreq = pipeparts.mkcapsfilter(pipeline, clean_hoft_ok_lowfreq, calibstate_caps)

	# Compute the RMS of the uncleaned strain in a mid-frequency range to test subtraction of noise and/or the ~300 Hz pcal line
	strain_rms_midfreq = calibration_parts.compute_rms(pipeline, straintee, mid_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_mid_min, f_max = cleaning_check_range_mid_max, filter_latency = filter_latency_factor, rate_out = calibstate_sr, td = td)
	# Compute the RMS of the cleaned strain in a mid-frequency range
	clean_strain_rms_midfreq = calibration_parts.compute_rms(pipeline, clean_straintee, mid_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_mid_min, f_max = cleaning_check_range_mid_max, filter_latency = filter_latency_factor, rate_out = calibstate_sr, td = td)
	# Require that ratio RMS(strain) / RMS(clean_strain) > 1.0
	clean_hoft_ok_midfreq = calibration_parts.complex_division(pipeline, strain_rms_midfreq, clean_strain_rms_midfreq)
	clean_hoft_ok_midfreq = pipeparts.mkbitvectorgen(pipeline, clean_hoft_ok_midfreq, bit_vector=pow(2,26), threshold=1.0)
	clean_hoft_ok_midfreq = pipeparts.mkcapsfilter(pipeline, clean_hoft_ok_midfreq, calibstate_caps)

	# Add these into the CALIB_STATE_VECTOR
	calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, clean_hoft_ok_lowfreq, clean_hoft_ok_midfreq))

#
# Produce time-dependent correction factors to be recorded in the frames
#

record_kappa_caps = "audio/x-raw, format=F32LE, rate=%d" % record_factors_sr

# Resample the \kappa_tst channels at the specified recording sample rate and change them to single precision channels
if compute_kappatst:

	ktstRout = pipeparts.mkaudioconvert(pipeline, smooth_ktstRtee)
	ktstRout = calibration_parts.mkresample(pipeline, ktstRout, 1, False, record_kappa_caps)
	ktstRout = pipeparts.mkprogressreport(pipeline, ktstRout, "progress_kappa_tst_real_%s" % instrument)

	ktstIout = pipeparts.mkaudioconvert(pipeline, smooth_ktstItee)
	ktstIout = calibration_parts.mkresample(pipeline, ktstIout, 1, False, record_kappa_caps)
	ktstIout = pipeparts.mkprogressreport(pipeline, ktstIout, "progress_kappa_tst_imag_%s" % instrument)

	smooth_ktstR_nogate = pipeparts.mkaudioconvert(pipeline, smooth_ktstR_nogate)
	smooth_ktstR_nogate = calibration_parts.mkresample(pipeline, smooth_ktstR_nogate, 1, False, record_kappa_caps)
	smooth_ktstR_nogate = pipeparts.mkprogressreport(pipeline, smooth_ktstR_nogate, "progress_kappa_tst_real_nogate_%s" % instrument)

	smooth_ktstI_nogate = pipeparts.mkaudioconvert(pipeline, smooth_ktstI_nogate)
	smooth_ktstI_nogate = calibration_parts.mkresample(pipeline, smooth_ktstI_nogate, 1, False, record_kappa_caps)
	smooth_ktstI_nogate = pipeparts.mkprogressreport(pipeline, smooth_ktstI_nogate, "progress_kappa_tst_imag_nogate_%s" % instrument)

# Resample the \kappa_pum channels at the specified recording sample rate and change them to single precision channels
if compute_kappapum:

	kpumRout = pipeparts.mkaudioconvert(pipeline, smooth_kpumRtee)
	kpumRout = calibration_parts.mkresample(pipeline, kpumRout, 1, False, record_kappa_caps)
	kpumRout = pipeparts.mkprogressreport(pipeline, kpumRout, "progress_kappa_pum_real_%s" % instrument)

	kpumIout = pipeparts.mkaudioconvert(pipeline, smooth_kpumItee)
	kpumIout = calibration_parts.mkresample(pipeline, kpumIout, 1, False, record_kappa_caps)
	kpumIout = pipeparts.mkprogressreport(pipeline, kpumIout, "progress_kappa_pum_imag_%s" % instrument)

	smooth_kpumR_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kpumR_nogate)
	smooth_kpumR_nogate = calibration_parts.mkresample(pipeline, smooth_kpumR_nogate, 1, False, record_kappa_caps)
	smooth_kpumR_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpumR_nogate, "progress_kappa_pum_real_nogate_%s" % instrument)

	smooth_kpumI_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kpumI_nogate)
	smooth_kpumI_nogate = calibration_parts.mkresample(pipeline, smooth_kpumI_nogate, 1, False, record_kappa_caps)
	smooth_kpumI_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpumI_nogate, "progress_kappa_pum_imag_nogate_%s" % instrument)

# Resample the \kappa_uim channels at the specified recording sample rate and change them to single precision channels
if compute_kappauim:

	kuimRout = pipeparts.mkaudioconvert(pipeline, smooth_kuimRtee)
	kuimRout = calibration_parts.mkresample(pipeline, kuimRout, 1, False, record_kappa_caps)
	kuimRout = pipeparts.mkprogressreport(pipeline, kuimRout, "progress_kappa_uim_real_%s" % instrument)

	kuimIout = pipeparts.mkaudioconvert(pipeline, smooth_kuimItee)
	kuimIout = calibration_parts.mkresample(pipeline, kuimIout, 1, False, record_kappa_caps)
	kuimIout = pipeparts.mkprogressreport(pipeline, kuimIout, "progress_kappa_uim_imag_%s" % instrument)

	smooth_kuimR_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kuimR_nogate)
	smooth_kuimR_nogate = calibration_parts.mkresample(pipeline, smooth_kuimR_nogate, 1, False, record_kappa_caps)
	smooth_kuimR_nogate = pipeparts.mkprogressreport(pipeline, smooth_kuimR_nogate, "progress_kappa_uim_real_nogate_%s" % instrument)

	smooth_kuimI_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kuimI_nogate)
	smooth_kuimI_nogate = calibration_parts.mkresample(pipeline, smooth_kuimI_nogate, 1, False, record_kappa_caps)
	smooth_kuimI_nogate = pipeparts.mkprogressreport(pipeline, smooth_kuimI_nogate, "progress_kappa_uim_imag_nogate_%s" % instrument)

# Resample the \kappa_pu channels at the specified recording sample rate and change them to single precision channels
if compute_kappapu:

	kpuRout = pipeparts.mkaudioconvert(pipeline, smooth_kpuRtee)
	kpuRout = calibration_parts.mkresample(pipeline, kpuRout, 1, False, record_kappa_caps)
	kpuRout = pipeparts.mkprogressreport(pipeline, kpuRout, "progress_kappa_pu_real_%s" % instrument)

	kpuIout = pipeparts.mkaudioconvert(pipeline, smooth_kpuItee)
	kpuIout = calibration_parts.mkresample(pipeline, kpuIout, 1, False, record_kappa_caps)
	kpuIout = pipeparts.mkprogressreport(pipeline, kpuIout, "progress_kappa_pu_imag_%s" % instrument)

	smooth_kpuR_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kpuR_nogate)
	smooth_kpuR_nogate = calibration_parts.mkresample(pipeline, smooth_kpuR_nogate, 1, False, record_kappa_caps)
	smooth_kpuR_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpuR_nogate, "progress_kappa_pu_real_nogate_%s" % instrument)

	smooth_kpuI_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kpuI_nogate)
	smooth_kpuI_nogate = calibration_parts.mkresample(pipeline, smooth_kpuI_nogate, 1, False, record_kappa_caps)
	smooth_kpuI_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpuI_nogate, "progress_kappa_pu_imag_nogate_%s" % instrument)

# Resample the \kappa_c channels at the specified recording sample rate and change it to a single precision channel
if compute_kappac:
	kcout = pipeparts.mkaudioconvert(pipeline, smooth_kctee)
	kcout = calibration_parts.mkresample(pipeline, kcout, 1, False, record_kappa_caps)
	kcout = pipeparts.mkprogressreport(pipeline, kcout, "progress_kappa_c_%s" % instrument)

	smooth_kc_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kc_nogate)
	smooth_kc_nogate = calibration_parts.mkresample(pipeline, smooth_kc_nogate, 1, False, record_kappa_caps)
	smooth_kc_nogate = pipeparts.mkprogressreport(pipeline, smooth_kc_nogate, "progress_kappa_c_nogate_%s" % instrument)

# Resample the f_cc channels at the specified recording sample rate and change it to a single precision channel
if compute_fcc:
	fccout = pipeparts.mkaudioconvert(pipeline, smooth_fcctee)
	fccout = calibration_parts.mkresample(pipeline, fccout, 1, False, record_kappa_caps)
	fccout = pipeparts.mkprogressreport(pipeline, fccout, "progress_f_cc_%s" % instrument)

	smooth_fcc_nogate = pipeparts.mkaudioconvert(pipeline, smooth_fcc_nogate)
	smooth_fcc_nogate = calibration_parts.mkresample(pipeline, smooth_fcc_nogate, 1, False, record_kappa_caps)
	smooth_fcc_nogate = pipeparts.mkprogressreport(pipeline, smooth_fcc_nogate, "progress_f_cc_nogate_%s" % instrument)

# Resample the f_s channels at the specified recording sample rate and change it to a single precision channel
if compute_fs:
	fsout = pipeparts.mkaudioconvert(pipeline, smooth_fs)
	fsout = calibration_parts.mkresample(pipeline, fsout, 1, False, record_kappa_caps)
	fsout = pipeparts.mkprogressreport(pipeline, fsout, "progress_f_s_%s" % instrument)

	smooth_fs_nogate = pipeparts.mkaudioconvert(pipeline, smooth_fs_nogate)
	smooth_fs_nogate = calibration_parts.mkresample(pipeline, smooth_fs_nogate, 1, False, record_kappa_caps)
	smooth_fs_nogate = pipeparts.mkprogressreport(pipeline, smooth_fs_nogate, "progress_f_s_nogate_%s" % instrument)

# Resample the f_s channels at the specified recording sample rate and change it to a single precision channel
if compute_srcq:
	srcQ_inv_out = pipeparts.mkaudioconvert(pipeline, smooth_srcQ_inv)
	srcQ_inv_out = calibration_parts.mkresample(pipeline, srcQ_inv_out, 1, False, record_kappa_caps)
	srcQ_inv_out = pipeparts.mkprogressreport(pipeline, srcQ_inv_out, "progress_SRC_Q_%s" % instrument)

	smooth_srcQ_inv_nogate = pipeparts.mkaudioconvert(pipeline, smooth_srcQ_inv_nogate)
	smooth_srcQ_inv_nogate = calibration_parts.mkresample(pipeline, smooth_srcQ_inv_nogate, 1, False, record_kappa_caps)
	smooth_srcQ_inv_nogate = pipeparts.mkprogressreport(pipeline, smooth_srcQ_inv_nogate, "progress_SRC_Q_nogate_%s" % instrument)

#
# CREATE MUXER AND HOOK EVERYTHING UP TO IT
#

mux = pipeparts.mkframecppchannelmux(pipeline, None)

mux.set_property("frame-duration", options.frame_duration)
mux.set_property("frames-per-file", options.frames_per_file)
mux.set_property("compression-scheme", int(OutputConfigs["compressionscheme"]))
mux.set_property("compression-level", int(OutputConfigs["compressionscheme"]))

# Link the output DQ vectors up to the muxer, if applicable
if compute_calib_statevector:
	calibration_parts.mkqueue(pipeline, calibstatevector).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STATE_VECTOR%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, odcstatevectortee).get_static_pad("src").link(mux.get_request_pad("%s:%s" % (instrument, ChannelNames["inputdqchannel"])))

# Link the strain branch to the muxer
calibration_parts.mkqueue(pipeline, strain).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STRAIN%s" % (instrument, chan_prefix, chan_suffix)))

# Link the cleaned strain branch to the muxer if h(t) was cleaned in any way
if remove_cal_lines or remove_power_lines or witness_channel_list is not None:
	calibration_parts.mkqueue(pipeline, clean_strain).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STRAIN_CLEAN%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of kappa_tst to the muxer
if compute_kappatst:
	calibration_parts.mkqueue(pipeline, ktstRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, ktstIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_ktstR_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_ktstI_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of kappa_pum to the muxer
if compute_kappapum:
	calibration_parts.mkqueue(pipeline, kpumRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PUM_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, kpumIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PUM_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kpumR_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PUM_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kpumI_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PUM_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of kappa_uim to the muxer
if compute_kappauim:
	calibration_parts.mkqueue(pipeline, kuimRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_UIM_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, kuimIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_UIM_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kuimR_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_UIM_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kuimI_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_UIM_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of kappa_pu to the muxer
if compute_kappapu:
	calibration_parts.mkqueue(pipeline, kpuRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, kpuIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kpuR_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kpuI_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the \kappa_c to the muxer
if compute_kappac:
	calibration_parts.mkqueue(pipeline, kcout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_C%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kc_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_C_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the f_cc to the muxer
if compute_fcc:
	calibration_parts.mkqueue(pipeline, fccout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_CC%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_fcc_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_CC_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the f_s to the muxer
if compute_fs:
	calibration_parts.mkqueue(pipeline, fsout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_S%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_fs_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_S_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the src_Q to the muxer
if compute_srcq:
	calibration_parts.mkqueue(pipeline, srcQ_inv_out).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_SRC_Q_INVERSE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_srcQ_inv_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_SRC_Q_INVERSE_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Check that all frames are long enough, that they have all of the channels by requring a certain amount of time from start-up, and that frames aren't written for times requested by the wings option
def check_complete_frames(pad, info, (output_start, frame_duration, wings_start, wings_end)):
	if verbose:
		print("Checking if frames are complete")
	buf = info.get_buffer()
	startts = lal.LIGOTimeGPS(0, buf.pts)
	duration = lal.LIGOTimeGPS(0, buf.duration)
	if not (startts % frame_duration == 0):
		if verbose:
			print("Dropping frame because it is not an integer multiple of frame duration")
		return Gst.PadProbeReturn.DROP
	if startts < output_start:
		if verbose:
			print("Dropping frame because start time %f is less than desired output start time %f" % (startts, output_start))
		return Gst.PadProbeReturn.DROP
	if duration != frame_duration:
		if verbose:
			print("Dropping frame because the duration %d is not equal to the required frame duration %d" % (duration, frame_duration))
		return Gst.PadProbeReturn.DROP
	if wings_start is not None and wings_end is not None:
		if startts < wings_start or (startts+duration) > wings_end:
			if verbose:
				print("Dropping frame because it lies outside of the wings time")
			return Gst.PadProbeReturn.DROP
	return Gst.PadProbeReturn.OK
if InputConfigs["datasource"] == "frames":
	start = gps_start_time
elif InputConfigs["datasource"] == "lvshm":
	tm = time.gmtime()
	start = int(lal.UTCToGPS(tm))
# start time of first frame file is the desired start time + either filter latency or kappa settling (if computing kappas), whichever is bigger
if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
	output_start = start + max(int(filter_settle_time), demodulation_filter_time + int(TDCFConfigs["mediansmoothingtime"]) + int(TDCFConfigs["tdcfaveragingtime"]))
else:
	output_start = start + int(filter_settle_time)

# If the wings option is set, need to also check that frames aren't written during the requested wing time
wings = int(options.wings)
if wings != 0:
	wings_start = gps_start_time + wings
	wings_end = gps_end_time - wings
	mux.get_static_pad("src").add_probe(Gst.PadProbeType.BUFFER, check_complete_frames, (lal.LIGOTimeGPS(output_start,0), lal.LIGOTimeGPS(options.frame_duration*options.frames_per_file,0), lal.LIGOTimeGPS(wings_start, 0), lal.LIGOTimeGPS(wings_end, 0)))
else:
	mux.get_static_pad("src").add_probe(Gst.PadProbeType.BUFFER, check_complete_frames, (lal.LIGOTimeGPS(output_start,0), lal.LIGOTimeGPS(options.frame_duration*options.frames_per_file,0), None, None))

mux = pipeparts.mkprogressreport(pipeline, mux, "progress_sink_%s" % instrument)

if Config.getboolean("DebuggingConfigurations", "testlatency"):
	mux = pipeparts.mkgeneric(pipeline, mux, "splitcounter", filename = "gstlal_compute_strain_timestamps_out.txt")

if OutputConfigs["datasink"] == "lvshm":
	pipeparts.mkgeneric(pipeline, mux, "gds_lvshmsink", sync=False, async=False, shm_name = OutputConfigs["outputshmpartition"], num_buffers = int(OutputConfigs["numbuffers"]), blocksize = int(OutputConfigs["framesize"])*options.frame_duration*options.frames_per_file, buffer_mode = int(OutputConfigs["buffermode"]))
elif OutputConfigs["datasink"] == "frames":
	pipeparts.mkframecppfilesink(pipeline, mux, frame_type = OutputConfigs["frametype"], path = OutputConfigs["outputpath"], instrument = instrument) 

# Run pipeline

if DebuggingConfigs["pipelinegraphfilename"] != "None":
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(DebuggingConfigs["pipelinegraphfilename"], "NULL"), verbose = verbose)

# Seek the pipeline when necessary
if InputConfigs["datasource"] == "frames":
	if verbose:
		print >>sys.stderr, "seeking GPS start and stop times ..."
	if pipeline.set_state(Gst.State.READY) != Gst.StateChangeReturn.SUCCESS:
		raise RuntimeError("pipeline failed to enter READY state")
	datasource.pipeline_seek_for_gps(pipeline, gps_start_time, gps_end_time)

if verbose:
	print >>sys.stderr, "setting pipeline state to playing ..."
if pipeline.set_state(Gst.State.PLAYING) != Gst.StateChangeReturn.SUCCESS:
	raise RuntimeError("pipeline failed to enter PLAYING state")
else:
	if verbose:
		print "set to playing successfully"
if DebuggingConfigs["pipelinegraphfilename"] != "None":
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(DebuggingConfigs["pipelinegraphfilename"], "PLAYING"), verbose = verbose)
	
if verbose:
	print >>sys.stderr, "running pipeline ..."

mainloop.run()

if pipeline.set_state(Gst.State.NULL) != Gst.StateChangeReturn.SUCCESS:
	raise RuntimeError("pipeline could not be set to NULL")
