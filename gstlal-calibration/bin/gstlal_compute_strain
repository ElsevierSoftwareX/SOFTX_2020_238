#!/usr/bin/env python
#
# Copyright (C) 2010-2015  Jordi Burguet-Castell, Madeline Wade, Aaron Viets
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


"""
This pipeline produces h(t) given DARM_ERR and DARM_CTRL or given DELTAL_RESIDUAL and DELTAL_CTRL. It can be run online in real-time or offline on frame files.  It can write h(t) frames to frame files or to a shared memory partition.  

The differential arm length resulting from external sources is

\Delta L_{ext} = d_{err}/(\kappa_c C) + (A_tst * \kappa_tst + A_pu * \kappa_pu) d_{ctrl}

where C is the sensing function, A_tst is the TST acutuation function, A_pu is the PUM+UIM actuation, \kappa_c is the time dependent gain of the sensing function, \kappa_tst is the time-dependent gain of TST actuation, and \kappa_pu is the time-dependent gain of the PUM/UIM actuation.  \Delta L_{ext} is divided by the average arm length (4000 km) to obtain h(t), the external strain in the detectors,

h(t) = \Delta L_{ext} / L .

The time-dependent gains (\kappa's) as well as the value for the coupled cavity pole (f_cc) and SRC detuning parameters are calcuated in this pipeline as well.

This pipeline will most often be run in a format where it picks up after part of the actuation and sensing functions have been applied to the apporiate channels.  In this mode, the input channels are \Delta L_{res} and \Delta L_{ctrl, i}.  This pipeline then applies further high frequency corrections to each of these channels, applies the appropriate time delay to each channel, adds the channels together, and divides by L.

h(t) = (\Delta L_{res} * (1 / \kappa_c) * corrections + (\Delta L_{ctrl, TST} * \kappa_tst + (\Delta L_{ctrl, P} + \Delta L_{ctrl, U})* \kappa_pu) * corrections) / L

Note: The \kappa's are complex numbers.  Only the real part of the computed \kappa's are applied as time-dependent gain corrections.

Further documentation explaining the time domain calibration procedure can be found in LIGO DCC #T1400256 and #P1700236.

For a full list of example command lines that were used to create the O1 h(t) frames, see https://wiki.ligo.org/Calibration/GDSCalibrationConfigurationsO1.

Type gstlal_compute_strain --help to see the full list of command line options.
"""

import sys
import numpy
import time
import resource

from optparse import OptionParser, Option

import gi
gi.require_version('Gst', '1.0')
from gi.repository import GObject, Gst
GObject.threads_init()
Gst.init(None)

import lal

from gstlal import pipeparts
from gstlal import calibration_parts
from gstlal import simplehandler
from gstlal import datasource

from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
from glue.ligolw.utils import segments as ligolw_segments
array.use_in(ligolw.LIGOLWContentHandler)
param.use_in(ligolw.LIGOLWContentHandler)
from glue.ligolw import utils
from glue import segments

#
# Function definition for writing pipeline graph
#

def write_graph(demux):
	pipeparts.write_dump_dot(pipeline, "%s.%s" % (options.write_pipeline, "PLAYING"), verbose = True)

#
# Make sure we have sufficient resources
# We allocate far more memory than we need, so this is okay
#

def setrlimit(res, lim):
	hard_lim = resource.getrlimit(res)[1]
	resource.setrlimit(res, (lim if lim is not None else hard_lim, hard_lim))
# set the number of processes and total set size up to hard limit and
# shrink the per-thread stack size (default is 10 MiB)
setrlimit(resource.RLIMIT_NPROC, None)
setrlimit(resource.RLIMIT_AS, None)
setrlimit(resource.RLIMIT_RSS, None)
setrlimit(resource.RLIMIT_STACK, 1024*1024)

#
# Function definition to obtain the current GPS time
#

def now():
	return lal.LIGOTimeGPS(lal.UTCToGPS(time.gmtime()), 0)
	

#
# Function to update FIR matrix property
#

def fir_matrix_update(elem, arg, filtered):
	filtered.set_property("kernel", elem.get_property("fir_matrix")[0][::-1])
	print("fir matrix updated")

###################################################################################################
############################## Program Command Line Options #######################################
###################################################################################################

parser = OptionParser(description = __doc__)

# Append program specific options

# These options should be used whether the pipeline runs in full calibration mode or partial calibration mode
parser.add_option("--data-source", metavar = "source", help = "Set the data source from [frames|lvshm]. Required.")
parser.add_option("--frame-cache", metavar = "filename", help = "Set the name of the LAL cache listing the LIGO .gwf frame files (optional).  This is required iff --data-source=frames")
parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the start time of the segment to analyze in GPS seconds. This is required iff --data-source=frames")
parser.add_option("--gps-end-time", metavar = "seconds", help = "Set the end time of the segment to analyze in GPS seconds. This is required iff --data-source=frames")
parser.add_option("--wings", metavar = "seconds", type = "int", help = "Number of seconds to trim off of the beginning and end of the output. Should only be used if --data-source=frames.")
parser.add_option("--do-file-checksum", action = "store_true", help = "Set this option to turn on file checksum in the demuxer.")
parser.add_option("--dq-channel-name", metavar = "name", default = "ODC-MASTER_CHANNEL_OUT_DQ", help = "Set the name of the data quality (or state vector) channel. (Default=ODC-MASTER_CHANNEL_OUT_DQ)")
parser.add_option("--ifo", metavar = "name", help = "Name of the IFO to be calibrated.")
parser.add_option("--shared-memory-partition", metavar = "name", help = "Set the name of the shared memory partition to read from.  This is required iff --data-source=lvshm.")
parser.add_option("--frame-segments-file", metavar = "filename", help = "Set the name of the LIGO light-weight XML file from which to load frame segments.  This is required iff --data-source=frames")
parser.add_option("--frame-segments-name", metavar = "name", help = "Set the name of the segments to extract from the segment tables.  This is required iff --frame-segments-file is given")
parser.add_option("--hoft-sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate at which to generate strain data. This should be less than or equal to the sample rate of the error and control signal channels. (Default = 16384 Hz)")
parser.add_option("--control-sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate of the control signal channels. (Default = 16384 Hz)")
parser.add_option("--odc-sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate of the ODC state vector channel. (Default = 16384 Hz)")
parser.add_option("--calib-state-sample-rate", metavar = "Hz", default = 16, type = "int", help = "Sample rate for the outgoing DQ vector GDS-CALIB_STATE_VECTOR. (Default = 16 Hz)")
parser.add_option("--tst-exc-sample-rate", metavar = "Hz", default = 512, type = "int", help = "Sample rate for the control signals being read in. (Default = 512 Hz)")
parser.add_option("--coh-sample-rate", metavar = "Hz", default = 16, type = "int", help = "Sample rate for the coherence uncertainty channels. (Default = 16 Hz).")
parser.add_option("--buffer-length", metavar = "seconds", type = float, default = 1.0, help = "Set the length in seconds of buffers to be used in the pipeline (Default = 1.0)")
parser.add_option("--frame-duration", metavar = "seconds", type = "int", default = 4, help = "Set the number of seconds for each frame. (Default = 4)")
parser.add_option("--frames-per-file", metavar = "count", type = "int", default = 1, help = "Set the number of frames per frame file. (Default = 1)")
parser.add_option("--frame-size", metavar = "bytes", type = "int", default = 405338, help = "Approximate size in bytes of frame file images; used when writing to shared memory.  (Default=405338)")
parser.add_option("--compression-scheme", metavar = "scheme", type = "int", default = 256, help = "Set the compression scheme for the framecpp_channelmux element. (Default=256, no compression)")
parser.add_option("--compression-level", metavar = "level", type = "int", default = 0, help = "Set the compression level for the framecpp_channelmux element. (Default=0)")
parser.add_option("--write-to-shm-partition", metavar = "name", help = "Set the name of the shared memory partition to write to. If this is not provided, frames will be written to a file.")
parser.add_option("--buffer-mode", metavar = "number", type = "int", default = 2, help = "Set the buffer mode for the lvshmsink element. (Default=2)")
parser.add_option("--frame-type", metavar = "name", default = "TEST", help = "Set the frame type as input to the frame writing element. (Default=TEST)")
parser.add_option("--output-path", metavar = "name", default = ".", help = "Set the output path for writing frame files. (Default=Current)")
parser.add_option("--no-dq-vector", action = "store_true", help = "Set this if you want to turn off all interpretation and calculation of a data quality vector.")
parser.add_option("--frequency-domain-filtering", action = "store_true", help = "Set this to perform filtering routines in the frequency domain instead of using direct convolution.")
parser.add_option("--obs-ready-bitmask", metavar = "bitmask", type = "int", default = 4, help = "Bitmask used on ODC state vector in order to determine OBSERVATION_READY bit information. (Default=4)")
parser.add_option("--obs-intent-bitmask", metavar = "bitmask", type = "int", default = 2, help = "Bitmask used on ODC state vector in order to determine OBSERVATION_INTENT bit information. (Default=2)")
parser.add_option("--hw-inj-cbc-bitmask", metavar = "bitmask", type = "int", default = 16777216, help = "Bitmask used on ODC state vector in order presence of CBC hardware injection. (Default=16777216)")
parser.add_option("--hw-inj-burst-bitmask", metavar = "bitmask", type = "int", default = 33554432, help = "Bitmask used on ODC state vector in order presence of burst hardware injection. (Default=33554432)")
parser.add_option("--hw-inj-detchar-bitmask", metavar = "bitmask", type = "int", default = 67108864, help = "Bitmask used on ODC state vector in order presence of DetChar hardware injection. (Default=67108864)")
parser.add_option("--hw-inj-stoch-bitmask", metavar = "bitmask", type = "int", default = 8388608, help = "Bitmask used on ODC state vector in order presence of stochastic hardware injection. (Default=8388608)")
parser.add_option("--chan-prefix", metavar = "name", default = "GDS-", help = "Prefix for all output channel names. (Default = GDS)") 
parser.add_option("--chan-suffix", metavar = "name", help = "Suffix for all output channel names.") 

# These are debugging options
parser.add_option("--write-pipeline", metavar = "filename", help = "Write a DOT graph description of the as-built pipeline to this file (optional).  The environment variable GST_DEBUG_DUMP_DOT_DIR must be set for this option to work.")
parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")

# These are options specific to the calibration procedure
parser.add_option("--filters-file", metavar="filename", help = "Name of file containing filters (in npz format)")
parser.add_option("--factors-from-filters-file", action = "store_true", help = "Compute the calibration factors from reference values contained in the filters file instead of from EPICS channels.")
parser.add_option("--no-coherence", action = "store_true", help = "Gate the calibration factors with a pre-computed coherence channel.")
parser.add_option("--coherence-uncertainty-threshold", metavar = "float", type = float, default = 0.0025, help = "Threshold for the coherence uncertainty for each calibration line. (Default = 0.0025)")
parser.add_option("--coherence-time", metavar = "seconds", type = "int", default = 130, help = "Amount of time used in front end to compute coherence of calibration lines. (Default = 130)")
parser.add_option("--coh-unc-sus-line1-channel", metavar="name", default="CAL-CS_TDEP_SUS_LINE1_UNCERTAINTY", help = "Channel name for SUS line 1 coherence uncertainty. (Default=CAL-CS_TDEP_SUS_LINE1_UNCERTAINTY)")
parser.add_option("--coh-unc-pcaly-line1-channel", metavar="name", default="CAL-CS_TDEP_PCALY_LINE1_UNCERTAINTY", help = "Channel name for PCALY line 1 coherence uncertainty. (Default=CAL-CS_TDEP_PCALY_LINE1_UNCERTAINTY)")
parser.add_option("--coh-unc-pcaly-line2-channel", metavar="name", default="CAL-CS_TDEP_PCALY_LINE2_UNCERTAINTY", help = "Channel name for PCALY line 2 coherence uncertainty. (Default=CAL-CS_TDEP_PCALY_LINE2_UNCERTAINTY)")
parser.add_option("--coh-unc-darm-line1-channel", metavar="name", default="CAL-CS_TDEP_DARM_LINE1_UNCERTAINTY", help = "Channel name for DARM line 1 coherence uncertainty. (Default=CAL-CS_TDEP_DARM_LINE1_UNCERTAINTY)")
parser.add_option("--no-kappatst", action = "store_true", help = "Set this to turn off the calculation of \kappa_tst.")
parser.add_option("--no-kappapu", action = "store_true", help = "Set this to turn off the calculation of \kappa_pu.")
parser.add_option("--no-kappac", action = "store_true", help = "Set this to turn off the calculation of \kappa_c.")
parser.add_option("--no-fcc", action = "store_true", help = "Set this to turn off the calculation of f_cc.")
parser.add_option("--no-srcQ", action = "store_true", help = "Set this to turn off the calculation of the SRC Q.")
parser.add_option("--no-fs", action = "store_true", help = "Set this to turn off the calculation of the SRC spring frequency.")
parser.add_option("--factors-averaging-time", metavar = "Sec", type = int, default = 10, help = "Time over which to average the smoothed time-varying calibration factors (\kappas), given in seconds. (Default = 10 seconds)")
parser.add_option("--apply-kappapu", action = "store_true", help = "Set this to have the \kappa_pu factors multiply the actuation chain.")
parser.add_option("--apply-kappatst", action = "store_true", help = "Set this to have the \kappa_tst factors multiply the actuation chain.")
parser.add_option("--apply-kappac", action = "store_true", help = "Set this to have the \kappa_c factors multiply the sensing chain.")
parser.add_option("--apply-fcc", action = "store_true", help = "Set this to have the f_cc time-dependent, frequency-dependent corrections applied.")
parser.add_option("--compute-factors-sr", metavar = "Hz", type = int, default = 16, help = "Sample rate at which calibration factors are computed. (Default = 16 Hz)")
parser.add_option("--demodulation-filter-time", metavar = "s", type = int, default = 20, help = "Length in seconds of low-pass FIR filter used in demodulation of the calibration lines. (Default = 20 seconds)")
parser.add_option("--median-smoothing-time", metavar = "s", type = int, default = 128, help = "Time (in seconds) to smooth out \kappas with a median-like method. (Default = 128 s)")
parser.add_option("--kappas-default-to-median", action = "store_true", help = "If set, bad computed kappas will be replaced by the previous computed median in the running median array. Otherwise, they are replaced with the default value.")
parser.add_option("--filter-latency", metavar = "float", type = float, default = 0.0, help = "Latency of all filtering/averaging/median processes (other than calibration model filters) as a fraction of filter length. Value should be set between 0.0 and 1.0. (Default = 0.0)")
parser.add_option("--record-factors-sr", metavar = "Hz", type = int, default = 16, help = "Sample rate at which calibration factors are recorded. (Default = 16 Hz)")
parser.add_option("--expected-kappapu-real", metavar = "float", type = float, default = 1.0, help = "Expected value for the real part of \kappa_pu. (Default = 1.0)")
parser.add_option("--expected-kappatst-real", metavar = "float", type = float, default = 1.0, help = "Expected value for the real part of \kappa_tst. (Default = 1.0)")
parser.add_option("--expected-kappapu-imag", metavar = "float", type = float, default = 0.0, help = "Expected value for the imaginary part of \kappa_pu. (Default = 0.0)")
parser.add_option("--expected-kappatst-imag", metavar = "float", type = float, default = 0.0, help = "Expected value for the imaginary part of \kappa_tst. (Default = 0.0)")
parser.add_option("--expected-kappac", metavar = "float", type = float, default = 1.0, help = "Expected value for \kappa_c. (Default = 1.0)")
parser.add_option("--expected-fcc", metavar = "Hz", type = float, default = 360.0, help = "Expected value for the coupled cavity pole. (Default = 360.0 Hz)")
parser.add_option("--expected-fs", metavar = "Hz", type = float, default = 8.0, help = "Expected value for the SRC optical spring frequency. (Default = 8.0 Hz)")
parser.add_option("--expected-srcQ", metavar = "float", type = float, default = 28.0, help = "Expected value for the SRC Q. (Default = 28.0)")
parser.add_option("--kappapu-real-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of the real part of \kappa_pu +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--kappatst-real-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of the real part of \kappa_tst +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--kappapu-imag-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of the imaginary part of \kappa_pu +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--kappatst-imag-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of the imaginary part of \kappa_tst +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--kappac-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of \kappa_c +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--fcc-ok-var", metavar = "Hz", type = float, default = 50, help = "Values of f_cc +/- this number (in Hz) will be considered OK. (Default = 50 Hz)")
parser.add_option("--fs-ok-var", metavar = "Hz", type = float, default = 10, help = "Values of SRC spring frequency +/- this number (in Hz) will be considered OK. (Default = 10 Hz)")
parser.add_option("--srcQ-ok-var", metavar = "float", type = float, default = 20.0, help = "Values of SRC Q +/- this number will be considered OK. (Default = 20)")
parser.add_option("--exc-channel-name", metavar = "name", default = "CAL-CS_LINE_SUM_DQ", help = "Set the name of the excitation channel.  This is only necessary when the calibration factors computation is turned on, which is the default behavior. (Default = CAL-CS_LINE_SUM_DQ)")
parser.add_option("--tst-exc-channel-name", metavar = "name", default = "SUS-ETMY_L3_CAL_LINE_OUT_DQ", help = "Set the name of the TST excitation channel.  This is only necessary when the \kappa_tst factors computation is turned on, which is the default behavior. (Default = SUS-ETMY_L3_CAL_LINE_OUT_DQ)")
parser.add_option("--pcal-channel-name", metavar = "name", default = "CAL-PCALY_RX_PD_OUT_DQ", help = "Set the name of the PCal channel used for calculating the calibration factors. (Default = CAL-PCALY_RX_PD_OUT_DQ)")
parser.add_option("--dewhitening", action = "store_true", help = "Dewhitening should be used on the relevant channels, since the incoming channels are whitened and single precision.")
parser.add_option("--update-fcc", action = "store_true", help = "Update the cavity pole filter with time.")
parser.add_option("--fcc-filter-duration", metavar = "seconds", default = 1.0, type = float, help = "Duration of the cavity pole FIR filter. (Default = 0.01 seconds)")
parser.add_option("--fcc-averaging-time", metavar = "seconds", type = float, default = 60, help = "Length of time (in seconds) between when cavity pole FIR filter is updated.  The computed cavity pole values are averaged between the update intervals in order to obtain the cavity pole value used to compute the new FIR filter. (Default = 60 seconds)")
parser.add_option("--fcc-filter-taper-length", metavar = "samples", type = int, default = 32768, help = "Number of samples to be used when tapering old filter and ramping in new filter. (Default = 32768)")

# These are all options related to the reference channels used in the calibration factors computation
parser.add_option("--ref-channels-sr", metavar = "Hz", default = 16, help = "Set the sample rate for the reference model channels used in the calibration factors calculation. (Default = 16 Hz)")
parser.add_option("--EP4-real", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_TST_REAL", help = "Set the name of the channel containing the real part of A_tst at the ESD line used for the \kappa_a and \kappa_pu calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_TST_REAL)")
parser.add_option("--EP5-real", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_REAL", help = "Set the name of the channel containing the real part of A_pu at the ESD line used for the \kappa_a calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_REAL)")
parser.add_option("--EP3-real", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_REAL", help = "Set the name of the channel containing the real part of 1/A_pu at the ESD line used for the \kappa_pu calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_REAL)")
parser.add_option("--EP4-imag", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_TST_IMAG", help = "Set the name of the channel containing the imaginary part of A_tst at the ESD line used for the \kappa_a and \kappa_pu calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_TST_IMAG")
parser.add_option("--EP5-imag", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_IMAG", help = "Set the name of the channel containing the imaginary part of A_pu at the ESD line used for the \kappa_A calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_IMAG")
parser.add_option("--EP3-imag", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_IMAG", help = "Set the name of the channel containing the imaginary part of 1/A_pu at the ESD line used for the \kappa_PU calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_IMAG")
parser.add_option("--EP2-real", metavar = "name", default = "CAL-CS_TDEP_REF_CLGRATIO_CTRL_REAL", help = "Set the name of the channel containing the real part of the factors used to compute A(f_ctrl). (Default = CAL-CS_TDEP_REF_CLGRATIO_CTRL_REAL)")
parser.add_option("--EP2-imag", metavar = "name", default = "CAL-CS_TDEP_REF_CLGRATIO_CTRL_IMAG", help = "Set the name of the channel containing the imaginary part of the factors used to compute A(f_ctrl). (Default = CAL-CS_TDEP_REF_CLGRATIO_CTRL_IMAG)")
parser.add_option("--EP6-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_REAL", help = "Set the name of the channel containing the real part of C_res at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_REAL")
parser.add_option("--EP6-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_IMAG", help = "Set the name of the channel containing the imaginary part of C_res at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_IMAG")
parser.add_option("--EP7-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_D_REAL", help = "Set the name of the channel containing the real part of D at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_D_REAL")
parser.add_option("--EP7-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_D_IMAG", help = "Set the name of the channel containing the imaginary part of D at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_D_IMAG")
parser.add_option("--EP8-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_REAL", help = "Set the name of the channel containing the real part of A_tst at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_REAL")
parser.add_option("--EP8-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_IMAG", help = "Set the name of the channel containing the imaginary part of A_tst at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_IMAG")
parser.add_option("--EP9-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_REAL", help = "Set the name of the channel containing the real part of A_pu at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_REAL")
parser.add_option("--EP9-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_IMAG", help = "Set the name of the channel containing the imaginary part of A_pu at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_IMAG")
parser.add_option("--EP1-real", metavar = "name", default = "CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_REAL", help = "Set the name of the channel containing the real part of the \kappa_tst reference factors. (Default = CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_REAL)")
parser.add_option("--EP1-imag", metavar = "name", default = "CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_IMAG", help = "Set the name of the channel containing the imaginary part of the \kappa_tst reference factors. (Default = CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_IMAG)")
parser.add_option("--EP10-real", metavar = "name", default = "CAL-CS_TDEP_ESD_LINE1_REF_A_TST_NOLOCK_REAL", help = "Set the name of the channel containing the real part of A_tst at the ESD line used for removal of the ESD line. (Default = CAL-CS_TDEP_ESD_LINE1_REF_A_TST_REAL")
parser.add_option("--EP10-imag", metavar = "name", default = "CAL-CS_TDEP_ESD_LINE1_REF_A_TST_NOLOCK_IMAG", help = "Set the name of the channel containing the imaginary part of A_tst at the ESD line used for removal of the ESD line. (Default = CAL-CS_TDEP_ESD_LINE1_REF_A_TST_IMAG")
parser.add_option("--EP11-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE4_REF_C_NOCAVPOLE_REAL", help = "Set the name of the channel containing the real part of C_res at the PCal line used for the src_Q and f_s calculation. (Default = CAL-CS_TDEP_PCALY_LINE4_REF_C_NOCAVPOLE_REAL")
parser.add_option("--EP11-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE4_REF_C_NOCAVPOLE_IMAG", help = "Set the name of the channel containing the imaginary part of C_res at the PCal line used for the src_Q and f_s calculation. (Default = CAL-CS_TDEP_PCALY_LINE4_REF_C_NOCAVPOLE_IMAG")
parser.add_option("--EP12-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE4_REF_D_REAL", help = "Set the name of the channel containing the real part of D at the PCal line used for the src_Q and f_s calculation. (Default = CAL-CS_TDEP_PCALY_LINE4_REF_D_REAL")
parser.add_option("--EP12-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE4_REF_D_IMAG", help = "Set the name of the channel containing the imaginary part of D at the PCal line used for the src_Q and f_s calculation. (Default = CAL-CS_TDEP_PCALY_LINE4_REF_D_IMAG")
parser.add_option("--EP13-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE4_REF_A_TST_REAL", help = "Set the name of the channel containing the real part of A_tst at the PCal line used for the src_Q and f_s calculation. (Default = CAL-CS_TDEP_PCALY_LINE4_REF_A_TST_REAL")
parser.add_option("--EP13-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE4_REF_A_TST_IMAG", help = "Set the name of the channel containing the imaginary part of A_tst at the PCal line used for the src_Q and f_s calculation. (Default = CAL-CS_TDEP_PCALY_LINE4_REF_A_TST_IMAG")
parser.add_option("--EP14-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE4_REF_A_USUM_REAL", help = "Set the name of the channel containing the real part of A_pu at the PCal line used for the src_Q and f_s calculation. (Default = CAL-CS_TDEP_PCALY_LINE4_REF_A_USUM_REAL")
parser.add_option("--EP14-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE4_REF_A_USUM_IMAG", help = "Set the name of the channel containing the imaginary part of A_pu at the PCal line used for the src_Q and f_s calculation. (Default = CAL-CS_TDEP_PCALY_LINE4_REF_A_USUM_IMAG")

# These options are related to noise subtraction
parser.add_option("--remove-DC", action = "store_true", help = "Set this option to remove the DC component from the residual and control channels before filtering.")
parser.add_option("--remove-callines", action = "store_true", help = "Set this option to subtract the calibration lines from the h(t) spectrum.")
parser.add_option("--remove-powerlines", action = "store_true", help = "Set this option to subtract the power mains lines from the h(t) spectrum.")
parser.add_option("--powerlines-channel-name", metavar = "name", default = "PEM-EY_MAINSMON_EBAY_1_DQ", help = "Set the name of the channel used as input for 60 Hz power lines to be removed. (Default = PEM-EY_MAINSMON_EBAY_1_DQ)")
parser.add_option("--powerlines-channel-sr", metavar = "Hz", type = int, default = 1024, help = "Sample rate of the powerlines channel (Default = 1024 Hz)")
parser.add_option("--powerlines-freq-var", metavar = "Hz", type = float, default = 0.02, help = "Amount by which freqency of the power mains varies with time. Supposedly they are intentionally varied by +- 0.02 Hz. (Default = 0.02)")
parser.add_option("--witness-channel-list", metavar = "name", default = None, help = "Comma-separated list of witness channels to use to subtract noise from h(t). (Default is to not use any witness channels.)")
parser.add_option("--witness-channel-sr", metavar = "Hz", type = int, default = 2048, help = "Sample rate at which transfer functions will be computed and witness channels will be filtered. (Default = 2048 Hz)")
parser.add_option("--cleaning-check-range-min", metavar = "Hz", type = int, default = 100, help = "Minimum of a range of frequencies in which we expect noise subtraction to be impactful. The HOFT_CLEAN_OK bit of the calibration state vector is determined based on whether rms amplitude of the cleaned data is less than that of uncleaned h(t) in this range. (Default = 100 Hz)")
parser.add_option("--cleaning-check-range-max", metavar = "Hz", type = int, default = 500, help = "Maximum of a range of frequencies in which we expect noise subtraction to be impactful. The HOFT_CLEAN_OK bit of the calibration state vector is determined based on whether rms amplitude of the cleaned data is less than that of uncleaned h(t) in this range. (Default = 500 Hz)")

# These options are specific to the full calibration mode
parser.add_option("--full-calibration", action = "store_true", help = "Set this to run the pipeline in full calibration mode.")
parser.add_option("--darm-ctrl-channel-name", metavar = "name", default = "CAL-DARM_CTRL_WHITEN_OUT_DBL_DQ", help = "Set the name for the control signal channel. (Default = CAL-DARM_CTRL_WHTIEN_OUT_DBL_DQ)")
parser.add_option("--darm-err-channel-name", metavar = "name", default = "CAL-DARM_ERR_WHITEN_OUT_DBL_DQ", help = "Set the name of the error signal channel. (Default = CAL-DARM_ERR_WHITEN_OUT_DBL_DQ)")

# These options are specific to the partial calibration mode
parser.add_option("--partial-calibration", action = "store_true", help = "Set this to run the pipeline in partial calibraiton mode.")
parser.add_option("--deltal-tst-channel-name", metavar = "name", default = "CAL-DELTAL_CTRL_TST_DBL_DQ", help = "Set the name of the partially calibrated control channel for the TST branch of the actuation. (Default = CAL-DELTAL_CTRL_TST_DBL_DQ)")
parser.add_option("--deltal-pum-channel-name", metavar = "name", default = "CAL-DELTAL_CTRL_PUM_DBL_DQ", help = "Set the name of the partially calibrated control channel for the PUM/UIM branch of the actuation. (Default = CAL-DELTAL_CTRL_PUM_DBL_DQ)")
parser.add_option("--deltal-uim-channel-name", metavar = "name", default = "CAL-DELTAL_CTRL_UIM_DBL_DQ", help = "Set the name of the partially calibrated control channel for the PUM/UIM branch of the actuation. (Default = CAL-DELTAL_CTRL_UIM_DBL_DQ)")
parser.add_option("--deltal-res-channel-name", metavar = "name", default = "CAL-DELTAL_RESIDUAL_DBL_DQ", help = "Set the name of the partially calibrated residual channel. (Default = CAL-DELTAL_RESIDUAL_DBL_DQ).")

# Parse options

options, filenames = parser.parse_args()

# Sanity checks for command line options
data_sources = set(("frames", "lvshm"))

if options.data_source not in data_sources:
	raise ValueError("--data-source must be one of %s" % ",".join(data_sources))

if options.data_source == "frames" and options.frame_cache is None:
	raise ValueError("--frame-cache must be specified when using --data-source=frames")

if options.wings is not None and options.data_source != "frames":
	raise ValueError("--wings can only be set when --data-source=frames")

if options.ifo is None:
	raise ValueError("must specify --ifo")

if options.frame_segments_file is not None and options.data_source != "frames":
	raise ValueError("can only give --frame-segments-file if --data-source=frames")

if options.frame_segments_name is not None and options.frame_segments_file is None:
	raise ValueError("can only specify --frame-segments-name if --frame-segments-file is given")

if options.data_source == "frames" and (options.gps_start_time is None or options.gps_end_time is None):
	raise ValueError("must specify --gps-start-time and --gps-end-time when --data-source=frames")

if options.full_calibration is None and options.partial_calibration is None or (options.full_calibration is not None and options.partial_calibration is not None):
	raise ValueError("must specify one (and only one) mode of the pipeline: either --full-calibration or --partial-calibration")

if int(options.record_factors_sr) > int(options.compute_factors_sr):
	raise ValueError("--record-factors-sr must be less than or equal to --compute-factors-sr")

if not options.factors_from_filters_file and (not options.no_fs or not options.no_srcQ) and ((options.data_source == "frames" and int(options.gps_start_time) < 1175954418) or (options.data_source == "lvshm" and now() < 1175954418)):
	raise ValueError("Cannot compute SRC detuning parameters as the needed EPICS channels are not in the frames until GPS time 1175954418. Use command line options --no-srcQ and --no-fs.")

if options.gps_start_time is not None:
	if options.gps_end_time is None:
		raise ValueError("must provide both --gps-start-time and --gps-end-time")
	if options.data_source == "lvshm" or options.data_source == "white":
		raise ValueError("cannot set --gps-start-time or --gps-end-time with --data-source=lvshm or --data-source=white")
	try:
		start = lal.LIGOTimeGPS(options.gps_start_time)
	except ValueError:
		raise ValueError("invalid --gps-start-time %s" % options.gps_start_time)
	try:
		end = lal.LIGOTimeGPS(options.gps_end_time)
	except ValueError:
		raise ValueError("invalid --gps-end-time %s" % options.gps_end_time)
	if start >= end:
		raise ValueError("--gps-start-time must be < --gps-end-time: %s < %s" % (options.gps_start_time, options.gps_end_time))
	# segment from gps start and stop time if given
	seg = segments.segment(start, end)
	gps_start_time = seg[0]
	gps_end_time = seg[1]
elif options.gps_end_time is not None:
	raise ValueError("must provide both --gps-start-time and --gps-end-time")

###################################################################################################
######################################## Setup ####################################################
###################################################################################################

# Set up instrument and channel name info from command line options
instrument = options.ifo

# Make segment list if a frame segments file is provided, other set frame_segments to None
if options.frame_segments_file is not None:
	# Frame segments from a user defined file
	frame_segments = ligolw_segments.segmenttable_get_by_name(utils.load_filename(options.frame_segments_file, contenthandler = datasource.ContentHandler), options.frame_segments_name).coalesce()
	if seg is not None:
		# clip frame segments to seek segment if it exists (not required, just saves some meory and I/O overhead)
		frame_segments = segments.segmentlistdict((instrument, seglist & segments.segmentlist([seg])) for instrument, seglist in frame_segments.items())
else:
	frame_segments = None

# Set up short-cut names for each of the sample rates used throughout the pipeline and establish caps string shortcuts
hoftsr = options.hoft_sample_rate  # Sample rate for h(t)
calibstatesr = options.calib_state_sample_rate  # Sample rate for the CALIB_STATE_VECTOR
odcsr = options.odc_sample_rate # Sample rate of the ODC channel that is read in
ctrlsr = options.control_sample_rate # Sample rate of the control channel (such as DARM_CTRL or DELTAL_CTRL)
cohsr = options.coh_sample_rate # Sample rate for the coherence uncertainty channels
hoft_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % hoftsr
ctrl_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % ctrlsr
calibstate_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % calibstatesr
odc_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % odcsr
coh_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % cohsr
# caps strings for the computation kappas
ref_factors_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % options.ref_channels_sr
compute_calib_factors_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0X0" % options.compute_factors_sr
compute_calib_factors_complex_caps = "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % options.compute_factors_sr

# Set up smoothing, averaging and integration sample sizes for kappa calulations
integration_samples = int(options.demodulation_filter_time) * options.compute_factors_sr
factors_average_samples = int(options.factors_averaging_time) * options.compute_factors_sr
median_smoothing_samples = int(options.median_smoothing_time) * options.compute_factors_sr
kappa_gate_attack_length = -integration_samples * (1.0 - options.filter_latency)
kappa_gate_hold_length = -integration_samples * options.filter_latency - (options.filter_latency != 0) * options.coherence_time * options.compute_factors_sr

# Set up string for the channels suffix and prefix as provided by the user
if options.chan_suffix is not None:
	chan_suffix = options.chan_suffix
else:
	chan_suffix = ""
chan_prefix = options.chan_prefix

# If td is true we will perform filtering in the time domain (direct convolution) in all FIR filtering routines below
td = not options.frequency_domain_filtering

# If we are using EPICS from frames and removing calibration lines, we need EP10 to remove the ESD line. Otherwise, we just remove the other lines if possible.
if (not options.factors_from_filters_file) and options.remove_callines and (options.data_source == "lvshm" or (options.ifo == "H1" and int(options.gps_start_time) > 1175954418) or (options.ifo == "L1" and int(options.gps_start_time) > 1180184418)):
	remove_esd_act_line = True
elif not options.factors_from_filters_file:
	remove_esd_act_line = False

#
# Load in the filters file that contains filter coefficients, etc.
#

filters = numpy.load(options.filters_file)

# If we're reading the reference model factors from the filters file, load them
if options.factors_from_filters_file:
	EP1_real = float(filters["EP1_real"])
	EP1_imag = float(filters["EP1_imag"])
	EP2_real = float(filters["EP2_real"])
	EP2_imag = float(filters["EP2_imag"])
	EP3_real = float(filters["EP3_real"])
	EP3_imag = float(filters["EP3_imag"])
	EP4_real = float(filters["EP4_real"])
	EP4_imag = float(filters["EP4_imag"])
	EP5_real = float(filters["EP5_real"])
	EP5_imag = float(filters["EP5_imag"])
	EP6_real = float(filters["EP6_real"])
	EP6_imag = float(filters["EP6_imag"])
	EP7_real = float(filters["EP7_real"])
	EP7_imag = float(filters["EP7_imag"])
	EP8_real = float(filters["EP8_real"])
	EP8_imag = float(filters["EP8_imag"])
	EP9_real = float(filters["EP9_real"])
	EP9_imag = float(filters["EP9_imag"])
	try:
		EP10_real = float(filters["EP10_real"])
		EP10_imag = float(filters["EP10_imag"])
		remove_esd_act_line = True
	except:
		remove_esd_act_line = False
	try:
		EP11_real = float(filters["EP11_real"])
		EP11_imag = float(filters["EP11_imag"])
		EP12_real = float(filters["EP12_real"])
		EP12_imag = float(filters["EP12_imag"])
		EP13_real = float(filters["EP13_real"])
		EP13_imag = float(filters["EP13_imag"])
		EP14_real = float(filters["EP14_real"])
		EP14_imag = float(filters["EP14_imag"])
	except:
		if not options.no_srcQ or not options.no_fs:
			raise ValueError("Cannot compute SRC spring frequency or Q, as the needed EPICS are not contained in the specified filters file.")

# Load all of the kappa dewhitening and correction factors
darm_act_line_freq = float(filters["ka_pcal_line_freq"])
pcal_corr_at_darm_act_freq_real = float(filters["ka_pcal_corr_re"])
pcal_corr_at_darm_act_freq_imag = float(filters["ka_pcal_corr_im"])
pu_act_esd_line_freq = float(filters["ka_esd_line_freq"])
opt_gain_fcc_line_freq = float(filters["kc_pcal_line_freq"])
pcal_corr_at_opt_gain_fcc_freq_real = float(filters["kc_pcal_corr_re"])
pcal_corr_at_opt_gain_fcc_freq_imag = float(filters["kc_pcal_corr_im"])
esd_act_line_freq = float(filters["ktst_esd_line_freq"])
try:
	src_pcal_line_freq = float(filters["src_pcal_line_freq"])
	pcal_corr_at_src_freq_real = float(filters["src_pcal_corr_re"])
	pcal_corr_at_src_freq_imag = float(filters["src_pcal_corr_im"])
	if src_pcal_line_freq > 10.0 and options.remove_callines:
		remove_src_pcal_line = True
	else:
		remove_src_pcal_line = False
except:
	remove_src_pcal_line = False
	if not options.no_srcQ or not options.no_fs:
		raise ValueError("Cannot compute SRC spring frequency or Q, as the calibration line frequency is not contained in the specified filters file.")
try:
	high_pcal_line_freq = float(filters["high_pcal_line_freq"])
	pcal_corr_at_high_line_freq_real = float(filters["high_pcal_corr_re"])
	pcal_corr_at_high_line_freq_imag = float(filters["high_pcal_corr_im"])
	if high_pcal_line_freq > 0:
		remove_high_pcal_line = True
	else:
		remove_high_pcal_line = False
except:
	remove_high_pcal_line = False
try:
	roaming_pcal_line_freq = float(filters["roaming_pcal_line_freq"])
	pcal_corr_at_roaming_line_real = float(filters["roaming_pcal_corr_re"])
	pcal_corr_at_roaming_line_imag = float(filters["roaming_pcal_corr_im"])
	if roaming_pcal_line_freq > 0.0:
		remove_roaming_pcal_line = True
	else:
		remove_roaming_pcal_line = False
except:
	remove_roaming_pcal_line = False
try:
	fcc_default = float(filters["fcc"])
except:
	fcc_default = options.expected_fcc
if options.dewhitening:
	try:
		derr_dewhiten_at_darm_act_freq_real = float(filters["ka_pcal_whitener_re"])
		derr_dewhiten_at_darm_act_freq_imag = float(filters["ka_pcal_whitener_im"])
		derr_dewhiten_at_pu_act_freq_real = float(filters["ka_esd_whitener_re"])
		derr_dewhiten_at_pu_act_freq_imag = float(filters["ka_esd_whitener_im"])
		derr_dewhiten_at_opt_gain_fcc_freq_real = float(filters["kc_pcal_whitener_re"])
		derr_dewhiten_at_opt_gain_fcc_freq_imag = float(filters["kc_pcal_whitener_im"])
		derr_dewhiten_at_esd_act_freq_real = float(filters["ktst_esd_whitener_re"])
		derr_dewhiten_at_esd_act_freq_imag = float(filters["ktst_esd_whitener_im"])
	except:
		derr_dewhiten_at_darm_act_freq_real = 1.0
		derr_dewhiten_at_darm_act_freq_imag = 0.0
		derr_dewhiten_at_pu_act_freq_real = 1.0
		derr_dewhiten_at_pu_act_freq_imag = 0.0
		derr_dewhiten_at_opt_gain_fcc_freq_real = 1.0
		derr_dewhiten_at_opt_gain_fcc_freq_imag = 0.0
		derr_dewhiten_at_esd_act_freq_real = 1.0
		derr_dewhiten_at_esd_act_freq_imag = 0.0

# If we're performing partial calibration, load the deltal filters
if options.partial_calibration:
	reschaindelay = int(filters["res_corr_delay"])
	reschainfilt = filters["res_corr_filter"]
	tstdelay = pumuimdelay = int(filters["ctrl_corr_delay"])
	tstfilt = pumuimfilt = filters["ctrl_corr_filter"]
	tstchainsr = pumuimchainsr = int(filters["ctrl_corr_sr"])
	if options.dewhitening:
		tstdewhitensr = int(filters["deltal_tst_dewhiten_sr"])
		pumuimdewhitensr = int(filters["deltal_pumuim_dewhiten_sr"])
		tstdewhitendelay = int(filters["deltal_tst_dewhiten_delay"])
		pumuimdewhitendelay = int(filters["deltal_pumuim_dewhiten_delay"])
		tstdewhiten = filters["deltal_tst_dewhiten"]
		pumuimdewhiten = filters["deltal_pumuim_dewhiten"]
		resdewhitendelay = int(filters["deltal_res_dewhiten_delay"])
		resdewhiten = filters["deltal_res_dewhiten"]

	# Load the high-pass filter for h(t)
	try:
		act_highpass_delay = int(filters['ctrl_highpass_delay'])
		invsens_highpass_delay = int(filters['res_highpass_delay'])
		act_highpass = filters["ctrl_highpass"]
		invsens_highpass = filters["res_highpass"]
	except:
		act_highpass = []
		invsens_highpass = []
		invsens_highpass_delay = 0
		act_highpass_delay = 0

# If we're performing full calibration, load the actuation, sensing filters
if options.full_calibration:
	tstchainsr = int(filters["actuation_tst_sr"])
	pumuimchainsr = int(filters["actuation_pumuim_sr"])
	tstdelay = int(filters["actuation_tst_delay"])
	pumuimdelay = int(filters["actuation_pumuim_delay"])
	tstfilt = filters["actuation_tst"]
	pumuimfilt = filters["actuation_pumuim"]
	reschaindelay = int(filters["inv_sens_delay"])
	reschainfilt = filters["inv_sensing"]
	if options.dewhitening:
		ctrldewhitendelay = int(filters["dewhiten_ctrl_delay"])
		ctrldewhiten = filters["dewhiten_ctrl"]
		ctrldewhitensr = int(filters["dewhiten_ctrl_sr"])
		resdewhitendelay = int(filters["dewhiten_err_delay"])
		resdewhiten = filters["dewhiten_err"]

	# Load the high-pass filter for h(t)
	try:
		act_highpass_delay = int(filters['actuation_highpass_delay'])
		invsens_highpass_delay = int(filters['invsens_highpass_delay'])
		act_highpass = filters["actuation_highpass"]
		invsens_highpass = filters["inv_sensing_highpass"]
	except:
		act_highpass = []
		invsens_highpass = []

#
# Set up the appropriate channel list. In this section, we also fill a list called headkeys
# that will be the keys for the dictionary holding each pipeline branch name, and we set up
# a dictionary that will be populated with pipeline branch names based on the channel list.
#

head_dict = {}
channel_list = []
headkeys = []

# If we are computing the CALIB_STATE_VECTOR, we need the ODC state vector
if not options.no_dq_vector:
	channel_list.append((instrument, options.dq_channel_name))
	headkeys.append("odcstatevector")

# If we are computing the factors in the pipeline, we need the reference model EPICS records
if not options.factors_from_filters_file:
	# Needed for kappa_tst
	if not options.no_kappatst  or not options.no_kappapu or not options.no_kappac or not options.no_fcc:
		channel_list.extend(((instrument, options.EP1_real), (instrument, options.EP1_imag)))
		headkeys.extend(("EP1_real", "EP1_imag"))
	# These are needed for kappa_pu
	if not options.no_kappac or not options.no_fcc or not options.no_kappapu:
		channel_list.extend(((instrument, options.EP2_real), (instrument, options.EP2_imag), (instrument, options.EP3_real), (instrument, options.EP3_imag), (instrument, options.EP4_real), (instrument, options.EP4_imag)))
		headkeys.extend(("EP2_real", "EP2_imag", "EP3_real", "EP3_imag", "EP4_real", "EP4_imag"))
	# If we are computing either kappa_c or f_cc, we need some more EPICS records
	if not options.no_kappac or not options.no_fcc:
		channel_list.extend(((instrument, options.EP6_real), (instrument, options.EP6_imag), (instrument, options.EP7_real), (instrument, options.EP7_imag), (instrument, options.EP8_real), (instrument, options.EP8_imag), (instrument, options.EP9_real), (instrument, options.EP9_imag)))
		headkeys.extend(("EP6_real", "EP6_imag", "EP7_real", "EP7_imag", "EP8_real", "EP8_imag", "EP9_real", "EP9_imag"))

	# EP10 is needed to remove the ESD line
	if remove_esd_act_line:
		channel_list.extend(((instrument, options.EP10_real), (instrument, options.EP10_imag)))
		headkeys.extend(("EP10_real", "EP10_imag"))

	# These are needed if we compute the optical spring frequency and/or Q-factor of the Signal Recycling Cavity (SRC)
	if not options.no_fs or not options.no_srcQ:
		channel_list.extend(((instrument, options.EP11_real), (instrument, options.EP11_imag), (instrument, options.EP12_real), (instrument, options.EP12_imag), (instrument, options.EP13_real), (instrument, options.EP13_imag), (instrument, options.EP14_real), (instrument, options.EP14_imag)))
		headkeys.extend(("EP11_real", "EP11_imag", "EP12_real", "EP12_imag", "EP13_real", "EP13_imag", "EP14_real", "EP14_imag"))

# If we are using pre-computed coherence to gate kappas
if not options.no_coherence:
	if not options.no_kappatst or not options.no_kappapu or not options.no_kappac or not options.no_fcc or not options.no_fs or not options.no_srcQ:
		channel_list.extend(((instrument, options.coh_unc_sus_line1_channel), (instrument, options.coh_unc_pcaly_line1_channel), (instrument, options.coh_unc_darm_line1_channel)))
		headkeys.extend(("pcaly_line1_coh", "sus_coh", "darm_coh"))
	if not options.no_kappac or not options.no_fcc or not options.no_fs or not options.no_srcQ:
		channel_list.append((instrument, options.coh_unc_pcaly_line2_channel))
		headkeys.append("pcaly_line2_coh")

# We also need excitation channels for computing kappas
if not options.no_kappatst  or not options.no_kappapu or not options.no_kappac or not options.no_fcc or not options.no_fs or not options.no_srcQ or remove_esd_act_line:
	channel_list.append((instrument, options.tst_exc_channel_name))
	headkeys.append("tstexc")
if not options.no_kappac or not options.no_fcc or not options.no_kappapu or not options.no_fs or not options.no_srcQ:
	channel_list.append((instrument, options.exc_channel_name))
	headkeys.append("exc")

# We need to make sure we have DARM_ERR and the PCAL channel for computing \kappas
if not options.no_kappac or not options.no_fcc or not options.no_kappatst or not options.no_kappapu or not options.no_fs or not options.no_srcQ:
	channel_list.append((instrument, options.pcal_channel_name))
	headkeys.append("pcal")
	if options.partial_calibration:
		channel_list.append((instrument, options.darm_err_channel_name))
		headkeys.append("darm_err")

# For full calibration we need DARM_ERR and DARM_CTRL as our input channels
if options.full_calibration:
	channel_list.extend(((instrument, options.darm_err_channel_name), (instrument, options.darm_ctrl_channel_name)))
	headkeys.extend(("res", "ctrl"))
# For partial calibration we need DELTAL_TST, DELTAL_PUM, DELTAL_UIM, and DELTAL_RES
elif options.partial_calibration:
	channel_list.extend(((instrument, options.deltal_res_channel_name), (instrument, options.deltal_tst_channel_name), (instrument, options.deltal_pum_channel_name), (instrument, options.deltal_uim_channel_name)))
	headkeys.extend(("res", "tst", "pum", "uim"))

# If we are removing 60 Hz lines and harmonics, add the witness channel
if options.remove_powerlines:
	channel_list.append((instrument, options.powerlines_channel_name))
	headkeys.append("powerlines")

# If we are using witness channels to clean h(t), add those to the channel list
if options.witness_channel_list is not None:
	witness_channel_list = options.witness_channel_list.split(',')
	for i in range(0, len(witness_channel_list)):
		channel_list.append((instrument, witness_channel_list[i]))
		headkeys.append(witness_channel_list[i])


####################################################################################################
####################################### Main Pipeline ##############################################
####################################################################################################

pipeline = Gst.Pipeline(name="gstlal_compute_strain")
mainloop = GObject.MainLoop()
handler = simplehandler.Handler(mainloop, pipeline)

# 
# Turn off debugging tools or verboseness
#

pipeparts.mkchecktimestamps = lambda pipeline, src, *args: src # comment this line out to turn on the checktimestamps debugging
if not options.verbose:
	pipeparts.mkprogressreport = lambda pipeline, src, *args: src

#
# Read in data from frames or shared memory
#

if options.data_source == "lvshm": # Data is to be read from shared memory; "low-latency" mode
	src = pipeparts.mklvshmsrc(pipeline, shm_name = options.shared_memory_partition, assumed_duration = 1)
elif options.data_source == "frames": # Data is to be read from frame files; "offline" mode
	src = pipeparts.mklalcachesrc(pipeline, location = options.frame_cache, cache_dsc_regex = instrument)

#
# Hook up the relevant channels to the demuxer
#

if options.data_source == "lvshm":
	demux = pipeparts.mkframecppchanneldemux(pipeline, src, do_file_checksum = options.do_file_checksum, skip_bad_files = True, channel_list = map("%s:%s".__mod__, channel_list))

elif options.data_source == "frames":
	demux = pipeparts.mkframecppchanneldemux(pipeline, src, do_file_checksum = options.do_file_checksum, skip_bad_files = False, channel_list = map("%s:%s".__mod__, channel_list))

# Write the pipeline graph after pads have been hooked up to the demuxer
if options.write_pipeline is not None:
	demux.connect("no-more-pads", write_graph)	

# Get everything hooked up and fill in discontinuities
for key, chan in zip(headkeys, channel_list):
	head_dict[key] = calibration_parts.hook_up(pipeline, demux, chan[1], instrument, options.buffer_length)

# When reading from disk, clip the incoming data stream(s) to segment list if one is provided
if options.data_source == "frames" and frame_segments is not None:
	for key in headkeys:
		currenthead = head_dict[key]
		head_dict[key] = calibration_parts.mkgate(pipeline, currenthead, pipeparts.mksegmentsrc(pipeline, frame_segments[instrument]), 1)

#
# TIME-VARYING FACTORS COMPUTATIONS
#

for key in headkeys:
	if key.startswith("EP"):
		head_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		head_dict[key] = calibration_parts.mkresample(pipeline, head_dict[key], 0, False, compute_calib_factors_caps)

if not options.no_coherence:
	if not options.no_kappatst or not options.no_kappapu or not options.no_kappac or not options.no_fcc or not options.no_fs or not options.no_srcQ:
		pcaly_line1_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line1_coh"], coh_caps, "pcaly_line1_coh")
		pcaly_line1_coh = calibration_parts.mkresample(pipeline, pcaly_line1_coh, 0, False, compute_calib_factors_caps)
		sus_coh = calibration_parts.caps_and_progress(pipeline, head_dict["sus_coh"], coh_caps, "sus_coh")
		sus_coh = calibration_parts.mkresample(pipeline, sus_coh, 0, False, compute_calib_factors_caps)
		darm_coh = calibration_parts.caps_and_progress(pipeline, head_dict["darm_coh"], coh_caps, "darm_coh")
		darm_coh = calibration_parts.mkresample(pipeline, darm_coh, 0, False, compute_calib_factors_caps)
	if not options.no_kappac or not options.no_fcc or not options.no_fs or not options.no_srcQ:
		pcaly_line2_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line2_coh"], coh_caps, "pcaly_line2_coh")
		pcaly_line2_coh = calibration_parts.mkresample(pipeline, pcaly_line2_coh, 0, False, compute_calib_factors_caps)

if not options.no_kappatst or not options.no_kappapu or not options.no_kappac or not options.no_fcc or not options.no_fs or not options.no_srcQ or remove_esd_act_line:
	tstexccaps = "audio/x-raw, format=F64LE, rate=%d" % options.tst_exc_sample_rate
	tstexc = calibration_parts.caps_and_progress(pipeline, head_dict["tstexc"], tstexccaps, "tstexc")

if not options.no_kappac or not options.no_fcc or not options.no_kappapu or not options.no_fs or not options.no_srcQ:
	exc = calibration_parts.caps_and_progress(pipeline, head_dict["exc"], hoft_caps, "exc")

# If we use the coherence channels multiple times in the pipeline, we need to tee the channels
if not options.no_coherence:
	lowfreq_coh_use = int(not options.no_kappatst) + int(not options.no_kappapu) + int(not options.no_kappac) + int(not options.no_fcc) + int(not options.no_srcQ) + int(not options.no_fs) + int(not options.no_dq_vector and (not options.no_kappatst or not options.no_kappapu or not options.no_kappac or not options.no_fcc or not options.no_srcQ or not options.no_fs))
	highfreq_coh_use = int(not options.no_kappac) + int(not options.no_fcc) + int(not options.no_srcQ) + int(not options.no_fs) + int(not options.no_dq_vector and (not options.no_kappac or not options.no_fcc or not options.no_srcQ or not options.no_fs)) 
	if lowfreq_coh_use >= 2:
		pcaly_line1_coh = pipeparts.mktee(pipeline, pcaly_line1_coh)
		sus_coh = pipeparts.mktee(pipeline, sus_coh)
		darm_coh = pipeparts.mktee(pipeline, darm_coh)
	if highfreq_coh_use >= 2:
		pcaly_line2_coh = pipeparts.mktee(pipeline, pcaly_line2_coh)

# Set up computations for \kappa_tst,\kappa_c, \kappa_pu, f_cc, if applicable
if not options.no_kappac or not options.no_fcc or not options.no_kappatst or not options.no_kappapu or not options.no_srcQ or not options.no_fs:

	# pcal excitation channel, which will be demodulated
	pcal = calibration_parts.caps_and_progress(pipeline, head_dict["pcal"], hoft_caps, "pcal")
	pcaltee = pipeparts.mktee(pipeline, pcal)
	
	# DARM_ERR channel, which will have followed different paths if we're doing full vs. partial calibration
	if options.full_calibration:
		darm_err = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "darm_err")
	else:
		darm_err = calibration_parts.caps_and_progress(pipeline, head_dict["darm_err"], hoft_caps, "darm_err")
	derrtee = pipeparts.mktee(pipeline, darm_err)

	# demodulate the PCAL channel and apply the PCAL correction factor at the DARM actuation line frequency
	pcal_at_darm_act_freq = calibration_parts.demodulate(pipeline, pcaltee, darm_act_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency, prefactor_real = pcal_corr_at_darm_act_freq_real, prefactor_imag = pcal_corr_at_darm_act_freq_imag)
	if not options.no_kappapu or not options.no_kappac or not options.no_fcc or not options.no_srcQ or not options.no_fs or options.remove_callines:
		pcal_at_darm_act_freq = pipeparts.mktee(pipeline, pcal_at_darm_act_freq)

	# demodulate DARM_ERR at the DARM actuation line frequency
	derr_at_darm_act_freq = calibration_parts.demodulate(pipeline, derrtee, darm_act_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency)
	if options.dewhitening:
		# dewhiten DARM_ERR at the DARM actuation line frequency
		derr_at_darm_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_darm_act_freq, derr_dewhiten_at_darm_act_freq_real, derr_dewhiten_at_darm_act_freq_imag)
	if not options.no_kappapu or not options.no_kappac or not options.no_fcc or not options.no_srcQ or not options.no_fs:
		derr_at_darm_act_freq = pipeparts.mktee(pipeline, derr_at_darm_act_freq)

	# demodulate the TST excitation channel at the ESD actuation line frequency
	tstexc_at_esd_act_freq = calibration_parts.demodulate(pipeline, tstexc, esd_act_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency)
	if remove_esd_act_line:
		tstexc_at_esd_act_freq = pipeparts.mktee(pipeline, tstexc_at_esd_act_freq)

	# demodulate DARM_ERR at the ESD actuation line frequency
	derr_at_esd_act_freq = calibration_parts.demodulate(pipeline, derrtee, esd_act_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency)
	if options.dewhitening:
		# dewhiten DARM_ERR at the ESD actuation line frequency
		derr_at_esd_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_esd_act_freq, derr_dewhiten_at_esd_act_freq_real, derr_dewhiten_at_esd_act_freq_imag)

	# compute kappa_tst, either using reference factors from the filters file or reading them from EPICS channels
	if not options.factors_from_filters_file:
		EP1 = calibration_parts.merge_into_complex(pipeline, head_dict["EP1_real"], head_dict["EP1_imag"])
		ktst = calibration_parts.compute_kappatst(pipeline, derr_at_esd_act_freq, tstexc_at_esd_act_freq, pcal_at_darm_act_freq, derr_at_darm_act_freq, EP1)
	elif options.factors_from_filters_file:
		ktst = calibration_parts.compute_kappatst_from_filters_file(pipeline, derr_at_esd_act_freq, tstexc_at_esd_act_freq, pcal_at_darm_act_freq, derr_at_darm_act_freq, EP1_real, EP1_imag)

	if not options.no_kappatst or not options.no_kappac or not options.no_fcc or not options.no_srcQ or not options.no_fs:
		ktst = pipeparts.mktee(pipeline, ktst)
	if not options.no_kappatst:
		smooth_ktst_nogate = pipeparts.mkgeneric(pipeline, ktst, "lal_smoothkappas", default_kappa_re = options.expected_kappatst_real, default_kappa_im = options.expected_kappatst_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = options.kappas_default_to_median, filter_latency = options.filter_latency)
		smooth_ktstR_nogate, smooth_ktstI_nogate = calibration_parts.split_into_real(pipeline, smooth_ktst_nogate)

		if not options.no_coherence:
			# Gate kappa_tst with the coherence of the PCALY_line1 line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst, pcaly_line1_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_tst with the coherence of the suspension line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst_gated, sus_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_tst with the coherence of the DARM line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst_gated, darm_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

			if not options.no_dq_vector:
				ktst_gated = pipeparts.mktee(pipeline, ktst_gated)
				smooth_ktstRdq, smooth_ktstIdq = calibration_parts.track_bad_complex_kappas(pipeline, ktst_gated, options.expected_kappatst_real, options.expected_kappatst_imag, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

			# Smooth kappa_tst
			smooth_ktstR, smooth_ktstI = calibration_parts.smooth_complex_kappas(pipeline, ktst_gated, options.expected_kappatst_real, options.expected_kappatst_imag, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

		else:
			if not options.no_dq_vector:
				smooth_ktstRdq, smooth_ktstIdq = calibration_parts.track_bad_complex_kappas_no_coherence(pipeline, ktst, options.kappatst_real_ok_var, options.kappatst_imag_ok_var, options.expected_kappatst_real, options.expected_kappatst_imag, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

			# Smooth kappa_tst
			smooth_ktstR, smooth_ktstI = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, ktst, options.kappatst_real_ok_var, options.kappatst_imag_ok_var, options.expected_kappatst_real, options.expected_kappatst_imag, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

		smooth_ktstRtee = pipeparts.mktee(pipeline, smooth_ktstR)
		smooth_ktstItee = pipeparts.mktee(pipeline, smooth_ktstI)
	
# If we're also computing \kappa_c, f_cc, or \kappa_pu, keep going
if not options.no_kappac or not options.no_fcc or not options.no_kappapu or not options.no_srcQ or not options.no_fs:
	# demodulate excitation channel at PU actuation line frequency
	exc_at_pu_act_freq = calibration_parts.demodulate(pipeline, exc, pu_act_esd_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency)

	# demodulate DARM_ERR at PU actuation line frequency
	derr_at_pu_act_freq = calibration_parts.demodulate(pipeline, derrtee, pu_act_esd_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency)
	if options.dewhitening:
		# dewhiten DARM_ERR at the PU actuation line frequency
		derr_at_pu_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_pu_act_freq, derr_dewhiten_at_pu_act_freq_real, derr_dewhiten_at_pu_act_freq_imag)

	# compute the factor Afctrl that will be used in the computation of kappa_pu and kappa_a, either using reference factors from the filters file or reading them from EPICS channels
	if not options.factors_from_filters_file:
		EP2 = calibration_parts.merge_into_complex(pipeline, head_dict["EP2_real"], head_dict["EP2_imag"])
		EP3 = calibration_parts.merge_into_complex(pipeline, head_dict["EP3_real"], head_dict["EP3_imag"])
		EP4 = calibration_parts.merge_into_complex(pipeline, head_dict["EP4_real"], head_dict["EP4_imag"])
		afctrl = calibration_parts.compute_afctrl(pipeline, derr_at_pu_act_freq, exc_at_pu_act_freq, pcal_at_darm_act_freq, derr_at_darm_act_freq, EP2)
	elif options.factors_from_filters_file:
		afctrl = calibration_parts.compute_afctrl_from_filters_file(pipeline, derr_at_pu_act_freq, exc_at_pu_act_freq, pcal_at_darm_act_freq, derr_at_darm_act_freq, EP2_real, EP2_imag)

	# \kappa_pu calcuation, which needs to happen for any of the other kappas to be computed
	if not options.factors_from_filters_file:
		kpu = calibration_parts.compute_kappapu(pipeline, EP3, afctrl, ktst, EP4)
	elif options.factors_from_filters_file:
		kpu = calibration_parts.compute_kappapu_from_filters_file(pipeline, EP3_real, EP3_imag, afctrl, ktst, EP4_real, EP4_imag)

	if not options.no_kappapu or not options.no_srcQ or not options.no_fs:
		kpu = pipeparts.mktee(pipeline, kpu)
	if not options.no_kappapu:
		smooth_kpu_nogate = pipeparts.mkgeneric(pipeline, kpu, "lal_smoothkappas", default_kappa_re = options.expected_kappapu_real, default_kappa_im = options.expected_kappapu_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = options.kappas_default_to_median, filter_latency = options.filter_latency)
		smooth_kpuR_nogate, smooth_kpuI_nogate = calibration_parts.split_into_real(pipeline, smooth_kpu_nogate)

		if not options.no_coherence:
			# Gate kappa_pu with the coherence of the DARM line
			kpu_gated = calibration_parts.mkgate(pipeline, kpu, darm_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_pu with the coherence of the PCALY_line1 line
			kpu_gated = calibration_parts.mkgate(pipeline, kpu_gated, pcaly_line1_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			# Gate kappa_pu with the coherence of the suspension coherence
			kpu_gated = calibration_parts.mkgate(pipeline, kpu_gated, sus_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

			if not options.no_dq_vector:
				kpu_gated = pipeparts.mktee(pipeline, kpu_gated)
				smooth_kpuRdq, smooth_kpuIdq = calibration_parts.track_bad_complex_kappas(pipeline, kpu_gated, options.expected_kappapu_real, options.expected_kappapu_imag, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

			# Smooth kappa_pu
			smooth_kpuR, smooth_kpuI = calibration_parts.smooth_complex_kappas(pipeline, kpu_gated, options.expected_kappapu_real, options.expected_kappapu_imag, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

		else:
			if not options.no_dq_vector:
				smooth_kpuRdq, smooth_kpuIdq = calibration_parts.track_bad_complex_kappas_no_coherence(pipeline, kpu, options.kappapu_real_ok_var, options.kappapu_imag_ok_var, options.expected_kappapu_real, options.expected_kappapu_imag, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

			# Smooth kappa_pu
			smooth_kpuR, smooth_kpuI = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, kpu, options.kappapu_real_ok_var, options.kappapu_imag_ok_var, options.expected_kappapu_real, options.expected_kappapu_imag, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

		smooth_kpuRtee = pipeparts.mktee(pipeline, smooth_kpuR)
		smooth_kpuItee = pipeparts.mktee(pipeline, smooth_kpuI)	

	# Finally, compute \kappa_c and f_cc
	if not options.no_kappac or not options.no_fcc or not options.no_srcQ or not options.no_fs:
		# demodulate the PCAL channel and apply the PCAL correction factor at optical gain and f_cc line frequency
		pcal_at_opt_gain_freq = calibration_parts.demodulate(pipeline, pcaltee, opt_gain_fcc_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency, prefactor_real = pcal_corr_at_opt_gain_fcc_freq_real, prefactor_imag = pcal_corr_at_opt_gain_fcc_freq_imag)
		if options.remove_callines:
			pcal_at_opt_gain_freq = pipeparts.mktee(pipeline, pcal_at_opt_gain_freq)

		# demodulate DARM_ERR at optical gain and f_cc line frequency
		derr_at_opt_gain_freq = calibration_parts.demodulate(pipeline, derrtee, opt_gain_fcc_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency)
		if options.dewhitening:
			# dewhiten DARM_ERR at optical gain and f_cc line frequency
			derr_at_opt_gain_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_opt_gain_freq, derr_dewhiten_at_opt_gain_fcc_freq_real, derr_dewhiten_at_opt_gain_fcc_freq_imag)

		# Compute the factor S which will be used for the kappa_c and f_cc calculations
		if not options.factors_from_filters_file:
			EP6 = calibration_parts.merge_into_complex(pipeline, head_dict["EP6_real"], head_dict["EP6_imag"])
			EP7 = calibration_parts.merge_into_complex(pipeline, head_dict["EP7_real"], head_dict["EP7_imag"])
			EP8 = calibration_parts.merge_into_complex(pipeline, head_dict["EP8_real"], head_dict["EP8_imag"])
			EP9 = calibration_parts.merge_into_complex(pipeline, head_dict["EP9_real"], head_dict["EP9_imag"])
			S = calibration_parts.compute_S(pipeline, EP6, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7, ktst, EP8, kpu, EP9)
		elif options.factors_from_filters_file:
			S = calibration_parts.compute_S_from_filters_file(pipeline, EP6_real, EP6_imag, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7_real, EP7_imag, ktst, EP8_real, EP8_imag, kpu, EP9_real, EP9_imag)

		S = pipeparts.mktee(pipeline, S)

		SR, SI = calibration_parts.split_into_real(pipeline, S)

		if not options.no_kappac and not options.no_fcc:
			SR = pipeparts.mktee(pipeline, SR)
			SI = pipeparts.mktee(pipeline, SI)

		# compute kappa_c
		if not options.no_kappac or not options.no_srcQ or not options.no_fs:
			kc = calibration_parts.compute_kappac(pipeline, SR, SI)
		if not options.no_kappac:
			kc = pipeparts.mktee(pipeline, kc)
			smooth_kc_nogate = pipeparts.mkgeneric(pipeline, kc, "lal_smoothkappas", default_kappa_re = options.expected_kappac, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = options.kappas_default_to_median, filter_latency = options.filter_latency)

			if not options.no_coherence:
				# Gate kappa_c with all four of the calibration lines
				kc_gated = calibration_parts.mkgate(pipeline, kc, pcaly_line2_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				kc_gated = calibration_parts.mkgate(pipeline, kc_gated, darm_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				kc_gated = calibration_parts.mkgate(pipeline, kc_gated, pcaly_line1_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				kc_gated = calibration_parts.mkgate(pipeline, kc_gated, sus_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

				if not options.no_dq_vector:
					kc_gated = pipeparts.mktee(pipeline, kc_gated)
					smooth_kcdq = calibration_parts.track_bad_kappas(pipeline, kc_gated, options.expected_kappac, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

				smooth_kc = calibration_parts.smooth_kappas(pipeline, kc_gated, options.expected_kappac, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

			else:
				smooth_kc = calibration_parts.smooth_kappas_no_coherence(pipeline, kc, options.kappac_ok_var, options.expected_kappac, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

				if not options.no_dq_vector:
					smooth_kcdq = calibration_parts.track_bad_kappas_no_coherence(pipeline, kc, options.kappac_ok_var, options.expected_kappac, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

		smooth_kctee = pipeparts.mktee(pipeline, smooth_kc)

		# compute f_cc
		if not options.no_fcc or not options.no_srcQ or not options.no_fs:
			fcc = calibration_parts.compute_fcc(pipeline, SR, SI, opt_gain_fcc_line_freq)
		if not options.no_fcc:
			fcc = pipeparts.mktee(pipeline, fcc)
			smooth_fcc_nogate = pipeparts.mkgeneric(pipeline, fcc, "lal_smoothkappas", default_kappa_re = fcc_default, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = options.kappas_default_to_median, filter_latency = options.filter_latency)

			if not options.no_coherence:
				# Gate f_cc with all four of the calibration lines
				fcc_gated = calibration_parts.mkgate(pipeline, fcc, pcaly_line2_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, darm_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, pcaly_line1_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, sus_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

				if not options.no_dq_vector:
					fcc_gated = pipeparts.mktee(pipeline, fcc_gated)
					smooth_fccdq = calibration_parts.track_bad_kappas(pipeline, fcc_gated, fcc_default, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

				smooth_fcc = calibration_parts.smooth_kappas(pipeline, fcc_gated, fcc_default, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)
			else:
				smooth_fcc = calibration_parts.smooth_kappas_no_coherence(pipeline, fcc, options.fcc_ok_var, fcc_default, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)
				if not options.no_dq_vector:
					smooth_fccdq = calibration_parts.track_bad_kappas_no_coherence(pipeline, fcc, options.fcc_ok_var, fcc_default, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)
				
			smooth_fcctee = pipeparts.mktee(pipeline, smooth_fcc)

			if options.update_fcc:
				update_fcc = pipeparts.mkgeneric(pipeline, smooth_fcctee, "lal_fcc_update", data_rate = hoftsr, fcc_rate = options.compute_factors_sr, fcc_model = fcc_default, averaging_time = options.fcc_averaging_time, filter_duration = options.fcc_filter_duration)
				pipeparts.mkfakesink(pipeline, update_fcc)

	# compute f_s and Q
	if not options.no_fs or not options.no_srcQ:
		# demodulate PCAL channel and apply the PCAL correction factor at SRC detuning line frequency
		pcal_at_src_freq = calibration_parts.demodulate(pipeline, pcaltee, src_pcal_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency, prefactor_real = pcal_corr_at_src_freq_real, prefactor_imag = pcal_corr_at_src_freq_imag)
		if remove_src_pcal_line:
			pcal_at_src_freq = pipeparts.mktee(pipeline, pcal_at_src_freq)

		# demodulate DARM_ERR at SRC detuning line frequency
		derr_at_src_freq = calibration_parts.demodulate(pipeline, derrtee, src_pcal_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency)

		# Compute the factor Xi which will be used for the f_s and src_Q calculations
		if not options.factors_from_filters_file:
			EP11 = calibration_parts.merge_into_complex(pipeline, head_dict["EP11_real"], head_dict["EP11_imag"])
			EP12 = calibration_parts.merge_into_complex(pipeline, head_dict["EP12_real"], head_dict["EP12_imag"])
			EP13 = calibration_parts.merge_into_complex(pipeline, head_dict["EP13_real"], head_dict["EP13_imag"])
			EP14 = calibration_parts.merge_into_complex(pipeline, head_dict["EP14_real"], head_dict["EP14_imag"])
			Xi = calibration_parts.compute_Xi(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11, EP12, EP13, EP14, ktst, kpu, kc, fcc)
		elif options.factors_from_filters_file:
			Xi = calibration_parts.compute_Xi_from_filters_file(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11_real, EP11_imag, EP12_real, EP12_imag, EP13_real, EP13_imag, EP14_real, EP14_imag, ktst, kpu, kc, fcc)

		if options.no_srcQ:
                        # the imaginary part is only used to compute Q
			XiR = pipeparts.mkgeneric(pipeline, Xi, "creal")
		else:
			XiR, XiI = calibration_parts.split_into_real(pipeline, Xi)

		sqrtXiR = pipeparts.mkpow(pipeline, XiR, exponent = 0.5)
		if not options.no_fs and not options.no_srcQ:
			sqrtXiR = pipeparts.mktee(pipeline, sqrtXiR)

		# compute f_s
		if not options.no_fs:
			fs = pipeparts.mkaudioamplify(pipeline, sqrtXiR, src_pcal_line_freq)
			fs = pipeparts.mktee(pipeline, fs)
			smooth_fs_nogate = pipeparts.mkgeneric(pipeline, fs, "lal_smoothkappas", default_kappa_re = options.expected_fs, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = options.kappas_default_to_median, filter_latency = options.filter_latency)

			if not options.no_coherence:
				# Gate f_s with all four of the calibration lines
				fs_gated = calibration_parts.mkgate(pipeline, fs, pcaly_line2_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				fs_gated = calibration_parts.mkgate(pipeline, fs_gated, darm_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				fs_gated = calibration_parts.mkgate(pipeline, fs_gated, pcaly_line1_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				fs_gated = calibration_parts.mkgate(pipeline, fs_gated, sus_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

				if not options.no_dq_vector:
					fs_gated = pipeparts.mktee(pipeline, fs_gated)
					smooth_fsdq = calibration_parts.track_bad_kappas(pipeline, fs_gated, options.expected_fs, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

				smooth_fs = calibration_parts.smooth_kappas(pipeline, fs_gated, options.expected_fs, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

			else:
				smooth_fs = calibration_parts.smooth_kappas_no_coherence(pipeline, fs, options.fs_ok_var, options.expected_fs, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

				if not options.no_dq_vector:
					smooth_fsdq = calibration_parts.track_bad_kappas_no_coherence(pipeline, fs, options.fs_ok_var, options.expected_fs, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

			if not options.no_dq_vector:
				smooth_fs = pipeparts.mktee(pipeline, smooth_fs)

		# compute SRC Q_inv
		if not options.no_srcQ:
			sqrtXiR_inv = pipeparts.mkpow(pipeline, sqrtXiR, exponent = -1.0)
			sqrtXiR_inv = pipeparts.mkaudioamplify(pipeline, sqrtXiR_inv, -1.0)
			srcQ_inv = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, sqrtXiR_inv, XiI))
			srcQ_inv = pipeparts.mktee(pipeline, srcQ_inv)
			smooth_srcQ_inv_nogate = pipeparts.mkgeneric(pipeline, srcQ_inv, "lal_smoothkappas", default_kappa_re = 1.0 / options.expected_srcQ, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = options.kappas_default_to_median, filter_latency = options.filter_latency)

			if not options.no_coherence:
				# Gate SRC_Q with all four of the calibration lines
				srcQ_inv_gated = calibration_parts.mkgate(pipeline, srcQ_inv, pcaly_line2_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				srcQ_inv_gated = calibration_parts.mkgate(pipeline, srcQ_inv_gated, darm_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				srcQ_inv_gated = calibration_parts.mkgate(pipeline, srcQ_inv_gated, pcaly_line1_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
				srcQ_inv_gated = calibration_parts.mkgate(pipeline, srcQ_inv_gated, sus_coh, options.coherence_uncertainty_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

				if not options.no_dq_vector:
					srcQ_inv_gated = pipeparts.mktee(pipeline, srcQ_inv_gated)
					smooth_srcQdq = calibration_parts.track_bad_kappas(pipeline, srcQ_inv_gated, 1.0 / options.expected_srcQ, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

				smooth_srcQ_inv = calibration_parts.smooth_kappas(pipeline, srcQ_inv_gated, 1.0 / options.expected_srcQ, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

			else:
				smooth_srcQ_inv = calibration_parts.smooth_kappas_no_coherence(pipeline, srcQ_inv, options.srcQ_ok_var, 1.0 / options.expected_srcQ, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

				if not options.no_dq_vector:
					smooth_srcQdq = calibration_parts.track_bad_kappas_no_coherence(pipeline, srcQ_inv, options.srcQ_ok_var, 1.0 / options.expected_srcQ, median_smoothing_samples, factors_average_samples, options.kappas_default_to_median, options.filter_latency)

			if not options.no_dq_vector:
				smooth_srcQ_inv = pipeparts.mktee(pipeline, smooth_srcQ_inv)

#
# CONTROL BRANCH
#

# zero out filter settling samples
tst_filter_settle_time = 0.0
tst_filter_latency = 0.0
pumuim_filter_settle_time = 0.0
pumuim_filter_latency = 0.0

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank
if options.partial_calibration:
	# enforce caps on actuation channels and set up progress report if verbose is on
	tst = calibration_parts.caps_and_progress(pipeline, head_dict["tst"], ctrl_caps, "tst")
	tsttee = pipeparts.mktee(pipeline, tst)
	pum = calibration_parts.caps_and_progress(pipeline, head_dict["pum"], ctrl_caps, "pum")
	pumtee = pipeparts.mktee(pipeline, pum)
	uim = calibration_parts.caps_and_progress(pipeline, head_dict["uim"], ctrl_caps, "uim")
	uimtee = pipeparts.mktee(pipeline, uim)

	# add together the PUM and UIM actuation channels; this may change in the future...
	pumuim = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pumtee, uimtee))

	# if you need to, dewhiten the TST and PUM/UIM chains
	if options.dewhitening:
		pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumuimdewhitensr) 
		pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = int(pumuimdewhitendelay), fir_matrix = [pumuimdewhiten[::-1]], time_domain = td)
		pumuim_filter_settle_time += float(len(pumuimdewhiten)-pumuimdewhitendelay)/pumuimdewhitensr
		pumuim_filter_latency += float(pumuimdewhitendelay)/pumuimdewhitensr
		tst = calibration_parts.mkresample(pipeline, tsttee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % tstdewhitensr) 
		tst = pipeparts.mkfirbank(pipeline, tst, latency = int(tstdewhitendelay), fir_matrix = [tstdewhiten[::-1]], time_domain = td)
		tst_filter_settle_time += float(len(tstdewhiten)-tstdewhitendelay)/tstdewhitensr
		tst_filter_latency += float(tstdewhitendelay)/tstdewhitensr
	else:
		tst = tsttee

if options.full_calibration:
	# enforce caps on actuation channels and set up progress report, if verbose is on
	ctrl = calibration_parts.caps_and_progress(pipeline, head_dict["ctrl"], hoft_caps, "ctrl")
	darmctrltee = pipeparts.mktee(pipeline, ctrl)
	
	if options.dewhitening:
		# dewhiten the DARM_CTRL channel
		ctrl = calibration_parts.mkresample(pipeline, darmctrltee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % ctrldewhitensr)
		ctrl = pipeparts.mkfirbank(pipeline, ctrl, latency = int(ctrldewhitendelay), fir_matrix = [ctrldewhiten[::-1]], time_domain = td)
		tst_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
		tst_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
		pumuim_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
		pumuim_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
		# tee off DARM_CTRL to be filtered with PUM/UIM and TST filters separately
		ctrltee = pipeparts.mktee(pipeline, ctrl)
	else:
		ctrltee = pipeparts.mktee(pipeline, darmctrltee)
	tst = ctrltee
	pumuim = ctrltee

# resample what will become the TST actuation chain to the TST FIR filter sample rate
tst = calibration_parts.mkresample(pipeline, tst, 5, False, "audio/x-raw, format=F64LE, rate=%d" %  tstchainsr)
# Remove any DC component
if options.remove_DC:
	tst = calibration_parts.removeDC(pipeline, tst, tstchainsr)
# High-pass filter the TST chain
if any(act_highpass):
	tst = pipeparts.mkfirbank(pipeline, tst, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td)
	tst_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/tstchainsr
	tst_filter_latency += float(act_highpass_delay)/tstchainsr
# Filter TST chain with the TST acutaiton filter
tst = pipeparts.mkfirbank(pipeline, tst, latency = tstdelay, fir_matrix = [tstfilt[::-1]], time_domain = td)
tst_filter_settle_time += float(len(tstfilt)-tstdelay)/tstchainsr
tst_filter_latency += float(tstdelay)/tstchainsr
# resample the TST actuation chain to the full sample rate
if tstchainsr != pumuimchainsr or options.apply_kappatst or options.apply_kappapu:
	tst = calibration_parts.mkresample(pipeline, tst, 5, False, hoft_caps)
	#tst = calibration_parts.mkstockresample(pipeline, tst, hoft_caps)

# resample what will become the PUM/UIM actuation chain to the PUM/UIM FIR filter sample rate
pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumuimchainsr)
# Remove any DC component
if options.remove_DC:
	pumuim = calibration_parts.removeDC(pipeline, pumuim, pumuimchainsr)
# High-pass filter the PUM/UIM chain
if any(act_highpass):
	pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td)
	pumuim_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/pumuimchainsr
	pumuim_filter_latency += float(act_highpass_delay)/pumuimchainsr
# filter the PUM/UIM chain with the PUM/UIM actuation filter
pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = pumuimdelay, fir_matrix = [pumuimfilt[::-1]], time_domain = td)
pumuim_filter_settle_time += float(len(pumuimfilt)-pumuimdelay)/pumuimchainsr
pumuim_filter_latency += float(pumuimdelay)/pumuimchainsr
# resample the PUM/UIM actuation chain to the full sample rate
if tstchainsr != pumuimchainsr or options.apply_kappapu or options.apply_kappatst:
	pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, hoft_caps)
	#pumuim = calibration_parts.mkstockresample(pipeline, pumuim, hoft_caps)


# apply kappa_tst
if options.apply_kappatst:
	# Only apply the real part of \kappa_tst as a correction to A_tst
	ktst_for_tst = calibration_parts.mkresample(pipeline, smooth_ktstRtee, 3, False, hoft_caps)
	tst = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, ktst_for_tst, tst))
# apply kappa_pu
if options.apply_kappapu:
	# Only apply the real part of \kappa_pu as a correction to A_pu
	kpu_for_pu = calibration_parts.mkresample(pipeline, smooth_kpuRtee, 3, False, hoft_caps)
	pumuim = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, kpu_for_pu, pumuim))

# Add the TST and PUM/UIM chains together to form the full actuation chain
ctrl = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, tst, pumuim))
if tstchainsr != hoftsr or not options.apply_kappatst or not options.apply_kappapu:
	ctrl = calibration_parts.mkresample(pipeline, ctrl, 5, False, hoft_caps)

#
# RESIDUAL BRANCH
#

# zero out res filter settle time
res_filter_settle_time = 0.0
res_filter_latency = 0.0

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank

# enforce caps on the residual branch and hook up progress report if verbose is on
if options.full_calibration:
	if not options.no_kappatst or not options.no_kappapu or not options.no_kappac or not options.no_fcc:
		res = restee = derrtee
	else:
		res = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "res")
		res = restee = pipeparts.mktee(pipeline, res)
if options.partial_calibration:
	res = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "res")
	res = restee = pipeparts.mktee(pipeline, res)

# Remove any DC component
if options.remove_DC:
	res = calibration_parts.removeDC(pipeline, res, hoftsr)

# High-pass filter the residual chain
if any(invsens_highpass):
	res = pipeparts.mkfirbank(pipeline, res, latency = invsens_highpass_delay, fir_matrix = [invsens_highpass[::-1]], time_domain = td)
	res_filter_settle_time += float(len(invsens_highpass)-invsens_highpass_delay)/hoftsr
	res_filter_latency += float(invsens_highpass_delay)/hoftsr

# Correct for time-dependeice of f_cc
if options.update_fcc:
	default_fir_matrix = numpy.zeros(int(numpy.floor(hoftsr*options.fcc_filter_duration/2.0+1)*2.0-2.0))
	latency = int(hoftsr*options.fcc_filter_duration/(2.0)+1)
	default_fir_matrix[latency] = 1.0
	res = pipeparts.mkgeneric(pipeline, res, "lal_tdwhiten", kernel = default_fir_matrix[::-1], latency = latency, taper_length = options.fcc_filter_taper_length)
	update_fcc.connect("notify::fir-matrix", fir_matrix_update, res)

# Apply the residual chain filter
res = pipeparts.mkfirbank(pipeline, res, latency = int(reschaindelay), fir_matrix = [reschainfilt[::-1]], time_domain = td)

res_filter_settle_time += float(len(reschainfilt)-reschaindelay)/hoftsr
res_filter_latency += float(reschaindelay)/hoftsr
if options.dewhitening:
	res = pipeparts.mkfirbank(pipeline, res, latency = int(resdewhitendelay), fir_matrix = [resdewhiten[::-1]], time_domain = td)
	res_filter_settle_time += float(len(resdewhiten)-resdewhitendelay)/hoftsr
	res_filter_latency += float(resdewhitendelay)/hoftsr

# Apply factors to actuation and sensing chains, if applicable
if options.apply_kappac:
	kc_modify_res = calibration_parts.mkresample(pipeline, smooth_kctee, 3, False, hoft_caps)
	res = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, res, pipeparts.mkpow(pipeline, kc_modify_res, exponent = -1.0)))

filter_settle_time = max(res_filter_settle_time, tst_filter_settle_time, pumuim_filter_settle_time)
filter_latency = max(res_filter_latency, tst_filter_latency, pumuim_filter_latency)

#
# CONTROL + RESIDUAL = H(T)
#

# Add control and residual chains and divide by L to make h(t)
strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, res, ctrl))
# Divide by L in a way that is compatitble with old and new filters files, since old filter files don't recored "arm length"
try:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/float(filters["arm_length"]))
except KeyError:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/3994.5)

strain = pipeparts.mkprogressreport(pipeline, strain, "progress_hoft_%s" % instrument)

# Put the units back to strain before writing to frames
straintagstr = "units=strain,channel-name=%sCALIB_STRAIN%s,instrument=%s" % (chan_prefix, chan_suffix, instrument)
if not options.no_dq_vector or options.remove_callines or options.remove_powerlines or options.witness_channel_list is not None:
	straintee = pipeparts.mktee(pipeline, strain)
	strain = pipeparts.mktaginject(pipeline, straintee, straintagstr)
else:
	strain = pipeparts.mktaginject(pipeline, strain, straintagstr)

#
# CALIB_STATE_VECTOR BRANCH
#

#FIXME: Add more comments!

if not options.no_dq_vector:
	# FIXME: When the ODC is written as unsigned ints, this piece can be removed
	odcstatevector = calibration_parts.caps_and_progress(pipeline, head_dict["odcstatevector"], odc_caps, "odc_%s" % instrument)
	odctagstr = "channel-name=%s:%s, instrument=%s" % (instrument, options.dq_channel_name, instrument)
	odcstatevector = pipeparts.mktaginject(pipeline, odcstatevector, odctagstr)
	odcstatevectortee = pipeparts.mktee(pipeline, odcstatevector)

	#
	# GAP BIT BRANCH
	#	

	nogap = pipeparts.mkbitvectorgen(pipeline, odcstatevectortee, threshold=1, bit_vector = 1) 
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, odc_caps)
	nogap = pipeparts.mkgeneric(pipeline, nogap, "lal_logicalundersample", required_on = 1, status_out = 512)
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, calibstate_caps)

	# 
	# OBSERVATION-INTENT BIT BRANCH
	#

	obsintent = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = options.obs_intent_bitmask, status_out = 2)
	obsintent = pipeparts.mkcapsfilter(pipeline, obsintent, calibstate_caps)
	obsintenttee = pipeparts.mktee(pipeline, obsintent)
	
	#
	# OBSERVATION-READY BIT BRANCH
	#

	obsready = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = options.obs_ready_bitmask, status_out = 4)
	obsready = pipeparts.mkcapsfilter(pipeline, obsready, calibstate_caps)
	obsreadytee = pipeparts.mktee(pipeline, obsready)

	#
	# H(t)-PRODUCED BIT BRANCH
	#

	htproduced = pipeparts.mkbitvectorgen(pipeline, straintee, bit_vector = 8, threshold = 0)
	htproduced = pipeparts.mkcapsfilter(pipeline, htproduced, "audio/x-raw, format=U32LE, rate=%d" % hoftsr)
	htproduced = pipeparts.mkgeneric(pipeline, htproduced, "lal_logicalundersample", required_on = 8, status_out = 8)
	htproduced = pipeparts.mkcapsfilter(pipeline, htproduced, calibstate_caps)

	#
	# FILTERS-OK BIT BRANCH
	#
	
	# Set the FILTERS-OK bit based on observation-ready transitions
	filtersok = pipeparts.mkbitvectorgen(pipeline, obsintenttee, bit_vector=16, threshold=2)
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, calibstate_caps)
	filtersok = calibration_parts.mkgate(pipeline, filtersok, obsreadytee, 4, attack_length = -int(filter_settle_time * calibstatesr), hold_length = -int(filter_latency * calibstatesr))
	filtersok = pipeparts.mkbitvectorgen(pipeline, filtersok, bit_vector = 16, nongap_is_control = True)
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, calibstate_caps)

	#
	# NO-INVALID-INPUT BRANCH
	#

	# Check if any of the input data channels had to be replaced by zeroes because they were < 1e-35
	resok = pipeparts.mkcapsfilter(pipeline, restee, hoft_caps)
	resok = pipeparts.mkbitvectorgen(pipeline, resok, threshold=1e-35, bit_vector=1)
	resok = pipeparts.mkcapsfilter(pipeline, resok, "audio/x-raw, format=U32LE, rate=%d" % hoftsr)
	resok = pipeparts.mkgeneric(pipeline, resok, "lal_logicalundersample", required_on = 1, status_out = 1)
	resok = pipeparts.mkcapsfilter(pipeline, resok, calibstate_caps)
	if options.partial_calibration:
		tstok = pipeparts.mkcapsfilter(pipeline, tsttee, ctrl_caps)
		tstok = pipeparts.mkbitvectorgen(pipeline, tstok, threshold=1e-35, bit_vector=1)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, "audio/x-raw, format=U32LE, rate=%d" % ctrlsr)
		tstok = pipeparts.mkgeneric(pipeline, tstok, "lal_logicalundersample", required_on = 1, status_out = 1)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, calibstate_caps)
		pumok = pipeparts.mkcapsfilter(pipeline, pumtee, ctrl_caps)
		pumok = pipeparts.mkbitvectorgen(pipeline, pumok, threshold=1e-35, bit_vector=1)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, "audio/x-raw, format=U32LE, rate=%d" % ctrlsr)
		pumok = pipeparts.mkgeneric(pipeline, pumok, "lal_logicalundersample", required_on = 1, status_out = 1)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, calibstate_caps)
		uimok = pipeparts.mkcapsfilter(pipeline, uimtee, ctrl_caps)
		uimok = pipeparts.mkbitvectorgen(pipeline, uimok, threshold=1e-35, bit_vector=1)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, "audio/x-raw, format=U32LE, rate=%d" % ctrlsr)
		uimok = pipeparts.mkgeneric(pipeline, uimok, "lal_logicalundersample", required_on = 1, status_out = 1)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, calibstate_caps)
		noinvalidinput = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, resok, tstok, pumok, uimok))
		noinvalidinput = pipeparts.mkbitvectorgen(pipeline, noinvalidinput, threshold=4, bit_vector=33554432)
	if options.full_calibration:
		ctrlok = pipeparts.mkbitvectorgen(pipeline, darmctrltee, threshold=1e-35, bit_vector=1)
		ctrlok = pipeparts.mkcapsfilter(pipeline, ctrlok, "audio/x-raw, format=U32LE, rate=%d" % ctrlsr)
		ctrlok = pipeparts.mkgeneric(pipeline, ctrlok, "lal_logicalundersample", required_on = 1, status_out = 1)
		ctrlok = pipeparts.mkcapsfilter(pipeline, ctrlok, calibstate_caps)
		noinvalidinput = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, resok, ctrlok))
		noinvalidinput = pipeparts.mkbitvectorgen(pipeline, noinvalidinput, threshold=2, bit_vector=33554432)
	noinvalidinput = pipeparts.mkcapsfilter(pipeline, noinvalidinput, calibstate_caps)
	noinvalidinput = pipeparts.mktee(pipeline, noinvalidinput)
	# inputs that are replaced with zeros affect h(t) for a short time before and after the zeros, so we also must account for this corrupted time.
	noinvalidinput = calibration_parts.mkgate(pipeline, noinvalidinput, noinvalidinput, 33554432, attack_length = -int(filter_settle_time * calibstatesr), hold_length = -int(filter_latency * calibstatesr))

	#
	# KAPPA-SMOOTHING-SETTLED BIT BRANCH
	#
	if not options.no_kappac or not options.no_kappatst or not options.no_kappapu or not options.no_fcc:	
		smoothingok = pipeparts.mkbitvectorgen(pipeline, obsreadytee, bit_vector=1024, threshold=4)
		smoothingok = pipeparts.mkcapsfilter(pipeline, smoothingok, calibstate_caps)
		smoothingok = calibration_parts.mkgate(pipeline, smoothingok, obsreadytee, 4, attack_length =-(median_smoothing_samples+factors_average_samples + integration_samples))
		smoothingok = pipeparts.mkbitvectorgen(pipeline, smoothingok, bit_vector = 1024, nongap_is_control = True)
		smoothingok = pipeparts.mkcapsfilter(pipeline, smoothingok, calibstate_caps)

	#
	# KAPPATST BITS BRANCH
	#
	if not options.no_kappatst:
		ktstSmoothInRange, ktstMedianUncorrupt = calibration_parts.compute_kappa_bits(pipeline, smooth_ktstRtee, smooth_ktstItee, smooth_ktstRdq, smooth_ktstIdq, options.expected_kappatst_real, options.expected_kappatst_imag, options.kappatst_real_ok_var, options.kappatst_imag_ok_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = 2048, status_out_median = 4096, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# KAPPAPU BITS BRANCH
	#
	if not options.no_kappapu:
		kpuSmoothInRange, kpuMedianUncorrupt = calibration_parts.compute_kappa_bits(pipeline, smooth_kpuRtee, smooth_kpuItee, smooth_kpuRdq, smooth_kpuIdq, options.expected_kappapu_real, options.expected_kappapu_imag, options.kappapu_real_ok_var, options.kappapu_imag_ok_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = 8192, status_out_median = 16384, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# KAPPAC BITS BRANCH
	#
	if not options.no_kappac:
		kcSmoothInRange, kcMedianUncorrupt = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_kctee, smooth_kcdq, options.expected_kappac, options.kappac_ok_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = 131072, status_out_median = 262144, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# FCC BITS BRANCH
	#
	if not options.no_fcc:
		fccSmoothInRange, fccMedianUncorrupt = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_fcctee, smooth_fccdq, fcc_default, options.fcc_ok_var, int(median_smoothing_samples / 2) + factors_average_samples + options.fcc_averaging_time * options.compute_factors_sr, status_out_smooth = 524288, status_out_median = 1048576, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# FS BITS BRANCH
	#
	if not options.no_fs:
		fsSmoothInRange, fsMedianUncorrupt = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_fs, smooth_fsdq, options.expected_fs, options.fs_ok_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = 67108864, status_out_median = 134217728, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# SRCQ BITS BRANCH
	#
	if not options.no_srcQ:
		srcQSmoothInRange, srcQMedianUncorrupt = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_srcQ_inv, smooth_srcQdq, options.expected_srcQ, options.srcQ_ok_var, int(median_smoothing_samples / 2) + factors_average_samples, status_out_smooth = 268435456, status_out_median = 536870912, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# COHERENCE BITS BRANCH
	#
	if not options.no_coherence:
		if not options.no_kappatst or not options.no_kappapu or not options.no_kappac or not options.no_fcc or not options.no_srcQ or not options.no_fs:
			pcaly_line1_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line1_coh, threshold = options.coherence_uncertainty_threshold, bit_vector = 8388608, invert_control = True)
			pcaly_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line1_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % cohsr)
			pcaly_line1_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line1_coh_ok, "lal_logicalundersample", required_on = 8388608, status_out = 8388608)
			pcaly_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line1_coh_ok, calibstate_caps)

			sus_coh_ok = pipeparts.mkbitvectorgen(pipeline, sus_coh, threshold = options.coherence_uncertainty_threshold, bit_vector = 2097152, invert_control = True)
			sus_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % cohsr)
			sus_coh_ok = pipeparts.mkgeneric(pipeline, sus_coh_ok, "lal_logicalundersample", required_on = 2097152, status_out = 2097152)
			sus_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_coh_ok, calibstate_caps)

			darm_coh_ok = pipeparts.mkbitvectorgen(pipeline, darm_coh, threshold = options.coherence_uncertainty_threshold, bit_vector = 4194304, invert_control = True)
			darm_coh_ok = pipeparts.mkcapsfilter(pipeline, darm_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % cohsr)
			darm_coh_ok = pipeparts.mkgeneric(pipeline, darm_coh_ok, "lal_logicalundersample", required_on = 4194304, status_out = 4194304)
			darm_coh_ok = pipeparts.mkcapsfilter(pipeline, darm_coh_ok, calibstate_caps)
			coherence_bits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pcaly_line1_coh_ok, sus_coh_ok, darm_coh_ok))
		if not options.no_kappac or not options.no_fcc or not options.no_srcQ or not options.no_fs:
			pcaly_line2_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line2_coh, threshold = options.coherence_uncertainty_threshold, bit_vector = 16777216, invert_control = True)
			pcaly_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line2_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % cohsr)
			pcaly_line2_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line2_coh_ok, "lal_logicalundersample", required_on = 16777216, status_out = 16777216)
			pcaly_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line2_coh_ok, calibstate_caps)
			coherence_bits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, coherence_bits, pcaly_line2_coh_ok))

	#
	# H(T)-OK BIT BRANCH
	#

	# First combine higher order bits to determine h(t)-OK
	higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, filtersok, htproduced, obsreadytee, noinvalidinput))
	htok_threshold = 28+33554432
	if options.apply_kappatst:
		higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, higherbits, ktstSmoothInRange))
		htok_threshold += 2048
	if options.apply_kappapu:
		higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, higherbits, kpuSmoothInRange))
		htok_threshold += 8192
	if options.apply_kappac:
		higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, higherbits, kcSmoothInRange))
		htok_threshold += 131072
	if options.update_fcc:
		higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, higherbits, fccSmoothInRange))
		htok_threshold += 524288
	higherbitstee = pipeparts.mktee(pipeline, higherbits)

	# Now calculate h(t)-OK bit
	htok = pipeparts.mkbitvectorgen(pipeline, higherbitstee, bit_vector = 1, threshold = htok_threshold)
	htok = pipeparts.mkcapsfilter(pipeline, htok, calibstate_caps)

	#
	# HW INJECTION BITS
	#	

	hwinjcbc = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(options.hw_inj_cbc_bitmask), status_out = 64)
	hwinjcbc = pipeparts.mkcapsfilter(pipeline, hwinjcbc, calibstate_caps)

	hwinjburst = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(options.hw_inj_burst_bitmask), status_out = 128)
	hwinjburst = pipeparts.mkcapsfilter(pipeline, hwinjburst, calibstate_caps)

	hwinjdetchar = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(options.hw_inj_detchar_bitmask), status_out = 256)
	hwinjdetchar = pipeparts.mkcapsfilter(pipeline, hwinjdetchar, calibstate_caps)

	hwinjstoch = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = int(options.hw_inj_stoch_bitmask), status_out = 32)
	hwinjstoch = pipeparts.mkcapsfilter(pipeline, hwinjstoch, calibstate_caps)


	#
	# COMBINE ALL BITS TO MAKE GDS-CALIB_STATE_VECTOR
	#

	calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, nogap, higherbitstee, obsintenttee, htok, hwinjcbc, hwinjburst, hwinjdetchar, hwinjstoch))
	if not options.no_kappatst or not options.no_kappapu or not options.no_kappac or not options.no_fcc:
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, smoothingok))
		if not options.no_coherence:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, coherence_bits))
	if not options.no_kappatst:
		if not options.apply_kappatst:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, ktstSmoothInRange, ktstMedianUncorrupt))
		else:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, ktstMedianUncorrupt))
	if not options.no_kappapu:
		if not options.apply_kappapu:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kpuSmoothInRange, kpuMedianUncorrupt))
		else:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kpuMedianUncorrupt))
	if not options.no_kappac:
		if not options.apply_kappac:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kcSmoothInRange, kcMedianUncorrupt))
		else:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kcMedianUncorrupt))
	if not options.no_fcc:
		if not options.update_fcc:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, fccSmoothInRange, fccMedianUncorrupt))
		else:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, fccMedianUncorrupt))
	if not options.no_fs:
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, fsSmoothInRange, fsMedianUncorrupt))
	if not options.no_srcQ:
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, srcQSmoothInRange, srcQMedianUncorrupt))

	calibstatevector = pipeparts.mkprogressreport(pipeline, calibstatevector, "progress_calibstatevec_%s" % instrument)
	dqtagstr = "channel-name=%s:GDS-CALIB_STATE_VECTOR, instrument=%s" % (instrument, instrument)
	calibstatevector = pipeparts.mktaginject(pipeline, calibstatevector, dqtagstr)

#
# SUBTRACTION OF LINES AND NOISE
#

# First, remove calibration lines
if options.remove_callines:
	# if we didn't compute the kappas, we still need to get the pcal channel
	if options.no_kappatst and options.no_kappapu and options.no_kappac and options.no_fcc and options.no_srcQ and options.no_fs:
		pcal = calibration_parts.caps_and_progress(pipeline, head_dict["pcal"], hoft_caps, "pcal")
		pcaltee = pipeparts.mktee(pipeline, pcal)
		# Demodulate pcal at the ~30 Hz pcal line
		pcal_at_darm_act_freq = calibration_parts.demodulate(pipeline, pcal_tee, darm_act_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency, prefactor_real = pcal_corr_at_darm_act_freq_real, prefactor_imag =  pcal_corr_at_darm_act_freq_imag)

	# Reconstruct a calibrated pcal at only the ~30 Hz pcal line
	pcaly_line1 = calibration_parts.mkresample(pipeline, pcal_at_darm_act_freq, 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoftsr)
	pcaly_line1 = pipeparts.mkgeneric(pipeline, pcaly_line1, "lal_demodulate", line_frequency = -1.0 * darm_act_line_freq, prefactor_real = 2.0)
	remove_pcaly_line1 = pipeparts.mkgeneric(pipeline, pcaly_line1, "creal")

	# Make sure we have demodulated pcal at the ~300 Hz pcal line
	if options.no_kappac and options.no_fcc and options.no_srcQ and options.no_fs:
		pcal_at_opt_gain_freq = calibration_parts.demodulate(pipeline, pcaltee, opt_gain_fcc_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency, prefactor_real = pcal_corr_at_opt_gain_fcc_freq_real, prefactor_imag = pcal_corr_at_opt_gain_fcc_freq_imag)
	# Reconstruct a calibrated pcal at only the ~300 Hz pcal line
	pcaly_line2 = calibration_parts.mkresample(pipeline, pcal_at_opt_gain_freq, 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoftsr)
	pcaly_line2 = pipeparts.mkgeneric(pipeline, pcaly_line2, "lal_demodulate", line_frequency = -1.0 * opt_gain_fcc_line_freq, prefactor_real = 2.0)
	remove_pcaly_line2 = pipeparts.mkgeneric(pipeline, pcaly_line2, "creal")

	# Add the first two components together. We will add this to h(t) to remove these lines
	calibration_lines = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, remove_pcaly_line1, remove_pcaly_line2))

	if remove_esd_act_line:
		# Make sure we have demodulated the ESD excitation channel at the ~30 Hz ESD line
		if options.no_kappac and options.no_fcc and options.no_kappatst and options.no_kappapu and options.no_srcQ and options.no_fs:
			tstexc_at_esd_act_freq = calibration_parts.demodulate(pipeline, tstexc, esd_act_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency)
		if options.factors_from_filters_file:
			esd_act_line = calibration_parts.complex_audioamplify(pipeline, tstexc_at_esd_act_freq, EP10_real, EP10_imag)
		else:
			# EP10 was read from the frames
			EP10 = calibration_parts.merge_into_complex(pipeline, head_dict["EP10_real"], head_dict["EP10_imag"], long_queue, short_queue)
			esd_act_line = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, tstexc_at_esd_act_freq, EP10))
		# Reconstruct a calibrated ESD injection at the ~30 Hz ESD line
		if options.apply_kappatst:
			# Multiply by the real part of kappa_tst
			esd_act_line = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, esd_act_line, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, smooth_ktstRtee, matrix=[[1.0, 0.0]]))))
		esd_act_line = calibration_parts.mkresample(pipeline, esd_act_line, 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoftsr)
		esd_act_line_remove = pipeparts.mkgeneric(pipeline, esd_act_line, "lal_demodulate", line_frequency = -1.0 * esd_act_line_freq, prefactor_real = 2.0)
		esd_act_line_remove = pipeparts.mkgeneric(pipeline, esd_act_line_remove, "creal")
		# Add into the total line removal stream
		calibration_lines = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibration_lines, esd_act_line_remove))

	if remove_high_pcal_line:
		# Demodulate pcal at the ~1kHz pcal line
		pcaly_line3 = calibration_parts.demodulate(pipeline, pcaltee, high_pcal_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency, prefactor_real = pcal_corr_at_high_line_freq_real, prefactor_imag = pcal_corr_at_high_line_freq_imag)
		# Reconstruct a calibrated pcal at only the ~1kHz pcal line
		pcaly_line3 = calibration_parts.mkresample(pipeline, pcaly_line3, 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoftsr)
		pcaly_line3 = pipeparts.mkgeneric(pipeline, pcaly_line3, "lal_demodulate", line_frequency = -1.0 * high_pcal_line_freq, prefactor_real = 2.0)
		remove_pcaly_line3 = pipeparts.mkgeneric(pipeline, pcaly_line3, "creal")
		# Add into the total line removal stream
		calibration_lines = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibration_lines, remove_pcaly_line3))

	if remove_roaming_pcal_line:
		# Demodulate pcal at the ~3kHz pcal line
		pcaly_line4 = calibration_parts.demodulate(pipeline, pcaltee, roaming_pcal_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency, prefactor_real = pcal_corr_at_roaming_line_real, prefactor_imag = pcal_corr_at_roaming_line_imag)
		# Reconstruct a calibrated pcal at only the ~3kHz pcal line
		pcaly_line4 = calibration_parts.mkresample(pipeline, pcaly_line4, 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoftsr)
		pcaly_line4 = pipeparts.mkgeneric(pipeline, pcaly_line4, "lal_demodulate", line_frequency = -1.0 * roaming_pcal_line_freq, prefactor_real = 2.0)
		remove_pcaly_line4 = pipeparts.mkgeneric(pipeline, pcaly_line4, "creal")
		# Add into the total line removal stream
		calibration_lines = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibration_lines, remove_pcaly_line4))

	if remove_src_pcal_line:
		# Make sure we have demodulated pcal at the ~8 Hz pcal line
		if options.no_fs and options.no_srcQ:
			pcal_at_src_freq = calibration_parts.demodulate(pipeline, pcaltee, src_pcal_line_freq, td, options.compute_factors_sr, options.demodulation_filter_time, options.filter_latency, prefactor_real = pcal_corr_at_src_freq_real, prefactor_imag = pcal_corr_at_src_freq_imag)
		# Reconstruct a calibrated pcal at only the ~3kHz pcal line
		pcaly_line0 = calibration_parts.mkresample(pipeline, pcal_at_src_freq, 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoftsr)
		pcaly_line0 = pipeparts.mkgeneric(pipeline, pcaly_line0, "lal_demodulate", line_frequency = -1.0 * src_pcal_line_freq, prefactor_real = 2.0)
		remove_pcaly_line0 = pipeparts.mkgeneric(pipeline, pcaly_line0, "creal")
		# Add into the total line removal stream
		calibration_lines = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibration_lines, remove_pcaly_line0))

	# Divide the calibration lines we are removing by the arm length
	try:
		calibration_lines = pipeparts.mkaudioamplify(pipeline, calibration_lines, -1.0/float(filters["arm_length"]))
	except KeyError:
		calibration_lines = pipeparts.mkaudioamplify(pipeline, calibration_lines, -1.0/3994.5)

	clean_strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, straintee, calibration_lines))

# Next, remove 60 power lines and harmonics
if options.remove_powerlines:
	if not options.remove_callines:
		clean_strain = straintee
	powerlines = calibration_parts.caps_and_progress(pipeline, head_dict["powerlines"], "audio/x-raw, format=F64LE, channels=1, channel-mask=(bitmask)0x0", "powerlines")
	clean_strain = calibration_parts.remove_harmonics_with_witness(pipeline, clean_strain, powerlines, 60, 5, options.powerlines_freq_var, options.filter_latency, compute_rate = options.compute_factors_sr, rate_out = hoftsr, num_avg = 320, obsready = None if options.no_dq_vector else obsreadytee)

# Remove excess noise using any provided witness channels
if options.witness_channel_list is not None:
	if not (options.remove_callines or options.remove_powerlines):
		clean_strain = straintee
	if options.no_dq_vector:
		obsreadytee = None
	witnesses = []
	for key in headkeys:
		if key in witness_channel_list:
			witnesses.append(calibration_parts.caps_and_progress(pipeline, head_dict[key], "audio/x-raw, format=F64LE, channels=1, channel-mask=(bitmask)0x0", key))
	if len(witnesses) != len(witness_channel_list):
		print("WARNING: Not all requested witness channels are being used")
	clean_strain = calibration_parts.clean_data(pipeline, clean_strain, hoftsr, witnesses, int(options.witness_channel_sr), int(options.witness_channel_sr), int(options.witness_channel_sr) / 2, 128, int(options.witness_channel_sr) * 3600, int(options.witness_channel_sr) / 2, 10, obsready = None if options.no_dq_vector else obsreadytee)

if options.remove_callines or options.remove_powerlines or options.witness_channel_list is not None:
	clean_strain = pipeparts.mkprogressreport(pipeline, clean_strain, "progress_hoft_cleaned_%s" % instrument)
	clean_straintagstr = "units=strain,channel-name=%sCALIB_STRAIN_CLEAN%s,instrument=%s" % (chan_prefix, chan_suffix, instrument)
	clean_strain = pipeparts.mktaginject(pipeline, clean_strain, clean_straintagstr)

# Produce time-dependent correction factors to be recorded in the frames

record_kappa_caps = "audio/x-raw, format=F32LE, rate=%d" % options.record_factors_sr

# Resample the \kappa_pu channels at the specified recording sample rate and change them to single precision channels
if not options.no_kappapu:

	kpuRout = pipeparts.mkaudioconvert(pipeline, smooth_kpuRtee)
	kpuRout = calibration_parts.mkresample(pipeline, kpuRout, 1, False, record_kappa_caps)
	kpuRout = pipeparts.mkprogressreport(pipeline, kpuRout, "progress_kappa_pu_real_%s" % instrument)

	kpuIout = pipeparts.mkaudioconvert(pipeline, smooth_kpuItee)
	kpuIout = calibration_parts.mkresample(pipeline, kpuIout, 1, False, record_kappa_caps)
	kpuIout = pipeparts.mkprogressreport(pipeline, kpuIout, "progress_kappa_pu_imag_%s" % instrument)

	smooth_kpuR_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kpuR_nogate)
	smooth_kpuR_nogate = calibration_parts.mkresample(pipeline, smooth_kpuR_nogate, 1, False, record_kappa_caps)
	smooth_kpuR_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpuR_nogate, "progress_kappa_pu_real_nogate_%s" % instrument)

	smooth_kpuI_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kpuI_nogate)
	smooth_kpuI_nogate = calibration_parts.mkresample(pipeline, smooth_kpuI_nogate, 1, False, record_kappa_caps)
	smooth_kpuI_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpuI_nogate, "progress_kappa_pu_imag_nogate_%s" % instrument)

# Resample the \kappa_tst channels at the specified recording sample rate and change them to single precision channels
if not options.no_kappatst:

	ktstRout = pipeparts.mkaudioconvert(pipeline, smooth_ktstRtee)
	ktstRout = calibration_parts.mkresample(pipeline, ktstRout, 1, False, record_kappa_caps)
	ktstRout = pipeparts.mkprogressreport(pipeline, ktstRout, "progress_kappa_tst_real_%s" % instrument)

	ktstIout = pipeparts.mkaudioconvert(pipeline, smooth_ktstItee)
	ktstIout = calibration_parts.mkresample(pipeline, ktstIout, 1, False, record_kappa_caps)
	ktstIout = pipeparts.mkprogressreport(pipeline, ktstIout, "progress_kappa_tst_imag_%s" % instrument)

	smooth_ktstR_nogate = pipeparts.mkaudioconvert(pipeline, smooth_ktstR_nogate)
	smooth_ktstR_nogate = calibration_parts.mkresample(pipeline, smooth_ktstR_nogate, 1, False, record_kappa_caps)
	smooth_ktstR_nogate = pipeparts.mkprogressreport(pipeline, smooth_ktstR_nogate, "progress_kappa_tst_real_nogate_%s" % instrument)

	smooth_ktstI_nogate = pipeparts.mkaudioconvert(pipeline, smooth_ktstI_nogate)
	smooth_ktstI_nogate = calibration_parts.mkresample(pipeline, smooth_ktstI_nogate, 1, False, record_kappa_caps)
	smooth_ktstI_nogate = pipeparts.mkprogressreport(pipeline, smooth_ktstI_nogate, "progress_kappa_tst_imag_nogate_%s" % instrument)

# Resample the \kappa_c channels at the specified recording sample rate and change it to a single precision channel
if not options.no_kappac:
	kcout = pipeparts.mkaudioconvert(pipeline, smooth_kctee)
	kcout = calibration_parts.mkresample(pipeline, kcout, 1, False, record_kappa_caps)
	kcout = pipeparts.mkprogressreport(pipeline, kcout, "progress_kappa_c_%s" % instrument)

	smooth_kc_nogate = pipeparts.mkaudioconvert(pipeline, smooth_kc_nogate)
	smooth_kc_nogate = calibration_parts.mkresample(pipeline, smooth_kc_nogate, 1, False, record_kappa_caps)
	smooth_kc_nogate = pipeparts.mkprogressreport(pipeline, smooth_kc_nogate, "progress_kappa_c_nogate_%s" % instrument)

# Resample the f_cc channels at the specified recording sample rate and change it to a single precision channel
if not options.no_fcc:
	fccout = pipeparts.mkaudioconvert(pipeline, smooth_fcctee)
	fccout = calibration_parts.mkresample(pipeline, fccout, 1, False, record_kappa_caps)
	fccout = pipeparts.mkprogressreport(pipeline, fccout, "progress_f_cc_%s" % instrument)

	smooth_fcc_nogate = pipeparts.mkaudioconvert(pipeline, smooth_fcc_nogate)
	smooth_fcc_nogate = calibration_parts.mkresample(pipeline, smooth_fcc_nogate, 1, False, record_kappa_caps)
	smooth_fcc_nogate = pipeparts.mkprogressreport(pipeline, smooth_fcc_nogate, "progress_f_cc_nogate_%s" % instrument)

# Resample the f_s channels at the specified recording sample rate and change it to a single precision channel
if not options.no_fs:
	fsout = pipeparts.mkaudioconvert(pipeline, smooth_fs)
	fsout = calibration_parts.mkresample(pipeline, fsout, 1, False, record_kappa_caps)
	fsout = pipeparts.mkprogressreport(pipeline, fsout, "progress_f_s_%s" % instrument)

	smooth_fs_nogate = pipeparts.mkaudioconvert(pipeline, smooth_fs_nogate)
	smooth_fs_nogate = calibration_parts.mkresample(pipeline, smooth_fs_nogate, 1, False, record_kappa_caps)
	smooth_fs_nogate = pipeparts.mkprogressreport(pipeline, smooth_fs_nogate, "progress_f_s_nogate_%s" % instrument)

# Resample the f_s channels at the specified recording sample rate and change it to a single precision channel
if not options.no_srcQ:
	srcQ_inv_out = pipeparts.mkaudioconvert(pipeline, smooth_srcQ_inv)
	srcQ_inv_out = calibration_parts.mkresample(pipeline, srcQ_inv_out, 1, False, record_kappa_caps)
	srcQ_inv_out = pipeparts.mkprogressreport(pipeline, srcQ_inv_out, "progress_SRC_Q_%s" % instrument)

	smooth_srcQ_inv_nogate = pipeparts.mkaudioconvert(pipeline, smooth_srcQ_inv_nogate)
	smooth_srcQ_inv_nogate = calibration_parts.mkresample(pipeline, smooth_srcQ_inv_nogate, 1, False, record_kappa_caps)
	smooth_srcQ_inv_nogate = pipeparts.mkprogressreport(pipeline, smooth_srcQ_inv_nogate, "progress_SRC_Q_nogate_%s" % instrument)

#
# CREATE MUXER AND HOOK EVERYTHING UP TO IT
#

mux = pipeparts.mkframecppchannelmux(pipeline, None)

if options.frame_duration is not None:
	mux.set_property("frame-duration", options.frame_duration)
if options.frames_per_file is not None:
	mux.set_property("frames-per-file", options.frames_per_file)
mux.set_property("compression-scheme", options.compression_scheme)
mux.set_property("compression-level", options.compression_level)

# Link the output DQ vectors up to the muxer, if applicable
if not options.no_dq_vector:
	calibration_parts.mkqueue(pipeline, calibstatevector).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STATE_VECTOR%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, odcstatevectortee).get_static_pad("src").link(mux.get_request_pad("%s:%s" % (instrument, options.dq_channel_name)))

# Link the strain branch to the muxer
calibration_parts.mkqueue(pipeline, strain).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STRAIN%s" % (instrument, chan_prefix, chan_suffix)))

# Link the cleaned strain branch to the muxer if h(t) was cleaned in any way
if options.remove_callines or options.remove_powerlines or options.witness_channel_list is not None:
	calibration_parts.mkqueue(pipeline, clean_strain).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STRAIN_CLEAN%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of \kappa_tst to the muxer
if not options.no_kappatst:
	calibration_parts.mkqueue(pipeline, ktstRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, ktstIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_ktstR_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_ktstI_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of \kappa_pu to the muxer
if not options.no_kappapu:
	calibration_parts.mkqueue(pipeline, kpuRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, kpuIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kpuR_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kpuI_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the \kappa_c to the muxer
if not options.no_kappac:
	calibration_parts.mkqueue(pipeline, kcout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_C%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_kc_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_C_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the f_cc to the muxer
if not options.no_fcc:
	calibration_parts.mkqueue(pipeline, fccout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_CC%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_fcc_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_CC_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the f_s to the muxer
if not options.no_fs:
	calibration_parts.mkqueue(pipeline, fsout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_S%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_fs_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_S_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Link the src_Q to the muxer
if not options.no_srcQ:
	calibration_parts.mkqueue(pipeline, srcQ_inv_out).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_SRC_Q_INVERSE%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, smooth_srcQ_inv_nogate).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_SRC_Q_INVERSE_NOGATE%s" % (instrument, chan_prefix, chan_suffix)))

# Check that all frames are long enough, that they have all of the channels by requring a certain amount of time from start-up, and that frames aren't written for times requested by the wings option
def check_complete_frames(pad, info, (output_start, frame_duration, wings_start, wings_end)):
	buf = info.get_buffer()
	startts = lal.LIGOTimeGPS(0, buf.pts)
	duration = lal.LIGOTimeGPS(0, buf.duration)
	if not (startts % frame_duration == 0):
		return Gst.PadProbeReturn.DROP
	if startts < output_start:
		return Gst.PadProbeReturn.DROP
	if duration != frame_duration:
		return Gst.PadProbeReturn.DROP
	if wings_start is not None and wings_end is not None:
		if startts < wings_start or (startts+duration) > wings_end:
			return Gst.PadProbeReturn.DROP
	return Gst.PadProbeReturn.OK
if options.data_source == "frames":
	start = int(options.gps_start_time)
elif options.data_source == "lvshm":
	tm = time.gmtime()
	start = int(lal.UTCToGPS(tm))
# start time of first frame file is the desired start time + either filter latency or kappa settling (if computing kappas), whichever is bigger
if not options.no_kappatst or not options.no_kappapu or not options.no_kappac or not options.no_fcc:
	output_start = start + max(int(filter_settle_time), options.demodulation_filter_time + options.median_smoothing_time + options.factors_averaging_time)
else:
	output_start = start + int(filter_settle_time)

# If the wings option is set, need to also check that frames aren't written during the requested wing time
if options.wings is not None:
	wings_start = int(options.gps_start_time) + options.wings
	wings_end = int(options.gps_end_time) - options.wings
	mux.get_static_pad("src").add_probe(Gst.PadProbeType.BUFFER, check_complete_frames, (lal.LIGOTimeGPS(output_start,0), lal.LIGOTimeGPS(options.frame_duration*options.frames_per_file,0), lal.LIGOTimeGPS(wings_start, 0), lal.LIGOTimeGPS(wings_end, 0)))
else:
	mux.get_static_pad("src").add_probe(Gst.PadProbeType.BUFFER, check_complete_frames, (lal.LIGOTimeGPS(output_start,0), lal.LIGOTimeGPS(options.frame_duration*options.frames_per_file,0), None, None))

mux = pipeparts.mkprogressreport(pipeline, mux, "progress_sink_%s" % instrument)

if options.write_to_shm_partition is not None:
	pipeparts.mkgeneric(pipeline, mux, "gds_lvshmsink", sync=False, async=False, shm_name = options.write_to_shm_partition, num_buffers=10, blocksize=options.frame_size*options.frame_duration*options.frames_per_file, buffer_mode=options.buffer_mode)
else:
	pipeparts.mkframecppfilesink(pipeline, mux, frame_type = options.frame_type, path = options.output_path, instrument = instrument) 

# Run pipeline

if options.write_pipeline is not None:
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(options.write_pipeline, "NULL"), verbose = options.verbose)

# Seek the pipeline when necessary
if options.data_source == "frames":
	if options.verbose:
		print >>sys.stderr, "seeking GPS start and stop times ..."
	if pipeline.set_state(Gst.State.READY) != Gst.StateChangeReturn.SUCCESS:
		raise RuntimeError("pipeline failed to enter READY state")
	datasource.pipeline_seek_for_gps(pipeline, gps_start_time, gps_end_time)

if options.verbose:
	print >>sys.stderr, "setting pipeline state to playing ..."
if pipeline.set_state(Gst.State.PLAYING) != Gst.StateChangeReturn.SUCCESS:
	raise RuntimeError("pipeline failed to enter PLAYING state")
else:
	print "set to playing successfully"
if options.write_pipeline is not None:
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(options.write_pipeline, "PLAYING"), verbose = options.verbose)
	
if options.verbose:
	print >>sys.stderr, "running pipeline ..."

mainloop.run()

if pipeline.set_state(Gst.State.NULL) != Gst.StateChangeReturn.SUCCESS:
	raise RuntimeError("pipeline could not be set to NULL")
