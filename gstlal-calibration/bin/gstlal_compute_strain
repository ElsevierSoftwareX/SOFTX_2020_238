#!/usr/bin/env python
#
# Copyright (C) 2010-2015  Jordi Burguet-Castell, Madeline Wade
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


"""
This pipeline produces h(t) given DARM_ERR and DARM_CTRL or given DELTAL_RESIDUAL and DELTAL_CTRL. It can be run online in real-time or offline on frame files.  It can write h(t) frames to frame files or to a shared memory partition.  

The differential arm length resulting from external sources is

\Delta L_{ext} = d_{err}/(\kappa_c C) + (A_tst * \kappa_tst + A_usum * \kappa_pu) d_{ctrl}

where C is the sensing function, A_tst is the TST acutuation function, A_usum is the PUM+UIM+TOP actuation, \kappa_c is the time dependent gain of the sensing function, \kappa_tst is the time-dependent gain of TST actuation, and \kappa_pu is the time-dependent gain of the PUM/UIM actuation.  \Delta L_{ext} is divided by the average arm length (4000 km) to obtain h(t), the external strain in the detectors,

h(t) = \Delta L_{ext} / L .

The time-dependent gains (\kappa's) as well as the value for the coupled cavity pole (f_cc), the time-dependent gain of the PUM actuation (\kappa_pu) and the overall time-depenent gain of the actuation (\kappa_a) are calcuated in this pipeline as well.

This pipeline will most often be run in a format where it picks up after part of the actuation and sensing functions have been applied to the apporiate channels.  In this mode, the input channels are \Delta L_{res} and \Delta L_{ctrl}.  This pipeline then applies further high frequency corrections to each of these channels, applies the appropriate time delay to each channel, adds the channels together, and divides by L.

h(t) = (\Delta L_{res} * (1 / \kappa_c) * corrections + (\Delta L_{ctrl, TST} * \kappa_tst + \Delta L_{ctrl, USUM} * \kappa_pu) * corrections) / L

Note: The \kappa's are complex numbers.  Only the real part of the computed \kappa's are applied as time-dependent gain corrections.

Further documentation explaining the time domain calibration procedure can be found in LIGO DCC #T1400256.

For a full list of example command lines that were used to create the O1 h(t) frames, see https://wiki.ligo.org/Calibration/GDSCalibrationConfigurationsO1.

Type gstlal_compute_strain --help to see the full list of command line options.
"""

import sys
import os
import numpy
import time
import resource

from optparse import OptionParser, Option

import gi
gi.require_version('Gst', '1.0')
from gi.repository import GObject, Gst
GObject.threads_init()
Gst.init(None)

import lal

from gstlal import pipeparts
from gstlal import calibration_parts
from gstlal import simplehandler
from gstlal import datasource

from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
from glue.ligolw.utils import segments as ligolw_segments
array.use_in(ligolw.LIGOLWContentHandler)
param.use_in(ligolw.LIGOLWContentHandler)
from glue.ligolw import utils
from glue import segments

def write_graph(demux):
	pipeparts.write_dump_dot(pipeline, "%s.%s" % (options.write_pipeline, "PLAYING"), verbose = True)

#
# Make sure we have sufficient resources
# We allocate far more memory than we need, so this is okay
#

def setrlimit(res, lim):
	hard_lim = resource.getrlimit(res)[1]
	resource.setrlimit(res, (lim if lim is not None else hard_lim, hard_lim))
# set the number of processes and total set size up to hard limit and
# shrink the per-thread stack size (default is 10 MiB)
setrlimit(resource.RLIMIT_NPROC, None)
setrlimit(resource.RLIMIT_AS, None)
setrlimit(resource.RLIMIT_RSS, None)
setrlimit(resource.RLIMIT_STACK, 1024*1024) 

def now():
	return lal.LIGOTimeGPS(lal.UTCToGPS(tim.gmtime()), 0)
	

###################################################################################################
############################## Program Command Line Options #######################################
###################################################################################################

parser = OptionParser(description = __doc__)

# Append program specific options

# These options should be used whether the pipeline runs in full calibration mode or partial calibration mode
parser.add_option("--data-source", metavar = "source", help = "Set the data source from [frames|lvshm]. Required.")
parser.add_option("--frame-cache", metavar = "filename", help = "Set the name of the LAL cache listing the LIGO .gwf frame files (optional).  This is required iff --data-source=frames")
parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the start time of the segment to analyze in GPS seconds. This is required iff --data-source=frames")
parser.add_option("--gps-end-time", metavar = "seconds", help = "Set the end time of the segment to analyze in GPS seconds. This is required iff --data-source=frames")
parser.add_option("--wings", metavar = "seconds", type = "int", help = "Number of seconds to trim off of the beginning and end of the output. Should only be used if --data-source=frames.")
parser.add_option("--do-file-checksum", action = "store_true", help = "Set this option to turn on file checksum in the demuxer.")
parser.add_option("--dq-channel-name", metavar = "name", default = "ODC-MASTER_CHANNEL_OUT_DQ", help = "Set the name of the data quality (or state vector) channel. (Default=ODC-MASTER_CHANNEL_OUT_DQ)")
parser.add_option("--ifo", metavar = "name", help = "Name of the IFO to be calibrated.")
parser.add_option("--shared-memory-partition", metavar = "name", help = "Set the name of the shared memory partition to read from.  This is required iff --data-source=lvshm.")
parser.add_option("--frame-segments-file", metavar = "filename", help = "Set the name of the LIGO light-weight XML file from which to load frame segments.  This is required iff --data-source=frames")
parser.add_option("--frame-segments-name", metavar = "name", help = "Set the name of the segments to extract from the segment tables.  This is required iff --frame-segments-file is given")
parser.add_option("--hoft-sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate at which to generate strain data. This should be less than or equal to the sample rate of the error and control signal channels. (Default = 16384 Hz)")
parser.add_option("--control-sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate of the control signal channels. (Default = 16384 Hz)")
parser.add_option("--odc-sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate of the ODC state vector channel. (Default = 16384 Hz)")
parser.add_option("--calib-state-sample-rate", metavar = "Hz", default = 16, type = "int", help = "Sample rate for the outgoing DQ vector GDS-CALIB_STATE_VECTOR. (Default = 16 Hz)")
parser.add_option("--tst-exc-sample-rate", metavar = "Hz", default = 512, type = "int", help = "Sample rate for the control signals being read in. (Default = 512 Hz)")
parser.add_option("--coh-sample-rate", metavar = "Hz", default = 16, type = "int", help = "Sample rate for the coherence uncertainty channels. (Default = 16 Hz).")
parser.add_option("--frame-duration", metavar = "seconds", type = "int", default = 4, help = "Set the number of seconds for each frame. (Default = 4)")
parser.add_option("--frames-per-file", metavar = "count", type = "int", default = 1, help = "Set the number of frames per frame file. (Default = 1)")
parser.add_option("--frame-size", metavar = "bytes", type = "int", default = 405338, help = "Approximate size in bytes of frame file images; used when writing to shared memory.  (Default=405338)")
parser.add_option("--compression-scheme", metavar = "scheme", type = "int", default = 256, help = "Set the compression scheme for the framecpp_channelmux element. (Default=256, no compression)")
parser.add_option("--compression-level", metavar = "level", type = "int", default = 0, help = "Set the compression level for the framecpp_channelmux element. (Default=0)")
parser.add_option("--write-to-shm-partition", metavar = "name", help = "Set the name of the shared memory partition to write to. If this is not provided, frames will be written to a file.")
parser.add_option("--buffer-mode", metavar = "number", type = "int", default = 2, help = "Set the buffer mode for the lvshmsink element. (Default=2)")
parser.add_option("--frame-type", metavar = "name", default = "TEST", help = "Set the frame type as input to the frame writing element. (Default=TEST)")
parser.add_option("--output-path", metavar = "name", default = ".", help = "Set the output path for writing frame files. (Default=Current)")
parser.add_option("--no-dq-vector", action = "store_true", help = "Set this if you want to turn off all interpretation and calculation of a data quality vector.")
parser.add_option("--frequency-domain-filtering", action = "store_true", help = "Set this to perform filtering routines in the frequency domain instead of using direct convolution.")
parser.add_option("--obs-ready-bitmask", metavar = "bitmask", type = "int", default = 4, help = "Bitmask used on ODC state vector in order to determine OBSERVATION_READY bit information. (Default=4)")
parser.add_option("--obs-intent-bitmask", metavar = "bitmask", type = "int", default = 2, help = "Bitmask used on ODC state vector in order to determine OBSERVATION_INTENT bit information. (Default=2)")
parser.add_option("--hw-inj-cbc-bitmask", metavar = "bitmask", type = "int", default = 16777216, help = "Bitmask used on ODC state vector in order presence of CBC hardware injection. (Default=16777216)")
parser.add_option("--hw-inj-burst-bitmask", metavar = "bitmask", type = "int", default = 33554432, help = "Bitmask used on ODC state vector in order presence of burst hardware injection. (Default=33554432)")
parser.add_option("--hw-inj-detchar-bitmask", metavar = "bitmask", type = "int", default = 67108864, help = "Bitmask used on ODC state vector in order presence of DetChar hardware injection. (Default=67108864)")
parser.add_option("--hw-inj-stoch-bitmask", metavar = "bitmask", type = "int", default = 8388608, help = "Bitmask used on ODC state vector in order presence of stochastic hardware injection. (Default=8388608)")
parser.add_option("--chan-prefix", metavar = "name", default = "GDS-", help = "Prefix for all output channel names. (Default = GDS)") 
parser.add_option("--chan-suffix", metavar = "name", help = "Suffix for all output channel names.") 

# These are debugging options
parser.add_option("--write-pipeline", metavar = "filename", help = "Write a DOT graph description of the as-built pipeline to this file (optional).  The environment variable GST_DEBUG_DUMP_DOT_DIR must be set for this option to work.")
parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")

# These are options specific to the calibration procedure
parser.add_option("--filters-file", metavar="filename", help = "Name of file containing filters (in npz format)")
parser.add_option("--factors-from-filters-file", action = "store_true", help = "Compute the calibration factors from reference values contained in the filters file instead of from EPICS channels.")
parser.add_option("--no-coherence", action = "store_true", help = "Gate the calibration factors with a pre-computed coherence channel.")
parser.add_option("--coherence-uncertainty-threshold", metavar = "float", type = float, default = 0.20, help = "Threshold for the coherence uncertainty for each calibration line. (Default = 0.20)")
parser.add_option("--coh-unc-sus-line1-channel", metavar="name", default="CAL-CS_TDEP_SUS_LINE1_UNCERTAINTY", help = "Channel name for SUS line 1 coherence uncertainty. (Default=CAL-CS_TDEP_SUS_LINE1_UNCERTAINTY)")
parser.add_option("--coh-unc-pcaly-line1-channel", metavar="name", default="CAL-CS_TDEP_PCALY_LINE1_UNCERTAINTY", help = "Channel name for PCALY line 1 coherence uncertainty. (Default=CAL-CS_TDEP_PCALY_LINE1_UNCERTAINTY)")
parser.add_option("--coh-unc-pcaly-line2-channel", metavar="name", default="CAL-CS_TDEP_PCALY_LINE2_UNCERTAINTY", help = "Channel name for PCALY line 2 coherence uncertainty. (Default=CAL-CS_TDEP_PCALY_LINE2_UNCERTAINTY)")
parser.add_option("--coh-unc-darm-line1-channel", metavar="name", default="CAL-CS_TDEP_DARM_LINE1_UNCERTAINTY", help = "Channel name for DARM line 1 coherence uncertainty. (Default=CAL-CS_TDEP_DARM_LINE1_UNCERTAINTY)")
parser.add_option("--no-kappatst", action = "store_true", help = "Set this to turn off the calculation of \kappa_tst.")
parser.add_option("--no-kappapu", action = "store_true", help = "Set this to turn off the calculation of \kappa_pu.")
parser.add_option("--no-kappaa", action = "store_true", help = "Set this to turn off the calculation of \kappa_a.")
parser.add_option("--no-kappac", action = "store_true", help = "Set this to turn off the calculation of \kappa_c.")
parser.add_option("--no-fcc", action = "store_true", help = "Set this to turn off the calculation of f_cc.")
parser.add_option("--factors-averaging-time", metavar = "Sec", type = int, default = 10, help = "Time over which to average the smoothed time-varying calibration factors (\kappas), given in seconds. (Default = 10 seconds)")
parser.add_option("--apply-kappapu", action = "store_true", help = "Set this to have the \kappa_pu factors multiply the actuation chain.")
parser.add_option("--apply-kappatst", action = "store_true", help = "Set this to have the \kappa_tst factors multiply the actuation chain.")
parser.add_option("--apply-kappac", action = "store_true", help = "Set this to have the \kappa_c factors multiply the sensing chain.")
parser.add_option("--compute-factors-sr", metavar = "Hz", type = int, default = 16, help = "Sample rate at which calibration factors are computed. (Default = 16 Hz)")
parser.add_option("--median-smoothing-time", metavar = "s", type = int, default = 128, help = "Time (in seconds) to smooth out \kappas with a median-like method. (Default = 128 s)")
parser.add_option("--record-factors-sr", metavar = "Hz", type = int, default = 16, help = "Sample rate at which calibration factors are recorded. (Default = 16 Hz)")
parser.add_option("--expected-kappaa-real", metavar = "float", type = float, default = 1.0, help = "Expected value for the real part of \kappa_a. (Default = 1.0)")
parser.add_option("--expected-kappapu-real", metavar = "float", type = float, default = 1.0, help = "Expected value for the real part of \kappa_pu. (Default = 1.0)")
parser.add_option("--expected-kappatst-real", metavar = "float", type = float, default = 1.0, help = "Expected value for the real part of \kappa_tst. (Default = 1.0)")
parser.add_option("--expected-kappaa-imag", metavar = "float", type = float, default = 0.0, help = "Expected value for the imaginary part of \kappa_a. (Default = 0.0)")
parser.add_option("--expected-kappapu-imag", metavar = "float", type = float, default = 0.0, help = "Expected value for the imaginary part of \kappa_pu. (Default = 0.0)")
parser.add_option("--expected-kappatst-imag", metavar = "float", type = float, default = 0.0, help = "Expected value for the imaginary part of \kappa_tst. (Default = 0.0)")
parser.add_option("--expected-kappac", metavar = "float", type = float, default = 1.0, help = "Expected value for \kappa_c. (Default = 1.0)")
parser.add_option("--expected-fcc", metavar = "Hz", type = float, default = 330.0, help = "Expected value for the coupled cavity pole. (Default = 330.0 Hz)")
parser.add_option("--kappaa-real-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of the real part of \kappa_a +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--kappapu-real-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of the real part of \kappa_pu +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--kappatst-real-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of the real part of \kappa_tst +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--kappaa-imag-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of the imaginary part of \kappa_a +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--kappapu-imag-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of the imaginary part of \kappa_pu +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--kappatst-imag-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of the imaginary part of \kappa_tst +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--kappac-ok-var", metavar = "float", type = float, default = 0.2, help = "Values of \kappa_c +/- this number will be considered OK. (Default = 0.2)")
parser.add_option("--fcc-ok-var", metavar = "Hz", type = float, default = 50, help = "Values of f_cc +/- this number (in Hz) will be considered OK. (Default = 50 Hz)")
parser.add_option("--exc-channel-name", metavar = "name", default = "CAL-CS_LINE_SUM_DQ", help = "Set the name of the excitation channel.  This is only necessary when the calibration factors computation is turned on, which is the default behavior. (Default = CAL-CS_LINE_SUM_DQ)")
parser.add_option("--tst-exc-channel-name", metavar = "name", default = "SUS-ETMY_L3_CAL_LINE_OUT_DQ", help = "Set the name of the TST excitation channel.  This is only necessary when the \kappa_tst factors computation is turned on, which is the default behavior. (Default = SUS-ETMY_L3_CAL_LINE_OUT_DQ)")
parser.add_option("--pcal-channel-name", metavar = "name", default = "CAL-PCALY_RX_PD_OUT_DQ", help = "Set the name of the PCal channel used for calculating the calibration factors. (Default = CAL-PCALY_RX_PD_OUT_DQ)")
parser.add_option("--dewhitening", action = "store_true", help = "Dewhitening should be used on the relevant channels, since the incoming channels are whitened and single precision.")

# These are all options related to the reference channels used in the calibration factors computation
parser.add_option("--ref-channels-sr", metavar = "Hz", default = 16, help = "Set the sample rate for the reference model channels used in the calibration factors calculation. (Default = 16 Hz)")
parser.add_option("--EP4-real", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_TST_REAL", help = "Set the name of the channel containing the real part of A_tst at the ESD line used for the \kappa_a and \kappa_pu calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_TST_REAL)")
parser.add_option("--EP5-real", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_REAL", help = "Set the name of the channel containing the real part of A_pu at the ESD line used for the \kappa_a calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_REAL)")
parser.add_option("--EP3-real", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_REAL", help = "Set the name of the channel containing the real part of 1/A_pu at the ESD line used for the \kappa_pu calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_REAL)")
parser.add_option("--EP4-imag", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_TST_IMAG", help = "Set the name of the channel containing the imaginary part of A_tst at the ESD line used for the \kappa_a and \kappa_pu calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_TST_IMAG")
parser.add_option("--EP5-imag", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_IMAG", help = "Set the name of the channel containing the imaginary part of A_pu at the ESD line used for the \kappa_A calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_IMAG")
parser.add_option("--EP3-imag", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_IMAG", help = "Set the name of the channel containing the imaginary part of 1/A_pu at the ESD line used for the \kappa_PU calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_IMAG")
parser.add_option("--EP2-real", metavar = "name", default = "CAL-CS_TDEP_REF_CLGRATIO_CTRL_REAL", help = "Set the name of the channel containing the real part of the factors used to compute A(f_ctrl). (Default = CAL-CS_TDEP_REF_CLGRATIO_CTRL_REAL)")
parser.add_option("--EP2-imag", metavar = "name", default = "CAL-CS_TDEP_REF_CLGRATIO_CTRL_IMAG", help = "Set the name of the channel containing the imaginary part of the factors used to compute A(f_ctrl). (Default = CAL-CS_TDEP_REF_CLGRATIO_CTRL_IMAG)")
parser.add_option("--EP6-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_REAL", help = "Set the name of the channel containing the real part of C_res at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_REAL")
parser.add_option("--EP6-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_IMAG", help = "Set the name of the channel containing the imaginary part of C_res at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_IMAG")
parser.add_option("--EP7-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_D_REAL", help = "Set the name of the channel containing the real part of D at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_D_REAL")
parser.add_option("--EP7-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_D_IMAG", help = "Set the name of the channel containing the real part of D at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_D_IMAG")
parser.add_option("--EP8-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_REAL", help = "Set the name of the channel containing the real part of A_tst at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_REAL")
parser.add_option("--EP8-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_IMAG", help = "Set the name of the channel containing the real part of A_tst at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_IMAG")
parser.add_option("--EP9-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_REAL", help = "Set the name of the channel containing the real part of A_pu at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_REAL")
parser.add_option("--EP9-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_IMAG", help = "Set the name of the channel containing the real part of A_pu at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_IMAG")
parser.add_option("--EP1-real", metavar = "name", default = "CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_REAL", help = "Set the name of the channel containing the real part of the \kappa_tst reference factors. (Default = CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_REAL)")
parser.add_option("--EP1-imag", metavar = "name", default = "CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_IMAG", help = "Set the name of the channel containing the imaginary part of the \kappa_tst reference factors. (Default = CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_IMAG)")
parser.add_option("--different-control-whitening", action = "store_true", help = "Set when the whitening filters on each section of control chain are different. Only relevant in --split-actuation-chain mode") 

# These options are specific to the full calibration mode
parser.add_option("--full-calibration", action = "store_true", help = "Set this to run the pipeline in full calibration mode.")
parser.add_option("--darm-ctrl-channel-name", metavar = "name", default = "CAL-DARM_CTRL_WHITEN_OUT_DBL_DQ", help = "Set the name for the control signal channel. (Default = CAL-DARM_CTRL_WHTIEN_OUT_DBL_DQ)")
parser.add_option("--darm-err-channel-name", metavar = "name", default = "CAL-DARM_ERR_WHITEN_OUT_DBL_DQ", help = "Set the name of the error signal channel. (Default = CAL-DARM_ERR_WHITEN_OUT_DBL_DQ)")

# These options are specific to the partial calibration mode
parser.add_option("--partial-calibration", action = "store_true", help = "Set this to run the pipeline in partial calibraiton mode.")
parser.add_option("--deltal-tst-channel-name", metavar = "name", default = "CAL-DELTAL_CTRL_TST_DBL_DQ", help = "Set the name of the partially calibrated control channel for the TST branch of the actuation. (Default = CAL-DELTAL_CTRL_TST_DBL_DQ)")
parser.add_option("--deltal-pum-channel-name", metavar = "name", default = "CAL-DELTAL_CTRL_PUM_DBL_DQ", help = "Set the name of the partially calibrated control channel for the PUM/UIM branch of the actuation. (Default = CAL-DELTAL_CTRL_PUM_DBL_DQ)")
parser.add_option("--deltal-uim-channel-name", metavar = "name", default = "CAL-DELTAL_CTRL_UIM_DBL_DQ", help = "Set the name of the partially calibrated control channel for the PUM/UIM branch of the actuation. (Default = CAL-DELTAL_CTRL_UIM_DBL_DQ)")
parser.add_option("--deltal-res-channel-name", metavar = "name", default = "CAL-DELTAL_RESIDUAL_DBL_DQ", help = "Set the name of the partially calibrated residual channe. (Default = CAL-DELTAL_RESIDUAL_DBL_DQ).")

# Parse options

options, filenames = parser.parse_args()

# Sanity checks for command line options
data_sources = set(("frames", "lvshm"))

if options.data_source not in data_sources:
	raise ValueError("--data-source must be one of %s" % ",".join(data_sources))

if options.data_source == "frames" and options.frame_cache is None:
	raise ValueError("--frame-cache must be specified when using --data-source=frames")

if options.wings is not None and options.data_source != "frames":
	raise ValueError("--wings can only be set when --data-source=frames")

if options.ifo is None:
	raise ValueError("must specify --ifo")

if options.frame_segments_file is not None and options.data_source != "frames":
	raise ValueError("can only give --frame-segments-file if --data-source=frames")

if options.frame_segments_name is not None and options.frame_segments_file is None:
	raise ValueError("can only specify --frame-segments-name if --frame-segments-file is given")

if options.data_source == "frames" and (options.gps_start_time is None or options.gps_end_time is None):
	raise ValueError("must specify --gps-start-time and --gps-end-time when --data-source=frames")

if options.full_calibration is None and options.partial_calibration is None or (options.full_calibration is not None and options.partial_calibration is not None):
	raise ValueError("must specify one (and only one) mode of the pipeline: either --full-calibration or --partial-calibration")

if int(options.record_factors_sr) > int(options.compute_factors_sr):
	raise ValueError("--record-factors-sr must be less than or equal to --compute-factors-sr")

if options.gps_start_time is not None:
	if options.gps_end_time is None:
		raise ValueError("must provide both --gps-start-time and --gps-end-time")
	if options.data_source == "lvshm" or options.data_source == "white":
		raise ValueError("cannot set --gps-start-time or --gps-end-time with --data-source=lvshm or --data-source=white")
	try:
		start = lal.LIGOTimeGPS(options.gps_start_time)
	except ValueError:
		raise ValueError("invalid --gps-start-time %s" % options.gps_start_time)
	try:
		end = lal.LIGOTimeGPS(options.gps_end_time)
	except ValueError:
		raise ValueError("invalid --gps-end-time %s" % options.gps_end_time)
	if start >= end:
		raise ValueError("--gps-start-time must be < --gps-end-time: %s < %s" % (options.gps_start_time, options.gps_end_time))
	# segment from gps start and stop time if given
	seg = segments.segment(start, end)
	gps_start_time = seg[0]
	gps_end_time = seg[1]
elif options.gps_end_time is not None:
	raise ValueError("must provide both --gps-start-time and --gps-end-time")

###################################################################################################
######################################## Setup ####################################################
###################################################################################################

# Set up instrument and channel name info from command line options
instrument = options.ifo

# Make segment list if a frame segmentse file is provided, other set frame_segments to None
if options.frame_segments_file is not None:
	# Frame segments from a user defined file
	frame_segments = ligolw_segments.segmenttable_get_by_name(utils.load_filename(options.frame_segments_file, contenthandler = datasource.ContentHandler), options.frame_segments_name).coalesce()
	if seg is not None:
		# clip frame segments to seek segment if it exists (not required, just saves some meory and I/O overhead)
		frame_segments = segments.segmentlistdict((instrument, seglist & segments.segmentlist([seg])) for instrument, seglist in frame_segments.items())
else:
	frame_segments = None

# Set up short-cut names for each of the sample rates used throughout the pipeline and establish caps string shortcuts
hoftsr = options.hoft_sample_rate  # Sample rate for h(t)
calibstatesr = options.calib_state_sample_rate  # Sample rate for the CALIB_STATE_VECTOR
odcsr = options.odc_sample_rate # Sample rate of the ODC channel that is read in
ctrlsr = options.control_sample_rate # Sample rate of the control channel (such as DARM_CTRL or DELTAL_CTRL)
cohsr = options.coh_sample_rate # Sample rate for the coherence uncertainty channels
hoft_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % hoftsr
ctrl_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % ctrlsr
calibstate_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % calibstatesr
odc_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % odcsr
coh_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % cohsr
# caps strings for the computation kappas
ref_factors_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % options.ref_channels_sr
compute_calib_factors_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0X0" % options.compute_factors_sr
compute_calib_factors_complex_caps = "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % options.compute_factors_sr

# Set up smoothing, averaging and integration sample sizes for kappa calulations
factors_average_samples = int(options.factors_averaging_time) * options.compute_factors_sr
median_smoothing_samples = int(options.median_smoothing_time) * options.compute_factors_sr

# Set up string for the channels suffix and prefix as provided by the user
if options.chan_suffix is not None:
	chan_suffix = options.chan_suffix
else:
	chan_suffix = ""
chan_prefix = options.chan_prefix

# If td is true we will perform filtering in the time domain (direct convolution) in all FIR filtering routines below
td = not options.frequency_domain_filtering

#
# Set up the appropriate channel list
#

# Set up dictionary that will be populated with pipeline branch names based on the channel list
head_dict = {}

# I will also be filling a list called headkeys that will be the keys for the dictionary holding each pipeline branch name
if options.full_calibration: # For full calibration we need DARM_ERR and DARM_CTRL as our input channels
	channel_list = [(instrument, options.darm_ctrl_channel_name), (instrument, options.darm_err_channel_name)]
	headkeys = ["ctrl", "res"]
elif options.partial_calibration: # For partial calibration we need DELTAL_TST, DELTAL_PUM, DELTAL_UIM, and DELTAL_RES
	channel_list = [(instrument, options.deltal_tst_channel_name), (instrument, options.deltal_pum_channel_name), (instrument, options.deltal_uim_channel_name), (instrument, options.deltal_res_channel_name)]
	headkeys = ["tst", "pum", "uim", "res"]
	
# We need to make sure we have DARM_ERR and the PCAL channel for computing \kappas
if not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappatst or not options.no_kappapu:
	if options.partial_calibration:
		channel_list.append((instrument, options.darm_err_channel_name))
		headkeys.append("darm_err")
	channel_list.append((instrument, options.pcal_channel_name))
	headkeys.append("pcal")

# We also need the excitation channel for computing kappas
if (not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappapu):
	channel_list.append((instrument, options.exc_channel_name))
	headkeys.append("exc")
	# If we are computing the factors in the pipeline, we need the reference model EPICS records
	if not options.factors_from_filters_file:
		channel_list.extend(((instrument, options.EP2_real), (instrument, options.EP2_imag), (instrument, options.EP3_real), (instrument, options.EP3_imag), (instrument, options.EP4_real), (instrument, options.EP4_imag)))
		headkeys.extend(("EP2_real", "EP2_imag", "EP3_real", "EP3_imag", "EP4_real", "EP4_imag"))
		if not options.no_kappaa:	
			channel_list.extend(((instrument, options.EP5_real), (instrument, options.EP5_imag)))
			headkeys.extend(("EP5_real", "EP5_imag"))

# If we are computing either kappa_c or f_cc, we need some more EPICS records
if (not options.no_kappac or not options.no_fcc) and not options.factors_from_filters_file:
	channel_list.extend(((instrument, options.EP6_real), (instrument, options.EP6_imag), (instrument, options.EP7_real), (instrument, options.EP7_imag), (instrument, options.EP8_real), (instrument, options.EP8_imag), (instrument, options.EP9_real), (instrument, options.EP9_imag)))
	headkeys.extend(("EP6_real", "EP6_imag", "EP7_real", "EP7_imag", "EP8_real", "EP8_imag", "EP9_real", "EP9_imag"))

# If we are computing kappa_tst, kappa_a or kappa_c, we need more channels
if not options.no_kappatst or not options.no_kappaa or not options.no_kappac or not options.no_fcc:
	channel_list.append((instrument, options.tst_exc_channel_name))
	headkeys.append("tstexc")
	if not options.factors_from_filters_file:
		channel_list.extend(((instrument, options.EP1_real), (instrument, options.EP1_imag)))
		headkeys.extend(("EP1_real", "EP1_imag"))

# If we are using pre-computed coherence to gate kappas
if not options.no_coherence:
	if not options.no_kappatst or not options.no_kappaa or not options.no_kappapu or not options.no_kappac or not options.no_fcc:
		channel_list.extend(((instrument, options.coh_unc_sus_line1_channel), (instrument, options.coh_unc_pcaly_line1_channel)))
		headkeys.extend(("sus_coh", "pcaly_line1_coh"))
	if not options.no_kappapu or not options.no_kappaa or not options.no_kappac or not options.no_fcc:
		channel_list.append((instrument, options.coh_unc_darm_line1_channel))
		headkeys.append("darm_coh")
	if not options.no_kappac or not options.no_fcc:
		channel_list.append((instrument, options.coh_unc_pcaly_line2_channel))
		headkeys.append("pcaly_line2_coh")
	
# If we are computing the CALIB_STATE_VECTOR, we need yet another channel
if not options.no_dq_vector:
	channel_list.append((instrument, options.dq_channel_name))
	headkeys.append("odcstatevector")

#
# Load in the filters file that contains filter coefficients, etc.
#

filters = numpy.load(options.filters_file)

# If we're reading the reference model factors from the filters file, load them
if options.factors_from_filters_file:
	EP1_real = float(filters["EP1_real"])
	EP1_imag = float(filters["EP1_imag"])
	EP2_real = float(filters["EP2_real"])
	EP2_imag = float(filters["EP2_imag"])
	EP3_real = float(filters["EP3_real"])
	EP3_imag = float(filters["EP3_imag"])
	EP4_real = float(filters["EP4_real"])
	EP4_imag = float(filters["EP4_imag"])
	EP5_real = float(filters["EP5_real"])
	EP5_imag = float(filters["EP5_imag"])
	EP6_real = float(filters["EP6_real"])
	EP6_imag = float(filters["EP6_imag"])
	EP7_real = float(filters["EP7_real"])
	EP7_imag = float(filters["EP7_imag"])
	EP8_real = float(filters["EP8_real"])
	EP8_imag = float(filters["EP8_imag"])
	EP9_real = float(filters["EP9_real"])
	EP9_imag = float(filters["EP9_imag"])

# Load all of the kappa dewhitening and correction factors
darm_act_line_freq = float(filters["ka_pcal_line_freq"])
pcal_corr_at_darm_act_freq_real = float(filters["ka_pcal_corr_re"])
pcal_corr_at_darm_act_freq_imag = float(filters["ka_pcal_corr_im"])
pu_act_esd_line_freq = float(filters["ka_esd_line_freq"])
opt_gain_fcc_line_freq = float(filters["kc_pcal_line_freq"])
pcal_corr_at_opt_gain_fcc_freq_real = float(filters["kc_pcal_corr_re"])
pcal_corr_at_opt_gain_fcc_freq_imag = float(filters["kc_pcal_corr_im"])
esd_act_line_freq = float(filters["ktst_esd_line_freq"])
if options.dewhitening:
	try:
		derr_dewhiten_at_darm_act_freq_real = float(filters["ka_pcal_whitener_re"])
		derr_dewhiten_at_darm_act_freq_imag = float(filters["ka_pcal_whitener_im"])
		derr_dewhiten_at_pu_act_freq_real = float(filters["ka_esd_whitener_re"])
		derr_dewhiten_at_pu_act_freq_imag = float(filters["ka_esd_whitener_im"])
		derr_dewhiten_at_opt_gain_fcc_freq_real = float(filters["kc_pcal_whitener_re"])
		derr_dewhiten_at_opt_gain_fcc_freq_imag = float(filters["kc_pcal_whitener_im"])
		derr_dewhiten_at_esd_act_freq_real = float(filters["ktst_esd_whitener_re"])
		derr_dewhiten_at_esd_act_freq_imag = float(filters["ktst_esd_whitener_im"])
	except:
		derr_dewhiten_at_darm_act_freq_real = 1.0
		derr_dewhiten_at_darm_act_freq_imag = 0.0
		derr_dewhiten_at_pu_act_freq_real = 1.0
		derr_dewhiten_at_pu_act_freq_imag = 0.0
		derr_dewhiten_at_opt_gain_fcc_freq_real = 1.0
		derr_dewhiten_at_opt_gain_fcc_freq_imag = 0.0
		derr_dewhiten_at_esd_act_freq_real = 1.0
		derr_dewhiten_at_esd_act_freq_imag = 0.0

# If we're performing partial calibration, load the deltal filters
if options.partial_calibration:
	reschaindelay = filters["res_corr_delay"]
	reschainfilt = filters["res_corr_filter"]
	tstdelay = pumuimdelay = filters["ctrl_corr_delay"]
	tstfilt = pumuimfilt = filters["ctrl_corr_filter"]
	tstchainsr = pumuimchainsr = filters["ctrl_corr_sr"]
	if options.dewhitening:
		tstdewhitensr = int(filters["deltal_tst_dewhiten_sr"])
		pumuimdewhitensr = int(filters["deltal_pumuim_dewhiten_sr"])
		tstdewhitendelay = filters["deltal_tst_dewhiten_delay"]
		pumuimdewhitendelay = filters["deltal_pumuim_dewhiten_delay"]
		tstdewhiten = filters["deltal_tst_dewhiten"]
		pumuimdewhiten = filters["deltal_pumuim_dewhiten"]
		resdewhitendelay = filters["deltal_res_dewhiten_delay"]
		resdewhiten = filters["deltal_res_dewhiten"]

# If we're performing full calibration, load the actuation, sensing filters
if options.full_calibration:
	tstchainsr = int(filters["actuation_tst_sr"])
	pumuimchainsr = int(filters["actuation_pumuim_sr"])
	tstdelay = filters["actuation_tst_delay"]
	pumuimdelay = filters["actuation_pumuim_delay"]
	tstfilt = filters["actuation_tst"]
	pumuimfilt = filters["actuation_pumuim"]
	reschaindelay = filters["inv_sens_delay"]
	reschainfilt = filters["inv_sensing"]
	if options.dewhitening:
		ctrldewhitendelay = filters["dewhiten_ctrl_delay"]
		ctrldewhiten = filters["dewhiten_ctrl"]
		ctrldewhitensr = int(filters["dewhiten_ctrl_sr"])
		resdewhitendelay = filters["dewhiten_err_delay"]
		resdewhiten = filters["dewhiten_err"]

####################################################################################################
####################################### Main Pipeline ##############################################
####################################################################################################

pipeline = Gst.Pipeline(name="gstlal_compute_strain")
mainloop = GObject.MainLoop()
handler = simplehandler.Handler(mainloop, pipeline)

# 
# Turn off debugging tools or verboseness
#

pipeparts.mkchecktimestamps = lambda pipeline, src, *args: src # comment this line out to turn on the checktimestamps debugging
if not options.verbose:
	pipeparts.mkprogressreport = lambda pipeline, src, *args: src

#
# Read in data from frames or shared memory
#

if options.data_source == "lvshm": # Data is to be read from shared memory; "low-latency" mode
	src = pipeparts.mklvshmsrc(pipeline, shm_name = options.shared_memory_partition, assumed_duration = 1)
elif options.data_source == "frames": # Data is to be read from frame files; "offline" mode
	src = pipeparts.mklalcachesrc(pipeline, location = options.frame_cache, cache_dsc_regex = instrument)

#
# Hook up the relevant channels to the demuxer
#

if options.data_source == "lvshm":
	demux = pipeparts.mkframecppchanneldemux(pipeline, src, do_file_checksum = options.do_file_checksum, skip_bad_files = True, channel_list = map("%s:%s".__mod__, channel_list))

elif options.data_source == "frames":
	demux = pipeparts.mkframecppchanneldemux(pipeline, src, do_file_checksum = options.do_file_checksum, skip_bad_files = False, channel_list = map("%s:%s".__mod__, channel_list))

# Write the pipeline graph after pads have been hooked up to the demuxer
if options.write_pipeline is not None:
	demux.connect("no-more-pads", write_graph)	

# Make sure the code exits when it encounters a non-zero dataValid flag and is running in "offline mode" (i.e. reading from frames)
def exit_on_nonzero_datavalid(pad, ignored):
	datavalid = pad.get_property("datavalid")
	if datavalid != 0:
		print "ERROR: Non-zero dataValid flag encountered"
		sys.exit()
def connect_notify_datavalid_signal(demux, pad):
	name = pad.get_name()
	pad.connect("notify::datavalid", exit_on_nonzero_datavalid)
if options.data_source == "frames":
	demux.connect("pad-added", connect_notify_datavalid_signal)

# Get everything hooked up and blocked off to no more than 1 second buffers
for key, chan in zip(headkeys, channel_list):
	head_dict[key] = calibration_parts.hook_up(pipeline, demux, chan[1], instrument)

# Tee off the ODC channel to check for gaps and convert it to unsigned ints (if necessary)
if not options.no_dq_vector:
	# FIXME: When the ODC is written as unsigned ints, this piece can be removed
	odcstatevector = pipeparts.mkaudioconvert(pipeline, head_dict["odcstatevector"], odc_caps)
	odcstatevector = calibration_parts.mkinsertgap(pipeline, odcstatevector)
	odcgaptee = pipeparts.mktee(pipeline, odcstatevector)
	

# When reading from disk, clip the incoming data stream(s) to segment list if one is provided
if options.data_source == "frames" and frame_segments is not None:
	for key in headkeys:
		currenthead = head_dict[key]
		head_dict[key] = pipeparts.mkgate(pipeline, currenthead, threshold = 1, control = pipeparts.mksegmentsrc(pipeline, frame_segments[instrument]))

#
# DQ VECTOR BRANCH: PART 1
#
if not options.no_dq_vector:
	odcstatevector = calibration_parts.mkaudiorate(pipeline, odcgaptee)
	odctagstr = "channel-name=%s:%s, instrument=%s" % (instrument, options.dq_channel_name, instrument)
	odcstatevector = pipeparts.mktaginject(pipeline, odcstatevector, odctagstr)
	odcstatevector = pipeparts.mkprogressreport(pipeline, odcstatevector,"progress_odc_%s" % instrument)
	odcstatevectortee = pipeparts.mktee(pipeline, odcstatevector)

	if not options.no_kappatst or not options.no_kappaa or not options.no_kappapu or not options.no_kappac or not options.no_fcc:
		obsreadystatevec = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = options.obs_ready_bitmask, status_out = 1)
		obsreadystatevec = pipeparts.mkcapsfilter(pipeline, obsreadystatevec, "audio/x-raw, format=U32LE, rate=%d" % options.compute_factors_sr)
		obsreadystatevec = pipeparts.mktee(pipeline, obsreadystatevec)

#
# TIME-VARYING FACTORS COMPUTATIONS
#

if not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappapu:
	exc = calibration_parts.caps_and_progress(pipeline, head_dict["exc"], hoft_caps, "exc")

if not options.no_kappatst or not options.no_kappaa or not options.no_kappac or not options.no_fcc:
        tstexccaps = "audio/x-raw, format=F64LE, rate=%d" % options.tst_exc_sample_rate
        tstexc = calibration_parts.caps_and_progress(pipeline, head_dict["tstexc"], tstexccaps, "tstexc")

for key in headkeys:
	if key.startswith("EP"):
		head_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		head_dict[key] = calibration_parts.mkupsample(pipeline, head_dict[key], compute_calib_factors_caps)

# Set up computations for \kappa_a, \kappa_tst,\kappa_c, \kappa_pu, f_cc, if applicable
if not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappatst or not options.no_kappapu:

	# pcal excitation channel, which will be demodulated
	pcal = calibration_parts.caps_and_progress(pipeline, head_dict["pcal"], hoft_caps, "pcal")
	pcaltee = pipeparts.mktee(pipeline, pcal)
	
	# DARM_ERR channel, which will have followed different paths if we're doing full vs. partial calibration
	if options.full_calibration:
		darm_errtee = pipeparts.mktee(pipeline, head_dict["res"])
		darm_err = calibration_parts.mkqueue(pipeline, darm_errtee)
		head_dict["res"] = calibration_parts.mkqueue(pipeline, darm_errtee)
	else:
		darm_err = head_dict["darm_err"]
	darm_err = calibration_parts.caps_and_progress(pipeline, darm_err, hoft_caps, "darm_err")
	derrtee = pipeparts.mktee(pipeline, darm_err)

	# demodulate the PCAL channel at the DARM actuation line frequency
	pcal_at_darm_act_freq_nocorr = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, pcaltee), darm_act_line_freq, td, compute_calib_factors_caps)
	# apply the PCAL correction factor at the DARM actuation line frequency
	pcal_at_darm_act_freq = calibration_parts.complex_audioamplify(pipeline, pcal_at_darm_act_freq_nocorr, pcal_corr_at_darm_act_freq_real, pcal_corr_at_darm_act_freq_imag)
	if not options.no_coherence:
		# gate the output with the coherence for this line
		pcaly_line1_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line1_coh"], coh_caps, "pcaly_line1_coh", replace_zeros = True)
		if not options.no_dq_vector:
			pcaly_line1_coh = pipeparts.mktee(pipeline, pcaly_line1_coh)
		pcal_at_darm_act_freq = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, pcal_at_darm_act_freq), control = calibration_parts.mkqueue(pipeline, pcaly_line1_coh), threshold = options.coherence_uncertainty_threshold)
	if not options.no_kappapu or not options.no_kappaa or not options.no_kappac or not options.no_fcc:
		pcal_at_darm_act_freq = pipeparts.mktee(pipeline, pcal_at_darm_act_freq)

	# demodulate DARM_ERR at the DARM actuation line frequency
	derr_at_darm_act_freq = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, derrtee), darm_act_line_freq, td, compute_calib_factors_caps)
	if options.dewhitening:
		# dewhiten DARM_ERR at the DARM actuation line frequency
		derr_at_darm_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_darm_act_freq, derr_dewhiten_at_darm_act_freq_real, derr_dewhiten_at_darm_act_freq_imag)
	if not options.no_kappapu or not options.no_kappaa or not options.no_kappac or not options.no_fcc:
		derr_at_darm_act_freq = pipeparts.mktee(pipeline, derr_at_darm_act_freq)

	# resample and demodulate the TST excitation channel at the ESD actuation line frequency
	tstexc = calibration_parts.mkresample(pipeline, tstexc, hoft_caps)
	tstexc_at_esd_act_freq = calibration_parts.demodulate(pipeline, tstexc, esd_act_line_freq, td, compute_calib_factors_caps)
	if not options.no_coherence:
		sus_coh = calibration_parts.caps_and_progress(pipeline, head_dict["sus_coh"], coh_caps, "sus_coh", replace_zeros = True)
		if not options.no_dq_vector:
			sus_coh = pipeparts.mktee(pipeline, sus_coh)
		tstexc_at_esd_act_freq = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, tstexc_at_esd_act_freq), control = calibration_parts.mkqueue(pipeline, sus_coh), threshold = options.coherence_uncertainty_threshold)

	# demodulate DARM_ERR at the ESD actuation line frequency
	derr_at_esd_act_freq = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, derrtee), esd_act_line_freq, td, compute_calib_factors_caps)
	if options.dewhitening:
		# dewhiten DARM_ERR at the ESD actuation line frequency
		derr_at_esd_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_esd_act_freq, derr_dewhiten_at_esd_act_freq_real, derr_dewhiten_at_esd_act_freq_imag)

	# compute kappa_tst, either using reference factors from the filters file or reading them from EPICS channels
	if not options.factors_from_filters_file:
		ktst = calibration_parts.compute_kappatst(pipeline, derr_at_esd_act_freq, tstexc_at_esd_act_freq, pipeparts.mkqueue(pipeline, pcal_at_darm_act_freq), derr_at_darm_act_freq, calibration_parts.merge_into_complex(pipeline, head_dict["EP1_real"], head_dict["EP1_imag"]))
	elif options.factors_from_filters_file:
		ktst = calibration_parts.compute_kappatst_from_filters_file(pipeline, derr_at_esd_act_freq, tstexc_at_esd_act_freq, pipeparts.mkqueue(pipeline, pcal_at_darm_act_freq), derr_at_darm_act_freq, EP1_real, EP1_imag)

	if not options.no_dq_vector:
		ktst = pipeparts.mkgate(pipeline, ktst, control = pipeparts.mkqueue(pipeline, obsreadystatevec), threshold = 1)

	ktsttee = pipeparts.mktee(pipeline, ktst)

	if options.no_coherence:
		smooth_ktstR, smooth_ktstI = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, ktsttee, options.kappatst_real_ok_var, options.kappatst_imag_ok_var, options.expected_kappatst_real, options.expected_kappatst_imag, median_smoothing_samples, factors_average_samples)
		if not options.no_dq_vector:
			smooth_ktstRdq, smooth_ktstIdq = calibration_parts.track_bad_complex_kappas_no_coherence(pipeline, ktsttee, options.kappatst_real_ok_var, options.kappatst_imag_ok_var, options.expected_kappatst_real, options.expected_kappatst_imag, median_smoothing_samples)
	else:
		smooth_ktstR, smooth_ktstI = calibration_parts.smooth_complex_kappas(pipeline, ktsttee, options.expected_kappatst_real, options.expected_kappatst_imag, median_smoothing_samples, factors_average_samples)
		if not options.no_dq_vector:
			smooth_ktstRdq, smooth_ktstIdq = calibration_parts.track_bad_complex_kappas(pipeline, ktsttee, options.expected_kappatst_real, options.expected_kappatst_imag, median_smoothing_samples)
			

	if not options.no_kappatst:
		smooth_ktstRtee = pipeparts.mktee(pipeline, smooth_ktstR)
		smooth_ktstItee = pipeparts.mktee(pipeline, smooth_ktstI)
	
# If we're also computing \kappa_a, \kappa_c, f_cc, or \kappa_pu, keep going
if not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappapu:
	# demodulate excitation channel at PU actuation line frequency
	exc_at_pu_act_freq = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, exc), pu_act_esd_line_freq, td,compute_calib_factors_caps)
	if not options.no_coherence:
		# gate the output with the coherence for this line
		darm_coh = calibration_parts.caps_and_progress(pipeline, head_dict["darm_coh"], coh_caps, "darm_coh", replace_zeros = True)
		if not options.no_dq_vector:
			darm_coh = pipeparts.mktee(pipeline, darm_coh)
		exc_at_pu_act_freq = pipeparts.mkgate(pipeline, exc_at_pu_act_freq, control = calibration_parts.mkqueue(pipeline, darm_coh), threshold = options.coherence_uncertainty_threshold)

	# demodulate DARM_ERR at PU actuation line frequency
	derr_at_pu_act_freq = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, derrtee), pu_act_esd_line_freq, td, compute_calib_factors_caps)
	if options.dewhitening:
		# dewhiten DARM_ERR at the PU actuation line frequency
		derr_at_pu_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_pu_act_freq, derr_dewhiten_at_pu_act_freq_real, derr_dewhiten_at_pu_act_freq_imag)

	# compute the factor Afctrl that will be used in the computation of kappa_pu and kappa_a, either using reference factors from the filters file or reading them from EPICS channels
	if not options.factors_from_filters_file:
		afctrl = calibration_parts.compute_afctrl(pipeline, derr_at_pu_act_freq, exc_at_pu_act_freq, pipeparts.mkqueue(pipeline, pcal_at_darm_act_freq), pipeparts.mkqueue(pipeline, derr_at_darm_act_freq), calibration_parts.merge_into_complex(pipeline, head_dict["EP2_real"], head_dict["EP2_imag"]))
	elif options.factors_from_filters_file:
		afctrl = calibration_parts.compute_afctrl_from_filters_file(pipeline, derr_at_pu_act_freq, exc_at_pu_act_freq, pipeparts.mkqueue(pipeline, pcal_at_darm_act_freq), pipeparts.mkqueue(pipeline, derr_at_darm_act_freq), EP2_real, EP2_imag)

	# Tee things off as needed for rest of the kappa calculations
	if not options.factors_from_filters_file:
		EP4 = calibration_parts.merge_into_complex(pipeline, head_dict["EP4_real"], head_dict["EP4_imag"])
		if not options.no_kappaa:
			EP4 = pipeparts.mktee(pipeline, EP4)		
	if not options.no_kappaa:
		afctrl = pipeparts.mktee(pipeline, afctrl)

	# \kappa_pu calcuation, which needs to happen for any of the other kappas to be computed
	if not options.factors_from_filters_file:
		kpu = calibration_parts.compute_kappapu(pipeline, calibration_parts.merge_into_complex(pipeline, head_dict["EP3_real"], head_dict["EP3_imag"]), calibration_parts.mkqueue(pipeline, afctrl), calibration_parts.mkqueue(pipeline, ktsttee), calibration_parts.mkqueue(pipeline, EP4))
	elif options.factors_from_filters_file:
		kpu = calibration_parts.compute_kappapu_from_filters_file(pipeline, EP3_real, EP3_imag, calibration_parts.mkqueue(pipeline, afctrl), calibration_parts.mkqueue(pipeline, ktsttee), EP4_real, EP4_imag)

	if not options.no_dq_vector:
		kpu = pipeparts.mkgate(pipeline, kpu, control = pipeparts.mkqueue(pipeline, obsreadystatevec), threshold = 1)

	kputee = pipeparts.mktee(pipeline, kpu)

	if options.no_coherence:
		smooth_kpuR, smooth_kpuI = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, kputee, options.kappapu_real_ok_var, options.kappapu_imag_ok_var, options.expected_kappapu_real, options.expected_kappapu_imag, median_smoothing_samples, factors_average_samples)
		if not options.no_dq_vector:
			smooth_kpuRdq, smooth_kpuIdq = calibration_parts.track_bad_complex_kappas_no_coherence(pipeline, kputee, options.kappapu_real_ok_var, options.kappapu_imag_ok_var, options.expected_kappapu_real, options.expected_kappapu_imag, median_smoothing_samples)
	else:
		smooth_kpuR, smooth_kpuI = calibration_parts.smooth_complex_kappas(pipeline, kputee, options.expected_kappapu_real, options.expected_kappapu_imag, median_smoothing_samples, factors_average_samples)
		if not options.no_dq_vector:
			smooth_kpuRdq, smooth_kpuIdq = calibration_parts.track_bad_complex_kappas(pipeline, kputee, options.expected_kappapu_real, options.expected_kappapu_imag, median_smoothing_samples)

	if not options.no_kappapu:
		smooth_kpuRtee = pipeparts.mktee(pipeline, smooth_kpuR)
		smooth_kpuItee = pipeparts.mktee(pipeline, smooth_kpuI)	

	# Here's \kappa_a specific stuff
	if not options.no_kappaa:
		if not options.factors_from_filters_file:
			ka = calibration_parts.compute_kappaa(pipeline, calibration_parts.mkqueue(pipeline, afctrl), calibration_parts.mkqueue(pipeline, EP4), calibration_parts.merge_into_complex(pipeline, head_dict["EP5_real"], head_dict["EP5_imag"]))
		elif options.factors_from_filters_file:
			ka = calibration_parts.compute_kappaa_from_filters_file(pipeline, calibration_parts.mkqueue(pipeline, afctrl), EP4_real, EP4_imag, EP5_real, EP5_imag)

		if not options.no_dq_vector:
			ka = pipeparts.mkgate(pipeline, ka, control = pipeparts.mkqueue(pipeline, obsreadystatevec), threshold = 1)

		katee = pipeparts.mktee(pipeline, ka)

		if options.no_coherence:
			smooth_kaR, smooth_kaI = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, katee, options.kappaa_real_ok_var, options.kappaa_imag_ok_var, options.expected_kappaa_real, options.expected_kappaa_imag, median_smoothing_samples, factors_average_samples)
			if not options.no_dq_vector:
				smooth_kaRdq, smooth_kaIdq = calibration_parts.track_bad_complex_kappas_no_coherence(pipeline, katee, options.kappaa_real_ok_var, options.kappaa_imag_ok_var, options.expected_kappaa_real, options.expected_kappaa_imag, median_smoothing_samples)
		else:
			smooth_kaR, smooth_kaI = calibration_parts.smooth_complex_kappas(pipeline, katee, options.expected_kappaa_real, options.expected_kappaa_imag, median_smoothing_samples, factors_average_samples)
			if not options.no_dq_vector:
				smooth_kaRdq, smooth_kaIdq = calibration_parts.track_bad_complex_kappas(pipeline, katee, options.expected_kappaa_real, options.expected_kappaa_imag, median_smoothing_samples)

		smooth_kaRtee = pipeparts.mktee(pipeline, smooth_kaR)
		smooth_kaItee = pipeparts.mktee(pipeline, smooth_kaI)

	# Finally, compute \kappa_c and f_cc
	if not options.no_kappac or not options.no_fcc:
		# demodulate PCAL channel at optical gain and f_cc line frequency
		pcal_at_opt_gain_freq_nocorr = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, pcaltee), opt_gain_fcc_line_freq, td, compute_calib_factors_caps)
		# apply the PCAL correction factor at optical gain and f_cc line frequency
		pcal_at_opt_gain_freq = calibration_parts.complex_audioamplify(pipeline, pcal_at_opt_gain_freq_nocorr, pcal_corr_at_opt_gain_fcc_freq_real, pcal_corr_at_opt_gain_fcc_freq_imag)
		if not options.no_coherence:
			# gate the output with the coherence for this line
			pcaly_line2_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line2_coh"], coh_caps, "pcaly_line2_coh", replace_zeros = True)
			if not options.no_dq_vector:
				pcaly_line2_coh = pipeparts.mktee(pipeline, pcaly_line2_coh)
			pcal_at_opt_gain_freq = pipeparts.mkgate(pipeline, pcal_at_opt_gain_freq, control = calibration_parts.mkqueue(pipeline, pcaly_line2_coh), threshold = options.coherence_uncertainty_threshold)

		# demodulate DARM_ERR at optical gain and f_cc line frequency
		derr_at_opt_gain_freq = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, derrtee), opt_gain_fcc_line_freq, td, compute_calib_factors_caps)
		if options.dewhitening:
			# dewhiten DARM_ERR at optical gain and f_cc line frequency
			derr_at_opt_gain_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_opt_gain_freq, derr_dewhiten_at_opt_gain_fcc_freq_real, derr_dewhiten_at_opt_gain_fcc_freq_imag)

		# Compute the factor S which will be used for the kappa_c and f_cc calculations
		if not options.factors_from_filters_file:
			S = calibration_parts.compute_S(pipeline, calibration_parts.merge_into_complex(pipeline, head_dict["EP6_real"], head_dict["EP6_imag"]), pcal_at_opt_gain_freq, derr_at_opt_gain_freq, calibration_parts.merge_into_complex(pipeline, head_dict["EP7_real"], head_dict["EP7_imag"]), calibration_parts.mkqueue(pipeline, ktsttee),  calibration_parts.merge_into_complex(pipeline, head_dict["EP8_real"], head_dict["EP8_imag"]), calibration_parts.mkqueue(pipeline, kputee), calibration_parts.merge_into_complex(pipeline, head_dict["EP9_real"], head_dict["EP9_imag"]))
		elif options.factors_from_filters_file:
			S = calibration_parts.compute_S_from_filters_file(pipeline, EP6_real, EP6_imag, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7_real, EP7_imag, pipeparts.mkqueue(pipeline, ktsttee), EP8_real, EP8_imag, pipeparts.mkqueue(pipeline, kputee), EP9_real, EP9_imag)

		S = pipeparts.mktee(pipeline, S)

		SR, SI = calibration_parts.split_into_real(pipeline, S)

		if not options.no_kappac and not options.no_fcc:
			SR = pipeparts.mktee(pipeline, SR)
			SI = pipeparts.mktee(pipeline, SI)

		# compute kappa_c
		if not options.no_kappac:
			kc = calibration_parts.compute_kappac(pipeline, calibration_parts.mkqueue(pipeline, SR), calibration_parts.mkqueue(pipeline, SI))
			if not options.no_dq_vector:
				kc = pipeparts.mkgate(pipeline, kc, control = pipeparts.mkqueue(pipeline, obsreadystatevec), threshold = 1)
				kc = pipeparts.mktee(pipeline, kc)

			if options.no_coherence:
				smooth_kc = calibration_parts.smooth_kappas_no_coherence(pipeline, kc, options.kappac_ok_var, options.expected_kappac, median_smoothing_samples, factors_average_samples)

				if not options.no_dq_vector:
					smooth_kcdq = calibration_parts.track_bad_kappas_no_coherence(pipeline, kc, options.kappac_ok_var, options.expected_kappac, median_smoothing_samples)
			else:
				smooth_kc = calibration_parts.smooth_kappas(pipeline, kc, options.expected_kappac, median_smoothing_samples, factors_average_samples)
				if not options.no_dq_vector:
					smooth_kcdq = calibration_parts.track_bad_kappas(pipeline, kc, options.expected_kappac, median_smoothing_samples)

		smooth_kctee = pipeparts.mktee(pipeline, smooth_kc)

		# compute f_cc
		if not options.no_fcc:
			fcc = calibration_parts.compute_fcc(pipeline, calibration_parts.mkqueue(pipeline, SR), calibration_parts.mkqueue(pipeline, SI), opt_gain_fcc_line_freq)
			if not options.no_dq_vector:
				fcc = pipeparts.mkgate(pipeline, fcc, control = pipeparts.mkqueue(pipeline, obsreadystatevec), threshold = 1)
				fcc = pipeparts.mktee(pipeline, fcc)

			if options.no_coherence:
				smooth_fcc = calibration_parts.smooth_kappas_no_coherence(pipeline, fcc, options.fcc_ok_var, options.expected_fcc, median_smoothing_samples, factors_average_samples)
				if not options.no_dq_vector:
					smooth_fccdq = calibration_parts.track_bad_kappas_no_coherence(pipeline, fcc, options.fcc_ok_var, options.expected_fcc, median_smoothing_samples)
			else:
				smooth_fcc = calibration_parts.smooth_kappas(pipeline, fcc, options.expected_fcc, median_smoothing_samples, factors_average_samples)
				if not options.no_dq_vector:
					smooth_fccdq = calibration_parts.track_bad_kappas(pipeline, fcc, options.expected_fcc, median_smoothing_samples)
				
			smooth_fcctee = pipeparts.mktee(pipeline, smooth_fcc)

#
# CONTROL BRANCH
#

# zero out filter settling samples
tst_filter_settle_time = 0
pumuim_filter_settle_time = 0

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank
if options.partial_calibration:
	# enforce caps on actuation channels and set up progress report if verbose is on
	tsttee = pipeparts.mktee(pipeline, head_dict["tst"])
	tst = calibration_parts.caps_and_progress(pipeline, tsttee, ctrl_caps, "tst")
	pumtee = pipeparts.mktee(pipeline, head_dict["pum"])
	pum = calibration_parts.caps_and_progress(pipeline, pumtee, ctrl_caps, "pum")
	uimtee = pipeparts.mktee(pipeline, head_dict["uim"])
	uim = calibration_parts.caps_and_progress(pipeline, uimtee, ctrl_caps, "uim")

	# add together the PUM and UIM actuation channels; this may change in the future...
	pumuim = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pum, uim))

	# if you need to, dewhiten the TST and PUM/UIM chains
	if options.dewhitening:
		pumuim = calibration_parts.mkresample(pipeline, pumuim, "audio/x-raw, format=F64LE, rate=%d" % pumuimdewhitensr) 
		pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = int(pumuimdewhitendelay), fir_matrix = [pumuimdewhiten[::-1]], time_domain = td)
		pumuim_filter_settle_time += (len(pumuimdewhiten)+abs(pumuimdewhitendelay))/pumuimdewhitensr
		tst = calibration_parts.mkresample(pipeline, tst, "audio/x-raw, format=F64LE, rate=%d" % tstdewhitensr) 
		tst = pipeparts.mkfirbank(pipeline, tst, latency = int(tstdewhitendelay), fir_matrix = [tstdewhiten[::-1]], time_domain = td)
		tst_filter_settle_time += (len(tstdewhiten)+abs(tstdewhitendelay))/tstdewhitensr

if options.full_calibration:
	# enforce caps on actuation channels and set up progress report, if verbose is on
	darmctrltee = pipeparts.mktee(pipeline, head_dict["ctrl"])
	ctrl = calibration_parts.caps_and_progress(pipeline, darmctrltee, hoft_caps, "ctrl")
	
	if options.dewhitening:
		# dewhiten the DARM_CTRL channel
		ctrl = calibration_parts.mkresample(pipeline, ctrl, "audio/x-raw, format=F64LE, rate=%d" % ctrldewhitensr)
		ctrl = pipeparts.mkfirbank(pipeline, ctrl, latency = int(ctrldewhitendelay), fir_matrix = [ctrldewhiten[::-1]], time_domain = td)
		tst_filter_settle_time += (len(ctrldewhiten)+abs(ctrldewhitendelay))/ctrldewhitensr
		pumuim_filter_settle_time += (len(ctrldewhiten)+abs(ctrldewhitendelay))/ctrldewhitensr
	# tee off DARM_CTRL to be filtered with PUM/UIM and TST filters separately
	ctrltee = pipeparts.mktee(pipeline, ctrl)
	tst = calibration_parts.mkqueue(pipeline, ctrltee)
	pumuim = calibration_parts.mkqueue(pipeline, ctrltee)

# resample what will become the TST actuation chain to the TST FIR filter sample rate
tst = calibration_parts.mkresample(pipeline, tst, "audio/x-raw, format=F64LE, rate=%d" %  tstchainsr)
# filter TST chain with the TST acutaiton filter
tst = pipeparts.mkfirbank(pipeline, tst, latency = int(tstdelay), fir_matrix = [tstfilt[::-1]], time_domain = td)
tst_filter_settle_time += (len(tstfilt)+abs(tstdelay))/tstchainsr
# resample the TST actuation chain to the full sample rate
if tstchainsr != pumuimchainsr or options.apply_kappatst or options.apply_kappapu:
	tst = calibration_parts.mkresample(pipeline, tst, hoft_caps)

# resample what will become the PUM/UIM actuation chain to the PUM/UIM FIR filter sample rate
pumuim = calibration_parts.mkresample(pipeline, pumuim, "audio/x-raw, format=F64LE, rate=%d" % pumuimchainsr)
# filter the PUM/UIM chain with the PUM/UIM actuation filter
pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = int(pumuimdelay), fir_matrix = [pumuimfilt[::-1]], time_domain = td)
pumuim_filter_settle_time += (len(pumuimfilt)+abs(pumuimdelay))/pumuimchainsr
# resample the PUM/UIM actuation chain to the full sample rate
if tstchainsr != pumuimchainsr or options.apply_kappapu or options.apply_kappatst:
	pumuim = calibration_parts.mkresample(pipeline, pumuim, hoft_caps)

# apply kappa_tst
if options.apply_kappatst:
	# Only apply the real part of \kappa_tst as a correction to A_tst
	ktst_for_tst = calibration_parts.mkqueue(pipeline, smooth_ktstRtee)
	ktst_for_tst = calibration_parts.mkresample(pipeline, ktst_for_tst, hoft_caps)
	tst = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, ktst_for_tst, tst))
# apply kappa_pu
if options.apply_kappapu:
	# Only apply the real part of \kappa_pu as a correction to A_pu
	kpu_for_pu = calibration_parts.mkqueue(pipeline, smooth_kpuRtee)
	kpu_for_pu = calibration_parts.mkresample(pipeline, kpu_for_pu, hoft_caps)
	pumuim = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, kpu_for_pu, pumuim))

# Add the TST and PU/UIM chains together to form the full actuation chain
ctrl = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, tst, pumuim))
if tstchainsr != hoftsr or not options.apply_kappatst or not options.apply_kappapu:
	ctrl = calibration_parts.mkresample(pipeline, ctrl, hoft_caps)

#
# RESIDUAL BRANCH
#

# zero out res filter settle time
res_filter_settle_time = 0

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank

# enforce caps on the residual branch and hook up progress report if verbose is on
restee = pipeparts.mktee(pipeline, head_dict["res"])
res = calibration_parts.caps_and_progress(pipeline, restee, hoft_caps, "res")

# apply the residual chain filter 	
res = pipeparts.mkfirbank(pipeline, res, latency = int(reschaindelay), fir_matrix = [reschainfilt[::-1]], time_domain = td)
res_filter_settle_time += (len(reschainfilt)+abs(reschaindelay))/hoftsr
if options.dewhitening:
	res = pipeparts.mkfirbank(pipeline, res, latency = int(resdewhitendelay), fir_matrix = [resdewhiten[::-1]], time_domain = td)
	res_filter_settle_time += (len(resdewhiten)+abs(resdewhitendelay))/hoftsr

# Apply factors to actuation and sensing chains, if applicable
if options.apply_kappac:
	kc_modify_res = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, smooth_kctee), hoft_caps)
	res = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, res, pipeparts.mkpow(pipeline, kc_modify_res, exponent = -1.0)))

filter_settle_time = max(res_filter_settle_time, tst_filter_settle_time, pumuim_filter_settle_time)
		
#
# CONTROL + RESIDUAL = H(T)
#

# Add control and residual chains and divide by L to make h(t)
strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, res, ctrl))
# Divide by L in a way that is compatitble with old and new filters files, since old filter files don't recored "arm length"
try:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/float(filters["arm_length"]))
except KeyError:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/3994.5)
strain = pipeparts.mkprogressreport(pipeline, strain, "progress_hoft_%s" % instrument)
	
# Put the units back to strain before writing to frames
straintagstr = "units=strain,channel-name=%sCALIB_STRAIN%s,instrument=%s" % (chan_prefix, chan_suffix, instrument)
if not options.no_dq_vector:
	straintee = pipeparts.mktee(pipeline, strain)
	strain = pipeparts.mktaginject(pipeline, calibration_parts.mkqueue(pipeline, straintee), straintagstr)
else:
	strain = pipeparts.mktaginject(pipeline, strain, straintagstr)
	

#
# CALIB_STATE_VECTOR BRANCH: PART 2
#

#FIXME: Add more comments!

if not options.no_dq_vector:

	#
	# GAP BIT BRANCH
	#	

	nogap = pipeparts.mkbitvectorgen(pipeline, calibration_parts.mkqueue(pipeline, odcgaptee), threshold=1, bit_vector = 1) 
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, odc_caps)
	nogap = pipeparts.mkgeneric(pipeline, nogap, "lal_logicalundersample", required_on = 1, status_out = 512)
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, calibstate_caps)

	# 
	# OBSERVATION-INTENT BIT BRANCH
	#

	obsintent = calibration_parts.mkqueue(pipeline, odcstatevectortee)
	obsintent = pipeparts.mkgeneric(pipeline, obsintent, "lal_logicalundersample", required_on = options.obs_intent_bitmask, status_out = 2)
	obsintent = pipeparts.mkcapsfilter(pipeline, obsintent, calibstate_caps)
	obsintenttee = pipeparts.mktee(pipeline, obsintent)
	
	#
	# OBSERVATION-READY BIT BRANCH
	#

	obsready = pipeparts.mkgeneric(pipeline, odcstatevectortee, "lal_logicalundersample", required_on = options.obs_ready_bitmask, status_out = 4)
	obsready = pipeparts.mkcapsfilter(pipeline, obsready, calibstate_caps)
	obsreadytee = pipeparts.mktee(pipeline, obsready)

	#
	# H(t)-PRODUCED BIT BRANCH
	#

	htproduced = pipeparts.mkbitvectorgen(pipeline, straintee, bit_vector = 8, threshold = 0)
	htproduced = pipeparts.mkcapsfilter(pipeline, htproduced, "audio/x-raw, format=U32LE, rate=%d" % hoftsr)
	htproduced = pipeparts.mkgeneric(pipeline, htproduced, "lal_logicalundersample", required_on = 8, status_out = 8)
	htproduced = pipeparts.mkcapsfilter(pipeline, htproduced, calibstate_caps)

	#
	# FILTERS-OK BIT BRANCH
	#
	
	# Set the FILTERS-OK bit based on observation-ready transitions
	filtersok = pipeparts.mkbitvectorgen(pipeline, calibration_parts.mkqueue(pipeline, obsintenttee), bit_vector=16, threshold=2)
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, calibstate_caps)
	filtersok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, filtersok), control = calibration_parts.mkqueue(pipeline, obsreadytee), threshold = 4, attack_length = -int(filter_settle_time) * calibstatesr)
	filtersok = pipeparts.mkbitvectorgen(pipeline, filtersok, bit_vector = 16, nongap_is_control = True)
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, calibstate_caps)

	#
	# NO-INVALID-INPUT BRANCH
	#

	# Check if any of the input data channels had to be replaced by zeroes because they were < 1e-35
	resok = pipeparts.mkqueue(pipeline, restee)
	resok = pipeparts.mkcapsfilter(pipeline, resok, hoft_caps) 
	resok = pipeparts.mkbitvectorgen(pipeline, resok, threshold=1e-35, bit_vector=1)
	resok = pipeparts.mkcapsfilter(pipeline, resok, "audio/x-raw, format=U32LE, rate=%d" % hoftsr)
	resok = pipeparts.mkgeneric(pipeline, resok, "lal_logicalundersample", required_on = 1, status_out = 1)
	resok = pipeparts.mkcapsfilter(pipeline, resok, calibstate_caps)
	if options.partial_calibration:
		tstok = pipeparts.mkqueue(pipeline, tsttee)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, ctrl_caps)
		tstok = pipeparts.mkbitvectorgen(pipeline, tstok, threshold=1e-35, bit_vector=1)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, "audio/x-raw, format=U32LE, rate=%d" % ctrlsr)
		tstok = pipeparts.mkgeneric(pipeline, tstok, "lal_logicalundersample", required_on = 1, status_out = 1)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, calibstate_caps)
		pumok = pipeparts.mkqueue(pipeline, pumtee)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, ctrl_caps)
		pumok = pipeparts.mkbitvectorgen(pipeline, pumok, threshold=1e-35, bit_vector=1)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, "audio/x-raw, format=U32LE, rate=%d" % ctrlsr)
		pumok = pipeparts.mkgeneric(pipeline, pumok, "lal_logicalundersample", required_on = 1, status_out = 1)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, calibstate_caps)
		uimok = pipeparts.mkqueue(pipeline, uimtee)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, ctrl_caps)
		uimok = pipeparts.mkbitvectorgen(pipeline, uimok, threshold=1e-35, bit_vector=1)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, "audio/x-raw, format=U32LE, rate=%d" % ctrlsr)
		uimok = pipeparts.mkgeneric(pipeline, uimok, "lal_logicalundersample", required_on = 1, status_out = 1)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, calibstate_caps)
		noinvalidinput = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, resok, tstok, pumok, uimok))
		noinvalidinput = pipeparts.mkbitvectorgen(pipeline, noinvalidinput, threshold=4, bit_vector=33554432)
	if options.full_calibration:
		ctrlok = pipeparts.mkqueue(pipeline, darmctrltee)
		ctrlok = pipeparts.mkbitvectorgen(pipeline, ctrlok, threshold=1e-35, bit_vector=1)
		ctrlok = pipeparts.mkcapsfilter(pipeline, ctrlok, "audio/x-raw, format=U32LE, rate=%d" % ctrlsr)
		ctrlok = pipeparts.mkgeneric(pipeline, ctrlok, "lal_logicalundersample", required_on = 1, status_out = 1)
		ctrlok = pipeparts.mkcapsfilter(pipeline, ctrlok, calibstate_caps)
		noinvalidinput = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, resok, ctrlok))
		noinvalidinput = pipeparts.mkbitvectorgen(pipeline, noinvalidinput, threshold=2, bit_vector=33554432)
	noinvalidinput = pipeparts.mkcapsfilter(pipeline, noinvalidinput, calibstate_caps)

	#
	# KAPPA-SMOOTHING-SETTLED BIT BRANCH
	#
	if not options.no_kappaa or not options.no_kappac or not options.no_kappatst or not options.no_kappapu or not options.no_fcc:	
		smoothingok = pipeparts.mkbitvectorgen(pipeline, calibration_parts.mkqueue(pipeline, obsreadytee), bit_vector=1024, threshold=4)
		smoothingok = pipeparts.mkcapsfilter(pipeline, smoothingok, calibstate_caps)
		smoothingok = pipeparts.mkgate(pipeline, smoothingok, control = pipeparts.mkqueue(pipeline, obsreadytee), threshold = 4, attack_length =-(median_smoothing_samples+factors_average_samples+68*16))
		smoothingok = pipeparts.mkbitvectorgen(pipeline, smoothingok, bit_vector = 1024, nongap_is_control = True)
		smoothingok = pipeparts.mkcapsfilter(pipeline, smoothingok, calibstate_caps)

	#
	# KAPPATST BITS BRANCH
	#
	if not options.no_kappatst:
		ktstSmoothInRange, ktstMedianUncorrupt = calibration_parts.compute_kappa_bits(pipeline, calibration_parts.mkqueue(pipeline, smooth_ktstRtee), calibration_parts.mkqueue(pipeline, smooth_ktstItee), smooth_ktstRdq, smooth_ktstIdq, options.expected_kappatst_real, options.expected_kappatst_imag, options.kappatst_real_ok_var, options.kappatst_imag_ok_var, status_out_smooth = 2048, status_out_median = 4096, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# KAPPAPU BITS BRANCH
	#
	if not options.no_kappapu:
		kpuSmoothInRange, kpuMedianUncorrupt = calibration_parts.compute_kappa_bits(pipeline, calibration_parts.mkqueue(pipeline, smooth_kpuRtee), calibration_parts.mkqueue(pipeline, smooth_kpuItee), smooth_kpuRdq, smooth_kpuIdq, options.expected_kappapu_real, options.expected_kappapu_imag, options.kappapu_real_ok_var, options.kappapu_imag_ok_var, status_out_smooth = 8192, status_out_median = 16384, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# KAPPAA BITS BRANCH
	#
	if not options.no_kappaa:
		kaSmoothInRange, kaMedianUncorrupt = calibration_parts.compute_kappa_bits(pipeline, calibration_parts.mkqueue(pipeline, smooth_kaRtee), calibration_parts.mkqueue(pipeline, smooth_kaItee), smooth_kaRdq, smooth_kaIdq, options.expected_kappaa_real, options.expected_kappaa_imag, options.kappaa_real_ok_var, options.kappaa_imag_ok_var, status_out_smooth = 32768, status_out_median = 65536, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# KAPPAC BITS BRANCH
	#
	if not options.no_kappac:
		kcSmoothInRange, kcMedianUncorrupt = calibration_parts.compute_kappa_bits_only_real(pipeline, calibration_parts.mkqueue(pipeline, smooth_kctee), smooth_kcdq, options.expected_kappac, options.kappac_ok_var, status_out_smooth = 131072, status_out_median = 262144, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# FCC BITS BRANCH
	#
	if not options.no_fcc:
		fccSmoothInRange, fccMedianUncorrupt = calibration_parts.compute_kappa_bits_only_real(pipeline, calibration_parts.mkqueue(pipeline, smooth_fcctee), smooth_fccdq, options.expected_fcc, options.fcc_ok_var,  status_out_smooth = 524288, status_out_median = 1048576, starting_rate = options.compute_factors_sr, ending_rate = calibstatesr)

	#
	# COHERENCE BITS BRANCH
	#
	if not options.no_coherence:
		if not options.no_kappatst or not options.no_kappapu or not options.no_kappaa or not options.no_kappac or not options.no_fcc:
			pcaly_line1_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line1_coh, threshold = options.coherence_uncertainty_threshold, bit_vector = 8388608, invert_control = True)
			pcaly_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line1_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % cohsr)
			pcaly_line1_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line1_coh_ok, "lal_logicalundersample", required_on = 8388608, status_out = 8388608)
			pcaly_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line1_coh_ok, calibstate_caps)

			sus_coh_ok = pipeparts.mkbitvectorgen(pipeline, sus_coh, threshold = options.coherence_uncertainty_threshold, bit_vector = 2097152, invert_control = True)
			sus_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % cohsr)
			sus_coh_ok = pipeparts.mkgeneric(pipeline, sus_coh_ok, "lal_logicalundersample", required_on = 2097152, status_out = 2097152)
			sus_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_coh_ok, calibstate_caps)
			coherence_bits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pcaly_line1_coh_ok, sus_coh_ok))
		if not options.no_kappapu or not options.no_kappaa or not options.no_kappac or not options.no_fcc:
			darm_coh_ok = pipeparts.mkbitvectorgen(pipeline, darm_coh, threshold = options.coherence_uncertainty_threshold, bit_vector = 4194304, invert_control = True)
			darm_coh_ok = pipeparts.mkcapsfilter(pipeline, darm_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % cohsr)
			darm_coh_ok = pipeparts.mkgeneric(pipeline, darm_coh_ok, "lal_logicalundersample", required_on = 4194304, status_out = 4194304)
			darm_coh_ok = pipeparts.mkcapsfilter(pipeline, darm_coh_ok, calibstate_caps)
			coherence_bits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, coherence_bits, darm_coh_ok))
		if not options.no_kappac or not options.no_fcc:
			pcaly_line2_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line2_coh, threshold = options.coherence_uncertainty_threshold, bit_vector = 16777216, invert_control = True)
			pcaly_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line2_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % cohsr)
			pcaly_line2_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line2_coh_ok, "lal_logicalundersample", required_on = 16777216, status_out = 16777216)
			pcaly_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line2_coh_ok, calibstate_caps)
			coherence_bits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, coherence_bits, pcaly_line2_coh_ok))

	#
	# H(T)-OK BIT BRANCH
	#

	# First combine higher order bits to determine h(t)-OK
	higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, filtersok, htproduced, obsreadytee, noinvalidinput))
	htok_threshold = 28+33554432
	if options.apply_kappatst or options.apply_kappapu or options.apply_kappac:
		higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, higherbits, smoothingok))
		htok_threshold += 1024
	if options.apply_kappatst:
		higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, higherbits, ktstSmoothInRange))
		htok_threshold += 2048
	if options.apply_kappapu:
		higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, higherbits, kpuSmoothInRange))
		htok_threshold += 8192
	if options.apply_kappac:
		higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, higherbits, kcSmoothInRange))
		htok_threshold += 131072
	higherbitstee = pipeparts.mktee(pipeline, higherbits)

	# Now calculate h(t)-OK bit
	htok = pipeparts.mkbitvectorgen(pipeline, calibration_parts.mkqueue(pipeline, higherbitstee), bit_vector = 1, threshold = htok_threshold)
	htok = pipeparts.mkcapsfilter(pipeline, htok, calibstate_caps)

	#
	# HW INJECTION BITS
	#	

	hwinjcbc = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, odcstatevectortee), "lal_logicalundersample", required_on = int(options.hw_inj_cbc_bitmask), status_out = 64)
	hwinjcbc = pipeparts.mkcapsfilter(pipeline, hwinjcbc, calibstate_caps)

	hwinjburst = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, odcstatevectortee), "lal_logicalundersample", required_on = int(options.hw_inj_burst_bitmask), status_out = 128)
	hwinjburst = pipeparts.mkcapsfilter(pipeline, hwinjburst, calibstate_caps)

	hwinjdetchar = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, odcstatevectortee), "lal_logicalundersample", required_on = int(options.hw_inj_detchar_bitmask), status_out = 256)
	hwinjdetchar = pipeparts.mkcapsfilter(pipeline, hwinjdetchar, calibstate_caps)

	hwinjstoch = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, odcstatevectortee), "lal_logicalundersample", required_on = int(options.hw_inj_stoch_bitmask), status_out = 32)
	hwinjstoch = pipeparts.mkcapsfilter(pipeline, hwinjstoch, calibstate_caps)


	#
	# COMBINE ALL BITS TO MAKE GDS-CALIB_STATE_VECTOR
	#

	calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, nogap, higherbitstee, obsintenttee, htok, hwinjcbc, hwinjburst, hwinjdetchar, hwinjstoch))
	if not options.no_kappaa or not options.no_kappatst or not options.no_kappapu or not options.no_kappac or not options.no_fcc:
		if not options.apply_kappatst and not options.apply_kappapu and not options.apply_kappac:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, smoothingok))
		if not options.no_coherence:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, coherence_bits))
	if not options.no_kappaa:
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kaSmoothInRange, kaMedianUncorrupt))
	if not options.no_kappatst:
		if not options.apply_kappatst:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, ktstSmoothInRange, ktstMedianUncorrupt))
		else:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, ktstMedianUncorrupt))
	if not options.no_kappapu:
		if not options.apply_kappapu:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kpuSmoothInRange, kpuMedianUncorrupt))
		else:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kpuMedianUncorrupt))
	if not options.no_kappac:
		if not options.apply_kappac:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kcSmoothInRange, kcMedianUncorrupt))
		else:
			calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kcMedianUncorrupt))
	if not options.no_fcc:
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, fccSmoothInRange, fccMedianUncorrupt))

	calibstatevector = pipeparts.mkprogressreport(pipeline, calibstatevector, "progress_calibstatevec_%s" % instrument)
	dqtagstr = "channel-name=%s:GDS-CALIB_STATE_VECTOR, instrument=%s" % (instrument, instrument)
	calibstatevector = pipeparts.mktaginject(pipeline, calibstatevector, dqtagstr)

# Resample the \kappa_a channels at the specified recording sample rate and change them to single precision channels
record_kappa_caps = "audio/x-raw, format=F32LE, rate=%d" % options.record_factors_sr
if not options.no_kappaa:
	
	kaRout = pipeparts.mkaudioconvert(pipeline, calibration_parts.mkqueue(pipeline, smooth_kaRtee))
	kaRout = calibration_parts.mkresample(pipeline, kaRout, record_kappa_caps)

	kaIout = pipeparts.mkaudioconvert(pipeline, calibration_parts.mkqueue(pipeline, smooth_kaItee))
	kaIout = calibration_parts.mkresample(pipeline, kaIout, record_kappa_caps)

# Resample the \kappa_pu channels at the specified recording sample rate and change them to single precision channels
if not options.no_kappapu:

	kpuRout = pipeparts.mkaudioconvert(pipeline, calibration_parts.mkqueue(pipeline, smooth_kpuRtee))
	kpuRout = calibration_parts.mkresample(pipeline, kpuRout, record_kappa_caps)

	kpuIout = pipeparts.mkaudioconvert(pipeline, calibration_parts.mkqueue(pipeline, smooth_kpuItee))
	kpuIout = calibration_parts.mkresample(pipeline, kpuIout, record_kappa_caps)

# Resample the \kappa_tst channels at the specified recording sample rate and change them to single precision channels
if not options.no_kappatst:

	ktstRout = pipeparts.mkaudioconvert(pipeline, calibration_parts.mkqueue(pipeline, smooth_ktstRtee))
	ktstRout = calibration_parts.mkresample(pipeline, ktstRout, record_kappa_caps)

	ktstIout = pipeparts.mkaudioconvert(pipeline, calibration_parts.mkqueue(pipeline, smooth_ktstItee))
	ktstIout = calibration_parts.mkresample(pipeline, ktstIout, record_kappa_caps)

# Resample the \kappa_c channel at the specified recording sample rate and change it to a single precision channel
if not options.no_kappac:
	kcout = pipeparts.mkaudioconvert(pipeline, calibration_parts.mkqueue(pipeline, smooth_kctee))
	kcout = calibration_parts.mkresample(pipeline, kcout, record_kappa_caps)

# Resample the f_cc channel at the specified recording sample rate and change it to a single precision channel
if not options.no_fcc:
	fccout = pipeparts.mkaudioconvert(pipeline, calibration_parts.mkqueue(pipeline, smooth_fcctee))
	fccout = calibration_parts.mkresample(pipeline, fccout, record_kappa_caps)


#
# CREATE MUXER AND HOOK EVERYTHING UP TO IT
#

mux = pipeparts.mkframecppchannelmux(pipeline, None)

if options.frame_duration is not None:
        mux.set_property("frame-duration", options.frame_duration)
if options.frames_per_file is not None:
        mux.set_property("frames-per-file", options.frames_per_file)
mux.set_property("compression-scheme", options.compression_scheme)
mux.set_property("compression-level", options.compression_level)

# Link the output DQ vectors up to the muxer, if applicable
if not options.no_dq_vector:
	calibration_parts.mkqueue(pipeline, calibstatevector).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STATE_VECTOR%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, odcstatevectortee).get_static_pad("src").link(mux.get_request_pad("%s:%s" % (instrument, options.dq_channel_name)))

# Link the strain branch to the muxer
calibration_parts.mkqueue(pipeline, strain).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_STRAIN%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of \kappa_a to the muxer
if not options.no_kappaa:
	calibration_parts.mkqueue(pipeline, kaRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_A_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, kaIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_A_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of \kappa_tst to the muxer
if not options.no_kappatst:
	calibration_parts.mkqueue(pipeline, ktstRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, ktstIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_TST_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of \kappa_pu to the muxer
if not options.no_kappapu:
	calibration_parts.mkqueue(pipeline, kpuRout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, kpuIout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_PU_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))

# Link the \kappa_c to the muxer
if not options.no_kappac:
	calibration_parts.mkqueue(pipeline, kcout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_KAPPA_C%s" % (instrument, chan_prefix, chan_suffix)))

# Link the f_cc to the muxer
if not options.no_fcc:
	calibration_parts.mkqueue(pipeline, fccout).get_static_pad("src").link(mux.get_request_pad("%s:%sCALIB_F_CC%s" % (instrument, chan_prefix, chan_suffix)))

# Check that all frames are long enough, that they have all of the channels by requring a certain amount of time from start-up, and that frames aren't written for times requested by the wings option
def check_complete_frames(pad, info, (output_start, frame_duration, wings_start, wings_end)):
	buf = info.get_buffer()
	startts = lal.LIGOTimeGPS(0, buf.pts)
	duration = lal.LIGOTimeGPS(0, buf.duration)
	if not (startts % frame_duration == 0):
		return Gst.PadProbeReturn.DROP
	if startts < output_start:
		return Gst.PadProbeReturn.DROP	
	if duration != frame_duration:
		return Gst.PadProbeReturn.DROP
	if wings_start is not None and wings_end is not None:
		if startts < wings_start or (startts+duration) > wings_end:
			return Gst.PadProbeReturn.DROP
	return Gst.PadProbeReturn.OK
if options.data_source == "frames":
	start = int(options.gps_start_time)
elif options.data_source == "lvshm":
	tm = time.gmtime()
	start = int(lal.UTCToGPS(tm))
# start writing frame files that only start after the desired start time + filter latency + kappa settling (if computing kappas)
if not options.no_kappatst or not options.no_kappaa or not options.no_kappapu or not options.no_kappac or not options.no_fcc:
	output_start = start + int(filter_settle_time) + options.median_smoothing_time + options.factors_averaging_time  + 68 # 68 additional seconds seem necessary to make sure the low-pass filter for demodulation is also settled (I think that's the cause at least)
else:
	output_start = start + int(filter_settle_time)

# If the wings option is set, need to also check that frames aren't written during the requested wing time
if options.wings is not None:
	wings_start = int(options.gps_start_time) + options.wings
	wings_end = int(options.gps_end_time) - options.wings
	mux.get_static_pad("src").add_probe(Gst.PadProbeType.BUFFER, check_complete_frames, (lal.LIGOTimeGPS(output_start,0), lal.LIGOTimeGPS(options.frame_duration*options.frames_per_file,0), lal.LIGOTimeGPS(wings_start, 0), lal.LIGOTimeGPS(wings_end, 0)))
else:
	mux.get_static_pad("src").add_probe(Gst.PadProbeType.BUFFER, check_complete_frames, (lal.LIGOTimeGPS(output_start,0), lal.LIGOTimeGPS(options.frame_duration*options.frames_per_file,0), None, None))

mux = pipeparts.mkprogressreport(pipeline, mux, "progress_sink_%s" % instrument)

if options.write_to_shm_partition is not None:
	pipeparts.mkgeneric(pipeline, mux, "gds_lvshmsink", sync=False, async=False, shm_name = options.write_to_shm_partition, num_buffers=10, blocksize=options.frame_size*options.frame_duration*options.frames_per_file, buffer_mode=options.buffer_mode)
else:
	pipeparts.mkframecppfilesink(pipeline, mux, frame_type = options.frame_type, path = options.output_path, instrument = instrument) 

# Run pipeline

if options.write_pipeline is not None:
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(options.write_pipeline, "NULL"), verbose = options.verbose)

# Seek the pipeline when necessary
if options.data_source == "frames":
	if options.verbose:
		print >>sys.stderr, "seeking GPS start and stop times ..."
	if pipeline.set_state(Gst.State.READY) != Gst.StateChangeReturn.SUCCESS:
		raise RuntimeError("pipeline failed to enter READY state")
	datasource.pipeline_seek_for_gps(pipeline, gps_start_time, gps_end_time)

if options.verbose:
	print >>sys.stderr, "setting pipeline state to playing ..."
if pipeline.set_state(Gst.State.PLAYING) != Gst.StateChangeReturn.SUCCESS:
	raise RuntimeError("pipeline failed to enter PLAYING state")
else:
	print "set to playing successfully"
if options.write_pipeline is not None:
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(options.write_pipeline, "PLAYING"), verbose = options.verbose)
	
if options.verbose:
	print >>sys.stderr, "running pipeline ..."

mainloop.run()

if pipeline.set_state(Gst.State.NULL) != Gst.StateChangeReturn.SUCCESS:
	raise RuntimeError("pipeline could not be set to NULL")
