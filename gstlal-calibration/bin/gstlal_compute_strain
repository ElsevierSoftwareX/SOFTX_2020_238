#!/usr/bin/env python
#
# Copyright (C) 2010-2015  Jordi Burguet-Castell, Madeline Wade
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


"""
This pipeline produces h(t) given DARM_ERR and DARM_CTRL or given DELTAL_RESIDUAL and DELTAL_CTRL. It can be run online in real-time or offline on frame files.  It can write h(t) frames to frame files or to a shared memory partition.  

The differential arm length resulting from external sources is

\Delta L_{ext} = d_{err}/(\kappa_c C) + (A_tst * \kappa_tst + A_usum * \kappa_pu) d_{ctrl}

where C is the sensing function, A_tst is the TST acutuation function, A_usum is the PUM+UIM+TOP actuation, \kappa_c is the time dependent gain of the sensing function, \kappa_tst is the time-dependent gain of TST actuation, and \kappa_pu is the time-dependent gain of the PUM/UIM actuation.  \Delta L_{ext} is divided by the average arm length (4000 km) to obtain h(t), the external strain in the detectors,

h(t) = \Delta L_{ext} / L .

The time-dependent gains (\kappa's) as well as the value for the coupled cavity pole (f_cc), the time-dependent gain of the PUM actuation (\kappa_pu) and the overall time-depenent gain of the actuation (\kappa_a) are calcuated in this pipeline as well.

This pipeline will most often be run in a format where it picks up after part of the actuation and sensing functions have been applied to the apporiate channels.  In this mode, the input channels are \Delta L_{res} and \Delta L_{ctrl}.  This pipeline then applies further high frequency corrections to each of these channels, applies the appropriate time delay to each channel, adds the channels together, and divides by L.

h(t) = (\Delta L_{res} * (1 / \kappa_c) * corrections + (\Delta L_{ctrl, TST} * \kappa_tst + \Delta L_{ctrl, USUM} * \kappa_pu) * corrections) / L

Note: The \kappa's are complex numbers.  Only the real part of the computed \kappa's are applied as time-dependent gain corrections.

Further documentation explaining the time domain calibration procedure can be found in LIGO DCC #T1400256.

For a full list of example command lines that were used to create the O1 h(t) frames, see https://wiki.ligo.org/Calibration/GDSCalibrationConfigurationsO1.

Type gstlal_compute_strain --help to see the full list of command line options.
"""


import pygtk
pygtk.require("2.0")
import gobject
gobject.threads_init()
import pygst
pygst.require("0.10")
	
import sys
import os
import numpy
import time
import resource

from optparse import OptionParser, Option

# This mess is to make gstreamer stop eating our help messages
if "--help" in sys.argv or "-h" in sys.argv:
	try:
		del sys.argv[sys.argv.index("--help")]
	except ValueError:
		pass
	try:
		del sys.argv[sys.argv.index("-h")]
	except ValueError:
		pass
	import gst
	sys.argv.append("--help")
else:
	import gst

import lal

from gstlal import pipeparts
from gstlal import calibration_parts
from gstlal import simplehandler
from gstlal import datasource

from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS

from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
from glue.ligolw.utils import segments as ligolw_segments
array.use_in(ligolw.LIGOLWContentHandler)
param.use_in(ligolw.LIGOLWContentHandler)
from glue.ligolw import utils
from glue import segments

def write_graph(demux):
	pipeparts.write_dump_dot(pipeline, "%s.%s" % (options.write_pipeline, "PLAYING"), verbose = True)
	
parser = OptionParser(description = __doc__)

#
# Append program specific options
#

# These options should be used whether the pipeline runs in full calibration mode or partial calibration mode
parser.add_option("--data-source", metavar = "source", help = "Set the data source from [frames|lvshm]. Required.")
parser.add_option("--frame-cache", metavar = "filename", help = "Set the name of the LAL cache listing the LIGO .gwf frame files (optional).  This is required iff --data-source=frames")
parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the start time of the segment to analyze in GPS seconds. This is required iff --data-source=frames")
parser.add_option("--gps-end-time", metavar = "seconds", help = "Set the end time of the segment to analyze in GPS seconds. This is required iff --data-source=frames")
parser.add_option("--wings", metavar = "seconds", type = "int", help = "Number of seconds to trim off of the beginning and end of the output. Should only be used if --data-source=frames.")
parser.add_option("--dq-channel-name", metavar = "name", default = "ODC-MASTER_CHANNEL_OUT_DQ", help = "Set the name of the data quality (or state vector) channel. (Default=ODC-MASTER_CHANNEL_OUT_DQ)")
parser.add_option("--ifo", metavar = "name", help = "Name of the IFO to be calibrated.")
parser.add_option("--shared-memory-partition", metavar = "name", help = "Set the name of the shared memory partition to read from.  This is required iff --data-source=lvshm.")
parser.add_option("--frame-segments-file", metavar = "filename", help = "Set the name of the LIGO light-weight XML file from which to load frame segments.  This is required iff --data-source=frames")
parser.add_option("--frame-segments-name", metavar = "name", help = "Set the name of the segments to extract from the segment tables.  This is required iff --frame-segments-file is given")
parser.add_option("--sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate at which to generate strain data. This should be less than or equal to the sample rate of the error and control signal channels. (Default = 16384 Hz)")
parser.add_option("--control-sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate of the control signal channels. (Default = 16384 Hz)")
parser.add_option("--odc-sample-rate", metavar = "Hz", default = 16384, type = "int", help = "Sample rate of the ODC state vector channel. (Default = 16384 Hz)")
parser.add_option("--dq-sample-rate", metavar = "Hz", default = 16, type = "int", help = "Sample rate for the outgoing DQ vector GDS-CALIB_STATE_VECTOR. (Default = 16 Hz)")
parser.add_option("--tst-exc-sample-rate", metavar = "Hz", default = 512, type = "int", help = "Sample rate for the control signals being read in. (Default = 512 Hz)")
parser.add_option("--frame-duration", metavar = "seconds", type = "int", default = 4, help = "Set the number of seconds for each frame. (Default = 4)")
parser.add_option("--frames-per-file", metavar = "count", type = "int", default = 1, help = "Set the number of frames per frame file. (Default = 1)")
parser.add_option("--frame-size", metavar = "bytes", type = "int", default = 405338, help = "Approximate size in bytes of frame file images; used when writing to shared memory.  (Default=405338)")
parser.add_option("--compression-scheme", metavar = "scheme", type = "int", default = 256, help = "Set the compression scheme for the framecpp_channelmux element. (Default=256, no compression)")
parser.add_option("--compression-level", metavar = "level", type = "int", default = 0, help = "Set the compression level for the framecpp_channelmux element. (Default=0)")
parser.add_option("--write-to-shm-partition", metavar = "name", help = "Set the name of the shared memory partition to write to. If this is not provided, frames will be written to a file.")
parser.add_option("--buffer-mode", metavar = "number", type = "int", default = 2, help = "Set the buffer mode for the lvshmsink element. (Default=2)")
parser.add_option("--frame-type", metavar = "name", default = "TEST", help = "Set the frame type as input to the frame writing element. (Default=TEST)")
parser.add_option("--output-path", metavar = "name", default = ".", help = "Set the output path for writing frame files. (Default=Current)")
parser.add_option("--no-dq-vector", action = "store_true", help = "Set this if you want to turn off all interpretation and calculation of a data quality vector.")
parser.add_option("--filter-settle-time", metavar = "seconds", type = "int", default = 0, help = "Number of seconds required for the filters to settle in when the data begins to be calibrated. (Default=0)")
parser.add_option("--frequency-domain-filtering", action = "store_true", help = "Set this to perform filtering routines in the frequency domain instead of using direct convolution.")
parser.add_option("--science-quality-bitmask", metavar = "bitmask", type = "int", default = 4, help = "Bitmask used on ODC state vector in order to determine SCIENCE_QUALITY bit information. (Default=4)")
parser.add_option("--science-intent-bitmask", metavar = "bitmask", type = "int", default = 2, help = "Bitmask used on ODC state vector in order to determine SCIENCE_INTENT bit information. (Default=2)")
parser.add_option("--hw-inj-cbc-bitmask", metavar = "bitmask", type = "int", default = 16777216, help = "Bitmask used on ODC state vector in order presence of CBC hardware injection. (Default=16777216)")
parser.add_option("--hw-inj-burst-bitmask", metavar = "bitmask", type = "int", default = 33554432, help = "Bitmask used on ODC state vector in order presence of burst hardware injection. (Default=33554432)")
parser.add_option("--hw-inj-detchar-bitmask", metavar = "bitmask", type = "int", default = 67108864, help = "Bitmask used on ODC state vector in order presence of DetChar hardware injection. (Default=67108864)")
parser.add_option("--hw-inj-stoch-bitmask", metavar = "bitmask", type = "int", default = 8388608, help = "Bitmask used on ODC state vector in order presence of stochastic hardware injection. (Default=8388608)")
parser.add_option("--chan-prefix", metavar = "name", default = "GDS-", help = "Prefix for all output channel names. (Default = GDS)") 
parser.add_option("--chan-suffix", metavar = "name", help = "Suffix for all output channel names.") 

# These are debugging options
parser.add_option("--write-pipeline", metavar = "filename", help = "Write a DOT graph description of the as-built pipeline to this file (optional).  The environment variable GST_DEBUG_DUMP_DOT_DIR must be set for this option to work.")
parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")

# These are options specific to the calibration procedure
parser.add_option("--filters-file", metavar="filename", help = "Name of file containing filters (in npz format)")
parser.add_option("--factors-from-filters-file", action = "store_true", help = "Compute the calibration factors from reference values contained in the filters file instead of from EPICS channels.")
parser.add_option("--no-kappatst", action = "store_true", help = "Set this to turn off the calculation of \kappa_tst.")
parser.add_option("--no-kappapu", action = "store_true", help = "Set this to turn off the calculation of \kappa_pu.")
parser.add_option("--no-kappaa", action = "store_true", help = "Set this to turn off the calculation of \kappa_a.")
parser.add_option("--no-kappac", action = "store_true", help = "Set this to turn off the calculation of \kappa_c.")
parser.add_option("--no-fcc", action = "store_true", help = "Set this to turn off the calculation of f_cc.")
parser.add_option("--factors-averaging-time", metavar = "Sec", type = int, default = 128, help = "Time over which to average the time-varying calibration factors (\kappas), given in seconds. (Default = 128 seconds)")
parser.add_option("--factors-hold-time", metavar = "Sec", type = int, default = 20.0, help = "If values of \kappa are computed outside of the expected range for more than the period of time (in seconds) specified by this option, then the expected average value is updated to the current computed value. (Default = 20 seconds)")
parser.add_option("--apply-kappapu", action = "store_true", help = "Set this to have the \kappa_pu factors multiply the actuation chain.")
parser.add_option("--apply-kappatst", action = "store_true", help = "Set this to have the \kappa_tst factors multiply the actuation chain.")
parser.add_option("--apply-kappac", action = "store_true", help = "Set this to have the \kappa_c factors multiply the sensing chain.")
parser.add_option("--compute-factors-sr", metavar = "Hz", type = int, default = 16, help = "Sample rate at which calibration factors are computed. (Default = 16 Hz)")
parser.add_option("--median-smoothing-time", metavar = "s", type = int, default = 1, help = "Time (in seconds) for average to smooth out \kappa medians. (Default = 1 s)")
parser.add_option("--record-factors-sr", metavar = "Hz", type = int, default = 16, help = "Sample rate at which calibration factors are recorded. (Default = 16 Hz)")
parser.add_option("--factors-integration-time", metavar = "sec", type = float, default = 10.0, help = "Integration time for calibration factors computation. (Default = 10 s)")
parser.add_option("--expected-kappaa-real", metavar = "float", type = float, default = 1.0, help = "Expected value for the real part of \kappa_a. (Default = 1.0)")
parser.add_option("--expected-kappapu-real", metavar = "float", type = float, default = 1.0, help = "Expected value for the real part of \kappa_pu. (Default = 1.0)")
parser.add_option("--expected-kappatst-real", metavar = "float", type = float, default = 1.0, help = "Expected value for the real part of \kappa_tst. (Default = 1.0)")
parser.add_option("--expected-kappaa-imag", metavar = "float", type = float, default = 0.0, help = "Expected value for the imaginary part of \kappa_a. (Default = 0.0)")
parser.add_option("--expected-kappapu-imag", metavar = "float", type = float, default = 0.0, help = "Expected value for the imaginary part of \kappa_pu. (Default = 0.0)")
parser.add_option("--expected-kappatst-imag", metavar = "float", type = float, default = 0.0, help = "Expected value for the imaginary part of \kappa_tst. (Default = 0.0)")
parser.add_option("--expected-kappac", metavar = "float", type = float, default = 1.0, help = "Expected value for \kappa_c. (Default = 1.0)")
parser.add_option("--expected-fcc", metavar = "Hz", type = float, default = 330.0, help = "Expected value for the coupled cavity pole. (Default = 330.0 Hz)")
parser.add_option("--kappaa-real-ok-var", metavar = "float", type = float, default = 0.1, help = "Values of the real part of \kappa_a +/- this number will be considered OK. (Default = 0.1)")
parser.add_option("--kappaa-real-ok-var-for-average", metavar = "float", type = float, default = 0.05, help = "Values of the (pre-averaged) real part of \kappa_a must not change by more than +/- this amount from the last best computed value for this number to be considered OK for averaging. (Default = 0.05)")
parser.add_option("--kappapu-real-ok-var", metavar = "float", type = float, default = 0.1, help = "Values of the real part of \kappa_pu +/- this number will be considered OK. (Default = 0.1)")
parser.add_option("--kappapu-real-ok-var-for-average", metavar = "float", type = float, default = 0.05, help = "Values of the (pre-averaged) real part of \kappa_pu must not change by more than +/- this amount from the last best computed value for this number to be considered OK for averaging. (Default = 0.05)")
parser.add_option("--kappatst-real-ok-var", metavar = "float", type = float, default = 0.1, help = "Values of the real part of \kappa_tst +/- this number will be considered OK. (Default = 0.1)")
parser.add_option("--kappatst-real-ok-var-for-average", metavar = "float", type = float, default = 0.05, help = "Values of the (pre-averaged) real part of \kappa_tst must not change by more than +/- this amount from the last best computed value for this number to be considered OK for averaging. (Default = 0.05)")
parser.add_option("--kappaa-imag-ok-var", metavar = "float", type = float, default = 0.1, help = "Values of the imaginary part of \kappa_a +/- this number will be considered OK. (Default = 0.1)")
parser.add_option("--kappaa-imag-ok-var-for-average", metavar = "float", type = float, default = 0.05, help = "Values of the (pre-averaged) imaginary part of \kappa_a must not change by more than +/- this amount from the last best computed value for this number to be considered OK for averaging. (Default = 0.05)")
parser.add_option("--kappapu-imag-ok-var", metavar = "float", type = float, default = 0.1, help = "Values of the imaginary part of \kappa_pu +/- this number will be considered OK. (Default = 0.1)")
parser.add_option("--kappapu-imag-ok-var-for-average", metavar = "float", type = float, default = 0.05, help = "Values of the (pre-averaged) imaginary part of \kappa_pu must not change by more than +/- this amount from the last best computed value for this number to be considered OK for averaging. (Default = 0.05)")
parser.add_option("--kappatst-imag-ok-var", metavar = "float", type = float, default = 0.1, help = "Values of the imaginary part of \kappa_tst +/- this number will be considered OK. (Default = 0.1)")
parser.add_option("--kappatst-imag-ok-var-for-average", metavar = "float", type = float, default = 0.05, help = "Values of the (pre-averaged) imaginary part of \kappa_tst must not change by more than +/- this amount from the last best computed value for this number to be considered OK for averaging. (Default = 0.05)")
parser.add_option("--kappac-ok-var", metavar = "float", type = float, default = 0.1, help = "Values of \kappa_c +/- this number will be considered OK. (Default = 0.1)")
parser.add_option("--kappac-ok-var-for-average", metavar = "float", type = float, default = 0.05, help = "Values of the (pre-averaged) \kappa_c must not change by more than +/- this amount from the last best computed value for this number to be considered OK for averaging. (Default = 0.05)")
parser.add_option("--fcc-ok-var", metavar = "Hz", type = float, default = 30, help = "Values of f_cc +/- this number (in Hz) will be considered OK. (Default = 30 Hz)")
parser.add_option("--fcc-ok-var-for-average", metavar = "Hz", type = float, default = 5, help = "Values of the last best computed f_cc +/- this number (in Hz) will be considered OK for averaging. (Default = 5 Hz)")
parser.add_option("--exc-channel-name", metavar = "name", default = "CAL-CS_LINE_SUM_DQ", help = "Set the name of the excitation channel.  This is only necessary when the calibration factors computation is turned on, which is the default behavior. (Default = CAL-CS_LINE_SUM_DQ)")
parser.add_option("--tst-exc-channel-name", metavar = "name", default = "SUS-ETMY_L3_CAL_LINE_OUT_DQ", help = "Set the name of the TST excitation channel.  This is only necessary when the \kappa_tst factors computation is turned on, which is the default behavior. (Default = SUS-ETMY_L3_CAL_LINE_OUT_DQ)")
parser.add_option("--pcal-channel-name", metavar = "name", default = "CAL-PCALY_RX_PD_OUT_DQ", help = "Set the name of the PCal channel used for calculating the calibration factors. (Default = CAL-PCALY_RX_PD_OUT_DQ)")
# These are all options related to the reference channels used in the calibraiton factors computation
parser.add_option("--ref-channels-sr", metavar = "Hz", default = 16, help = "Set the sample rate for the reference model channels used in the calibration factors calculation. (Default = 16 Hz)")
parser.add_option("--EP4-real", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_TST_REAL", help = "Set the name of the channel containing the real part of A_tst at the ESD line used for the \kappa_a and \kappa_pu calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_TST_REAL)")
parser.add_option("--EP5-real", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_REAL", help = "Set the name of the channel containing the real part of A_pu at the ESD line used for the \kappa_a calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_REAL)")
parser.add_option("--EP3-real", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_REAL", help = "Set the name of the channel containing the real part of 1/A_pu at the ESD line used for the \kappa_pu calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_REAL)")
parser.add_option("--EP4-imag", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_TST_IMAG", help = "Set the name of the channel containing the imaginary part of A_tst at the ESD line used for the \kappa_a and \kappa_pu calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_TST_IMAG")
parser.add_option("--EP5-imag", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_IMAG", help = "Set the name of the channel containing the imaginary part of A_pu at the ESD line used for the \kappa_A calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_IMAG")
parser.add_option("--EP3-imag", metavar = "name", default = "CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_IMAG", help = "Set the name of the channel containing the imaginary part of 1/A_pu at the ESD line used for the \kappa_PU calculation. (Default = CAL-CS_TDEP_DARM_LINE1_REF_A_USUM_INV_IMAG")
parser.add_option("--EP2-real", metavar = "name", default = "CAL-CS_TDEP_REF_CLGRATIO_CTRL_REAL", help = "Set the name of the channel containing the real part of the factors used to compute A(f_ctrl). (Default = CAL-CS_TDEP_REF_CLGRATIO_CTRL_REAL)")
parser.add_option("--EP2-imag", metavar = "name", default = "CAL-CS_TDEP_REF_CLGRATIO_CTRL_IMAG", help = "Set the name of the channel containing the imaginary part of the factors used to compute A(f_ctrl). (Default = CAL-CS_TDEP_REF_CLGRATIO_CTRL_IMAG)")
parser.add_option("--EP6-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_REAL", help = "Set the name of the channel containing the real part of C_res at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_REAL")
parser.add_option("--EP6-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_IMAG", help = "Set the name of the channel containing the imaginary part of C_res at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_C_NOCAVPOLE_IMAG")
parser.add_option("--EP7-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_D_REAL", help = "Set the name of the channel containing the real part of D at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_D_REAL")
parser.add_option("--EP7-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_D_IMAG", help = "Set the name of the channel containing the real part of D at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_D_IMAG")
parser.add_option("--EP8-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_REAL", help = "Set the name of the channel containing the real part of A_tst at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_REAL")
parser.add_option("--EP8-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_IMAG", help = "Set the name of the channel containing the real part of A_tst at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_TST_IMAG")
parser.add_option("--EP9-real", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_REAL", help = "Set the name of the channel containing the real part of A_pu at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_REAL")
parser.add_option("--EP9-imag", metavar = "name", default = "CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_IMAG", help = "Set the name of the channel containing the real part of A_pu at the PCal line used for the \kappa_c and f_cc calculation. (Default = CAL-CS_TDEP_PCALY_LINE2_REF_A_USUM_IMAG")
parser.add_option("--EP1-real", metavar = "name", default = "CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_REAL", help = "Set the name of the channel containing the real part of the \kappa_tst reference factors. (Default = CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_REAL)")
parser.add_option("--EP1-imag", metavar = "name", default = "CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_IMAG", help = "Set the name of the channel containing the imaginary part of the \kappa_tst reference factors. (Default = CAL-CS_TDEP_REF_INVA_CLGRATIO_TST_IMAG)")
parser.add_option("--different-control-whitening", action = "store_true", help = "Set when the whitening filters on each section of control chain are different. Only relevant in --split-actuation-chain mode") 

# These options are specific to the full calibration mode
parser.add_option("--full-calibration", action = "store_true", help = "Set this to run the pipeline in full calibration mode.")
parser.add_option("--darm-ctrl-channel-name", metavar = "name", default = "CAL-DARM_CTRL_WHITEN_OUT_DQ", help = "Set the name for the control signal channel. (Default = CAL-DARM_CTRL_WHTIEN_OUT_DQ)")
parser.add_option("--darm-err-channel-name", metavar = "name", default = "CAL-DARM_ERR_WHITEN_OUT_DQ", help = "Set the name of the error signal channel. (Default = CAL-DARM_ERR_WHITEN_OUT_DQ)")
parser.add_option("--control-chain-delay", metavar = "samples", type = int, default = 0, help = "Additional delay from the front end to apply to the control chain. Should be given as number of samples at sample rate specified by --sample-rate (default of 16384 Hz). (Default = 0)")
parser.add_option("--error-chain-delay", metavar = "samples", type = int, default = 0, help = "CALIBRATION MODE: Additional delay from the front end to apply to the error chain. Should be given as number of samples at sample rate specified by --sample-rate (default of 16384 Hz). (Default = 0)")

# These options are specific to the partial calibration mode
parser.add_option("--partial-calibration", action = "store_true", help = "Set this to run the pipeline in partial calibraiton mode.")
parser.add_option("--deltal-tst-channel-name", metavar = "name", default = "CAL-DELTAL_CTRL_TST_DQ", help = "Set the name of the partially calibrated control channel for the TST branch of the actuation. (Default = CAL-DELTAL_CTRL_TST_DQ)")
parser.add_option("--deltal-pum-channel-name", metavar = "name", default = "CAL-DELTAL_CTRL_PUM_DQ", help = "Set the name of the partially calibrated control channel for the PUM/UIM branch of the actuation. (Default = CAL-DELTAL_CTRL_PUM_DQ)")
parser.add_option("--deltal-uim-channel-name", metavar = "name", default = "CAL-DELTAL_CTRL_UIM_DQ", help = "Set the name of the partially calibrated control channel for the PUM/UIM branch of the actuation. (Default = CAL-DELTAL_CTRL_UIM_DQ)")
parser.add_option("--deltal-res-channel-name", metavar = "name", default = "CAL-DELTAL_RESIDUAL_DQ", help = "Set the name of the partially calibrated residual channe. (Default = CAL-DELTAL_RESIDUAL_DQ).")

#
# Parse options
#

options, filenames = parser.parse_args()

# Sanity checks for command line options
data_sources = set(("frames", "lvshm"))

if options.data_source not in data_sources:
	raise ValueError("--data-source must be one of %s" % ",".join(data_sources))

if options.data_source == "frames" and options.frame_cache is None:
	raise ValueError("--frame-cache must be specified when using --data-source=frames")

if options.wings is not None and options.data_source != "frames":
	raise ValueError("--wings can only be set when --data-source=frames")

if options.wings is not None and (options.wings % (options.frames_per_file * options.frame_duration)) and (options.wings > (options.frames_per_file * options.frame_duration)):
	raise ValueError("--wings must be an integer multiple of --frames-per-file * --frame-duration when --wings is greater than --frames-per-file * --frame-duration")

if options.wings is not None and (options.wings < (options.frames_per_file * options.frame_duration)) and (((int(options.gps_start_time)+options.wings) % (options.frames_per_file * options.frame_duration) != 0) or ((int(options.gps_end_time)-options.wings) % (options.frames_per_file * options.frame_duration) != 0)):
	raise ValueError("when you want --wings < --frames-per-file * --frame-duration just set your GPS start and end times to be the value of --wings before and after an integer second boundarty of --frames-per-file * --frame-duration")

if options.ifo is None:
	raise ValueError("must specify --ifo")

if options.full_calibration and (options.darm_ctrl_channel_name is None or options.darm_err_channel_name is None):
	raise ValueError("must specify --darm-ctrl-channel-name and --darm-err-channel-name when in full calibration mode") 

if options.partial_calibration and (options.deltal_tst_channel_name is None or options.deltal_pum_channel_name is None or options.deltal_uim_channel_name is None or options.deltal_res_channel_name is None):
	raise ValueError("must specify --deltal-tst-channel-name, deltal-pum-channel-name, --deltal-uim-channel-name and deltal-res-channel-name in partial calibration mode")

if options.frame_segments_file is not None and options.data_source != "frames":
	raise ValueError("can only give --frame-segments-file if --data-source=frames")

if options.frame_segments_name is not None and options.frame_segments_file is None:
	raise ValueError("can only specify --frame-segments-name if --frame-segments-file is given")

if options.data_source == "frames" and (options.gps_start_time is None or options.gps_end_time is None):
	raise ValueError("must specify --gps-start-time and --gps-end-time when --data-source=frames")

if options.full_calibration is None and options.partial_calibration is None:
	raise ValueError("must specify a mode of the pipeline: either --full-calibration or --partial-calibration")

if int(options.record_factors_sr) > int(options.compute_factors_sr):
	raise ValueError("--record-factors-sr must be less than or equal to --compute-factors-sr")

if options.gps_start_time is not None:
	if options.gps_end_time is None:
		raise ValueError("must provide both --gps-start-time and --gps-end-time")
	if options.data_source == "lvshm" or options.data_source == "white":
		raise ValueError("cannot set --gps-start-time or --gps-end-time with --data-source=lvshm or --data-source=white")
	try:
		start = LIGOTimeGPS(options.gps_start_time)
	except ValueError:
		raise ValueError("invalid --gps-start-time %s" % options.gps_start_time)
	try:
		end = LIGOTimeGPS(options.gps_end_time)
	except ValueError:
		raise ValueError("invalid --gps-end-time %s" % options.gps_end_time)
	if start >= end:
		raise ValueError("--gps-start-time must be < --gps-end-time: %s < %s" % (options.gps_start_time, options.gps_end_time))
	# segment from gps start and stop time if given
	seg = segments.segment(start, end)
	# seek event from the gps start and stop time if given
	seekevent = gst.event_new_seek(1., gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH | gst.SEEK_FLAG_KEY_UNIT, gst.SEEK_TYPE_SET, seg[0].ns(), gst.SEEK_TYPE_SET, seg[1].ns())
elif options.gps_end_time is not None:
	raise ValueError("must provide both --gps-start-time and --gps-end-time")

# Set up instrument and channel name info from command line options
instrument = options.ifo

if options.frame_segments_file is not None:
	# Frame segments from a user defined file
	frame_segments = ligolw_segments.segmenttable_get_by_name(utils.load_filename(options.frame_segments_file, contenthandler = datasource.ContentHandler), options.frame_segments_name).coalesce()
	if seg is not None:
		# clip frame segments to seek segment if it exists (not required, just saves some meory and I/O overhead)
		frame_segments = segments.segmentlistdict((instrument, seglist & segments.segmentlist([seg])) for instrument, seglist in frame_segments.items())
else:
	frame_segments = None

# Set up short-cut names for each of the sample rates used throughout the pipeline and establish caps
sr = options.sample_rate  # Sample rate for h(t)
dqsr = options.dq_sample_rate  # Sample rate for the CALIB_STATE_VECTOR
odcsr = options.odc_sample_rate # Sample rate of the ODC channel that is read in
ctrlsr = options.control_sample_rate # Sample rate of the control channel (such as DARM_CTRL or DELTAL_CTRL)
caps = "audio/x-raw-float, width=64, rate=%d, channels=1, endianness=1234" % sr # = 8 bytes, a double
ctrl_caps = "audio/x-raw-float, width=64, rate=%d, channels=1, endianness=1234" % ctrlsr # = 8 bytes, a double
if options.chan_suffix is not None:
	chan_suffix = options.chan_suffix
else:
	chan_suffix = ""
chan_prefix = options.chan_prefix

td = not options.frequency_domain_filtering

# Make sure we have sufficient resources
# We allocate far more memory than we need, so this is okay

def setrlimit(res, lim):
	hard_lim = resource.getrlimit(res)[1]
	resource.setrlimit(res, (lim if lim is not None else hard_lim, hard_lim))

# set the number of processes and total set size up to hard limit and shrink the per thread stack size (default is 10 MiB)
setrlimit(resource.RLIMIT_NPROC, None)
setrlimit(resource.RLIMIT_AS, None)
setrlimit(resource.RLIMIT_RSS, None)
setrlimit(resource.RLIMIT_STACK, 1024*1024) # 1 Mib per thread

#
# Setup the pipeline
#

pipeline = gst.Pipeline(sys.argv[0])
mainloop = gobject.MainLoop()
handler = simplehandler.Handler(mainloop, pipeline)

# 
# Turn off debugging tools or verboseness
#

pipeparts.mkchecktimestamps = lambda pipeline, src, *args: src # comment this line out to turn on the checktimestamps debugging
if not options.verbose:
	pipeparts.mkprogressreport = lambda pipeline, src, *args: src

#
# Read in data from frames or shared memory
#

if options.data_source == "lvshm": # Data is to be read from shared memory
	src = pipeparts.mklvshmsrc(pipeline, shm_name = options.shared_memory_partition, assumed_duration = 1)
elif options.data_source == "frames": # Data is to be read from frame files
	src = pipeparts.mklalcachesrc(pipeline, location = options.frame_cache, cache_dsc_regex = instrument)

#
# Set up the appropriate channel list
#

head_dict = {}

# I will also be filling a list called headkeys that will be the keys for the dictionary holding each pipeline branch name
if options.full_calibration: # For full calibration we need DARM_ERR and DARM_CTRL as our input channels
	channel_list = [(instrument, options.darm_ctrl_channel_name), (instrument, options.darm_err_channel_name)]
	headkeys = ["ctrl", "res"]
elif options.partial_calibration: # For partial calibration we need DELTAL_TST, DELTAL_PUM, DELTAL_UIM, and DELTAL_RES
	channel_list = [(instrument, options.deltal_tst_channel_name), (instrument, options.deltal_pum_channel_name), (instrument, options.deltal_uim_channel_name), (instrument, options.deltal_res_channel_name)]
	headkeys = ["tst", "pum", "uim", "res"]
	
# We need to make sure we have DARM_ERR and the PCAL channel for computing \kappas
if not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappatst or not options.no_kappapu:
	if options.partial_calibration:
		channel_list.append((instrument, options.darm_err_channel_name))
		headkeys.append("darm_err")
	channel_list.append((instrument, options.pcal_channel_name))
	headkeys.append("pcal")

# We also need the excitation channel for computing kappas
if (not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappapu):
	channel_list.append((instrument, options.exc_channel_name))
	headkeys.append("exc")
	# If we are computing the factors in the pipeline, we need the reference model EPICS records
	if not options.factors_from_filters_file:
		channel_list.extend(((instrument, options.EP2_real), (instrument, options.EP2_imag), (instrument, options.EP3_real), (instrument, options.EP3_imag), (instrument, options.EP4_real), (instrument, options.EP4_imag)))
		headkeys.extend(("EP2_real", "EP2_imag", "EP3_real", "EP3_imag", "EP4_real", "EP4_imag"))
		if not options.no_kappaa:	
			channel_list.extend(((instrument, options.EP5_real), (instrument, options.EP5_imag)))
			headkeys.extend(("EP5_real", "EP5_imag"))

# If we are computing either kappa_c or f_cc, we need some more EPICS records
if (not options.no_kappac or not options.no_fcc) and not options.factors_from_filters_file:
	channel_list.extend(((instrument, options.EP6_real), (instrument, options.EP6_imag), (instrument, options.EP7_real), (instrument, options.EP7_imag), (instrument, options.EP8_real), (instrument, options.EP8_imag), (instrument, options.EP9_real), (instrument, options.EP9_imag)))
	headkeys.extend(("EP6_real", "EP6_imag", "EP7_real", "EP7_imag", "EP8_real", "EP8_imag", "EP9_real", "EP9_imag"))

# If we are computing kappa_tst, kappa_a or kappa_c, we need more channels
if not options.no_kappatst or not options.no_kappaa or not options.no_kappac or not options.no_fcc:
	channel_list.append((instrument, options.tst_exc_channel_name))
	headkeys.append("tstexc")
	if not options.factors_from_filters_file:
		channel_list.extend(((instrument, options.EP1_real), (instrument, options.EP1_imag)))
		headkeys.extend(("EP1_real", "EP1_imag"))
	
# If we are computing the CALIB_STATE_VECTOR, we need yet another channel
if not options.no_dq_vector:
	channel_list.append((instrument, options.dq_channel_name))
	headkeys.append("odcstatevector")

#
# Hook up the relevant channels to the demuxer
#

if options.data_source == "lvshm":
	demux = pipeparts.mkframecppchanneldemux(pipeline, src, do_file_checksum = True, skip_bad_files = True, channel_list = map("%s:%s".__mod__, channel_list))
elif options.data_source == "frames":
	demux = pipeparts.mkframecppchanneldemux(pipeline, src, do_file_checksum = True, skip_bad_files = False, channel_list = map("%s:%s".__mod__, channel_list))
# Write the pipeline graph after pads have been hooked up to the demuxer
if options.write_pipeline is not None:
	demux.connect("no-more-pads", write_graph)	
# Make sure the code exits when it encounters a non-zero dataValid flag and is running in "offline mode" (i.e. reading from frames)
def exit_on_nonzero_datavalid(pad, ignored):
	datavalid = pad.get_property("datavalid")
	if datavalid != 0:
		print "ERROR: Non-zero dataValid flag encountered"
		sys.exit()
def connect_notify_datavalid_signal(demux, pad):
	name = pad.get_name()
	pad.connect("notify::datavalid", exit_on_nonzero_datavalid)
if options.data_source == "frames":
	demux.connect("pad-added", connect_notify_datavalid_signal)

# Get everything hooked up and blocked off to no more than 1 second buffers
for key, chan in zip(headkeys, channel_list):
	head_dict[key] = calibration_parts.hook_up_and_reblock(pipeline, demux, chan[1], instrument)

# Tee off the ODC channel to check for gaps and convert it to unsigned ints (if necessary)
if not options.no_dq_vector:
	odcgaptee = pipeparts.mktee(pipeline, head_dict["odcstatevector"])
	odcstatevector = calibration_parts.mkqueue(pipeline, odcgaptee)
	# FIXME: When the ODC is written as unsigned ints, this piece can be removed
	odcstatevector = pipeparts.mkaudioconvert(pipeline, odcstatevector)
	head_dict["odcstatevector"] = pipeparts.mkcapsfilter(pipeline, odcstatevector, "audio/x-raw-int, signed=false")
	

# When reading from disk, clip the incoming data stream(s) to segment list
if options.data_source == "frames" and frame_segments is not None:
	for key in headkeys:
		currenthead = head_dict[key]
		head_dict[key] = pipeparts.mkgate(pipeline, currenthead, threshold = 1, control = pipeparts.mksegmentsrc(pipeline, frame_segments[instrument]))


# Set up the statevector for gating \kappas
if not options.no_dq_vector:
	odcstatevectortee = pipeparts.mktee(pipeline, head_dict["odcstatevector"])
	statevector = pipeparts.mkstatevector(pipeline, calibration_parts.mkqueue(pipeline, odcstatevectortee), required_on = options.science_quality_bitmask)
	statevectortee = pipeparts.mktee(pipeline, statevector)
	odcstatevector = calibration_parts.mkqueue(pipeline, odcstatevectortee)
#
# Load in the filters file that contains filter coefficients, etc.
#

filters = numpy.load(options.filters_file)

# If we're reading the reference model factors from the filters file, load them
if options.factors_from_filters_file:
	EP1_real = float(filters["EP1_real"])
	EP1_imag = float(filters["EP1_imag"])
	EP2_real = float(filters["EP2_real"])
	EP2_imag = float(filters["EP2_imag"])
	EP3_real = float(filters["EP3_real"])
	EP3_imag = float(filters["EP3_imag"])
	EP4_real = float(filters["EP4_real"])
	EP4_imag = float(filters["EP4_imag"])
	EP5_real = float(filters["EP5_real"])
	EP5_imag = float(filters["EP5_imag"])
	EP6_real = float(filters["EP6_real"])
	EP6_imag = float(filters["EP6_imag"])
	EP7_real = float(filters["EP7_real"])
	EP7_imag = float(filters["EP7_imag"])
	EP8_real = float(filters["EP8_real"])
	EP8_imag = float(filters["EP8_imag"])
	EP9_real = float(filters["EP9_real"])
	EP9_imag = float(filters["EP9_imag"])

# Load all of the kappa whitening and correction facrtors
ka_pcal_line_freq = float(filters["ka_pcal_line_freq"])
ka_pcal_W_real = float(filters["ka_pcal_whitener_re"])
ka_pcal_W_imag = float(filters["ka_pcal_whitener_im"])
ka_pcal_corr_real = float(filters["ka_pcal_corr_re"])
ka_pcal_corr_imag = float(filters["ka_pcal_corr_im"])
ka_esd_line_freq = float(filters["ka_esd_line_freq"])
ka_esd_W_real = float(filters["ka_esd_whitener_re"])
ka_esd_W_imag = float(filters["ka_esd_whitener_im"])
kc_pcal_line_freq = float(filters["kc_pcal_line_freq"])
kc_pcal_W_real = float(filters["kc_pcal_whitener_re"])
kc_pcal_W_imag = float(filters["kc_pcal_whitener_im"])
kc_pcal_corr_real = float(filters["kc_pcal_corr_re"])
kc_pcal_corr_imag = float(filters["kc_pcal_corr_im"])
ktst_esd_line_freq = float(filters["ktst_esd_line_freq"])
ktst_esd_W_real = float(filters["ktst_esd_whitener_re"])
ktst_esd_W_imag = float(filters["ktst_esd_whitener_im"])

# If we're performing partial calibration, load the deltal filters
if options.partial_calibration:
	tstdewhitensr = int(filters["deltal_tst_dewhiten_sr"])
	pumuimdewhitensr = int(filters["deltal_pumuim_dewhiten_sr"])
	tstdewhitendelay = filters["deltal_tst_dewhiten_delay"]
	pumuimdewhitendelay = filters["deltal_pumuim_dewhiten_delay"]
	tstdewhiten = filters["deltal_tst_dewhiten"]
	pumuimdewhiten = filters["deltal_pumuim_dewhiten"]
	reschaindelay = filters["res_corr_delay"]
	reschainfilt = filters["res_corr_filter"]
	resdewhitendelay = filters["deltal_res_dewhiten_delay"]
	resdewhiten = filters["deltal_res_dewhiten"]
	ctrlcorrdelay = filters["ctrl_corr_delay"]
	ctrlcorrfilt = filters["ctrl_corr_filter"]
# If we're performing full calibration, load the actuation, sensing filters
if options.full_calibration:
	tstchainsr = int(filters["actuation_tst_sr"])
	pumuimchainsr = int(filters["actuation_pumuim_sr"])
	tstdelay = filters["actuation_tst_delay"]
	pumuimdelay = filters["actuation_pumuim_delay"]
	tstfilt = filters["actuation_tst"]
	pumuimfilt = filters["actuation_pumuim"]
	ctrldewhitendelay = filters["dewhiten_ctrl_delay"]
	ctrldewhiten = filters["dewhiten_ctrl"]
	ctrldewhitensr = int(filters["dewhiten_ctrl_sr"])
	reschaindelay = filters["inv_sens_delay"]
	reschainfilt = filters["inv_sensing"]
	resdewhitendelay = filters["dewhiten_err_delay"]
	resdewhiten = filters["dewhiten_err"]
ctrlcorrsr = int(filters["ctrl_corr_sr"])

#
# TIME-VARYING FACTORS COMPUTATIONS
#

# Set up all of the inputs for the calibration factors
if not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappatst or not options.no_kappapu:
	# caps strings for the computation
	ref_factors_caps = "audio/x-raw-float, width=64, rate=%d, channels=1, endianness=1234" % options.ref_channels_sr
	compute_calib_factors_caps = "audio/x-raw-float, width=64, rate=%d, channels=1, endianness=1234" % options.compute_factors_sr
	compute_calib_factors_complex_caps = "audio/x-raw-complex, width=128, rate=%d, channels=1, endianness=1234" % options.compute_factors_sr

	pcal = calibration_parts.caps_and_progress(pipeline, head_dict["pcal"], caps, "pcal")
	if options.full_calibration:
		darm_errtee = pipeparts.mktee(pipeline, head_dict["res"])
		darm_err = calibration_parts.mkqueue(pipeline, darm_errtee)
		head_dict["res"] = calibration_parts.mkqueue(pipeline, darm_errtee)
	else:
		darm_err = head_dict["darm_err"]
	darm_err = calibration_parts.caps_and_progress(pipeline, darm_err, caps, "darm_err")

if not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappapu:
	exc = calibration_parts.caps_and_progress(pipeline, head_dict["exc"], caps, "exc")

if not options.no_kappatst or not options.no_kappaa or not options.no_kappac or not options.no_fcc:
        tstexccaps = "audio/x-raw-float, rate=%d, channels=1, width=64, endianness=1234" % options.tst_exc_sample_rate
        tstexc = calibration_parts.caps_and_progress(pipeline, head_dict["tstexc"], tstexccaps, "tstexc")

for key in headkeys:
	if key.startswith("EP"):
		head_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		head_dict[key] = calibration_parts.mkupsample(pipeline, head_dict[key], compute_calib_factors_caps)

# Set up computations for \kappa_a, \kappa_tst,\kappa_c, \kappa_pu, f_cc, if applicable
if not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappatst or not options.no_kappapu:
	# Set up smoothing, averaging and integration sample sizes
	factors_integration_samples = int(options.factors_integration_time) * options.compute_factors_sr
	factors_averaging_samples = int(options.factors_averaging_time) * options.compute_factors_sr
	median_smoothing_samples = int(options.median_smoothing_time * options.compute_factors_sr)

	pcaltee = pipeparts.mktee(pipeline, pcal)
	derrtee = pipeparts.mktee(pipeline, darm_err)

	ka_pcalR_nocorr, ka_pcalI_nocorr = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, pcaltee), sr, ka_pcal_line_freq, caps, compute_calib_factors_caps, factors_integration_samples, td)
	ka_pcalR, ka_pcalI = calibration_parts.filter_at_line(pipeline, calibration_parts.mkqueue(pipeline, ka_pcalR_nocorr), calibration_parts.mkqueue(pipeline, ka_pcalI_nocorr), ka_pcal_corr_real, ka_pcal_corr_imag, compute_calib_factors_caps)

	ka_derrfpR, ka_derrfpI = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, derrtee), sr, ka_pcal_line_freq, caps, compute_calib_factors_caps, factors_integration_samples, td)
	ka_derrWfpR, ka_derrWfpI = calibration_parts.filter_at_line(pipeline, calibration_parts.mkqueue(pipeline, ka_derrfpR), calibration_parts.mkqueue(pipeline, ka_derrfpI), ka_pcal_W_real, ka_pcal_W_imag, compute_calib_factors_caps)

	pcalfp_derrfpR, pcalfp_derrfpI = calibration_parts.complex_division(pipeline, ka_derrWfpR, ka_derrWfpI, ka_pcalR, ka_pcalI, compute_calib_factors_caps)
	pcalfp_derrfpR = pipeparts.mktee(pipeline, pcalfp_derrfpR)
	pcalfp_derrfpI = pipeparts.mktee(pipeline, pcalfp_derrfpI)
	

	# This is where the \kappa_tst specific stuff starts
	tstexc = calibration_parts.mkresample(pipeline, tstexc, caps)
	ktst_tstexcR, ktst_tstexcI = calibration_parts.demodulate(pipeline, tstexc, sr, ktst_esd_line_freq, caps, compute_calib_factors_caps, factors_integration_samples, td)

	ktst_derrftstR, ktst_derrftstI = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, derrtee), sr, ktst_esd_line_freq, caps, compute_calib_factors_caps, factors_integration_samples, td)
	ktst_derrWftstR, ktst_derrWftstI = calibration_parts.filter_at_line(pipeline, calibration_parts.mkqueue(pipeline, ktst_derrftstR), calibration_parts.mkqueue(pipeline, ktst_derrftstI), ktst_esd_W_real, ktst_esd_W_imag, compute_calib_factors_caps)

	if not options.factors_from_filters_file:
		ktstR, ktstI = calibration_parts.compute_kappatst(pipeline, calibration_parts.mkqueue(pipeline, ktst_derrWftstR), calibration_parts.mkqueue(pipeline, ktst_derrWftstI), calibration_parts.mkqueue(pipeline, ktst_tstexcR), calibration_parts.mkqueue(pipeline, ktst_tstexcI), calibration_parts.mkqueue(pipeline, pcalfp_derrfpR), calibration_parts.mkqueue(pipeline, pcalfp_derrfpI), calibration_parts.mkqueue(pipeline, head_dict["EP1_real"]), calibration_parts.mkqueue(pipeline, head_dict["EP1_imag"]), compute_calib_factors_caps, compute_calib_factors_complex_caps)
	elif options.factors_from_filters_file:
		ktstR, ktstI = calibration_parts.compute_kappatst_from_filters_file(pipeline, calibration_parts.mkqueue(pipeline, ktst_derrWftstR), calibration_parts.mkqueue(pipeline, ktst_derrWftstI), calibration_parts.mkqueue(pipeline, ktst_tstexcR), calibration_parts.mkqueue(pipeline, ktst_tstexcI), calibration_parts.mkqueue(pipeline, pcalfp_derrfpR), calibration_parts.mkqueue(pipeline, pcalfp_derrfpI), EP1_real, EP1_imag, compute_calib_factors_caps, compute_calib_factors_complex_caps)

	ktstRteedq = pipeparts.mktee(pipeline, ktstR)
	ktstIteedq = pipeparts.mktee(pipeline, ktstI)

	ktstRInRange, ktstIInRange, ktstRtee, ktstItee = calibration_parts.average_and_check_range(pipeline, ktstRteedq, ktstIteedq, options.kappatst_real_ok_var, options.kappatst_imag_ok_var, options.factors_hold_time, options.expected_kappatst_real, options.expected_kappatst_imag, factors_averaging_samples, median_smoothing_samples, compute_calib_factors_caps)

	if not options.no_kappatst:
		ktstRout = calibration_parts.mkqueue(pipeline, ktstRtee)
		ktstIout = calibration_parts.mkqueue(pipeline, ktstItee)
	
# If we're also computing \kappa_a, \kappa_c, f_cc, or \kappa_pu, keep going
if not options.no_kappaa or not options.no_kappac or not options.no_fcc or not options.no_kappapu:
	ka_excR, ka_excI = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, exc), sr, ka_esd_line_freq,caps, compute_calib_factors_caps, factors_integration_samples, td)

	ka_derrfxR, ka_derrfxI = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, derrtee), sr, ka_esd_line_freq, caps, compute_calib_factors_caps, factors_integration_samples, td)
	ka_derrWfxR, ka_derrWfxI = calibration_parts.filter_at_line(pipeline, calibration_parts.mkqueue(pipeline, ka_derrfxR), calibration_parts.mkqueue(pipeline, ka_derrfxI), ka_esd_W_real, ka_esd_W_imag, compute_calib_factors_caps)

	if not options.factors_from_filters_file:
		AfctrlR, AfctrlI = calibration_parts.compute_kappatst(pipeline, ka_derrWfxR, ka_derrWfxI, ka_excR, ka_excI, calibration_parts.mkqueue(pipeline, pcalfp_derrfpR), calibration_parts.mkqueue(pipeline, pcalfp_derrfpI), pipeparts.mkaudioamplify(pipeline, head_dict["EP2_real"], -1.0), pipeparts.mkaudioamplify(pipeline, head_dict["EP2_imag"], -1.0), compute_calib_factors_caps, compute_calib_factors_complex_caps)
	elif options.factors_from_filters_file:
		AfctrlR, AfctrlI = calibration_parts.compute_kappatst_from_filters_file(pipeline, ka_derrWfxR, ka_derrWfxI, ka_excR, ka_excI, calibration_parts.mkqueue(pipeline, pcalfp_derrfpR), calibration_parts.mkqueue(pipeline, pcalfp_derrfpI), -1.0 * EP2_real, -1.0 * EP2_imag, compute_calib_factors_caps, compute_calib_factors_complex_caps)
	if not options.no_kappaa:
		AfctrlR = pipeparts.mktee(pipeline, AfctrlR)
		AfctrlI = pipeparts.mktee(pipeline, AfctrlI)
		if not options.factors_from_filters_file:
			head_dict["EP4_real"] = pipeparts.mktee(pipeline, head_dict["EP4_real"])
			head_dict["EP4_imag"] = pipeparts.mktee(pipeline, head_dict["EP4_imag"])

	# \kappa_pu calcuation, which needs to happen for any of the other kappas to be computed
	if not options.factors_from_filters_file:
		kpuR, kpuI = calibration_parts.compute_kappapu(pipeline, calibration_parts.mkqueue(pipeline, head_dict["EP3_real"]), calibration_parts.mkqueue(pipeline, head_dict["EP3_imag"]), calibration_parts.mkqueue(pipeline, AfctrlR), calibration_parts.mkqueue(pipeline, AfctrlI), calibration_parts.mkqueue(pipeline, ktstRteedq), calibration_parts.mkqueue(pipeline, ktstIteedq), calibration_parts.mkqueue(pipeline, head_dict["EP4_real"]), calibration_parts.mkqueue(pipeline, head_dict["EP4_imag"]), compute_calib_factors_caps, compute_calib_factors_complex_caps)
	elif options.factors_from_filters_file:
		kpuR, kpuI = calibration_parts.compute_kappapu_from_filters_file(pipeline, EP3_real, EP3_imag, calibration_parts.mkqueue(pipeline, AfctrlR), calibration_parts.mkqueue(pipeline, AfctrlI), calibration_parts.mkqueue(pipeline, ktstRteedq), calibration_parts.mkqueue(pipeline, ktstIteedq), EP4_real, EP4_imag, compute_calib_factors_caps, compute_calib_factors_complex_caps)

	kpuRteedq = pipeparts.mktee(pipeline, kpuR)
	kpuIteedq = pipeparts.mktee(pipeline, kpuI)

	kpuRInRange, kpuIInRange, kpuRtee, kpuItee = calibration_parts.average_and_check_range(pipeline, kpuRteedq, kpuIteedq, options.kappapu_real_ok_var, options.kappapu_imag_ok_var, options.factors_hold_time, options.expected_kappapu_real, options.expected_kappapu_imag, factors_averaging_samples, median_smoothing_samples, compute_calib_factors_caps)

	if not options.no_kappapu:
		kpuRout = calibration_parts.mkqueue(pipeline, kpuRtee)
		kpuIout = calibration_parts.mkqueue(pipeline, kpuItee)
	

	# Here's \kappa_a specific stuff
	if not options.no_kappaa:
		if not options.factors_from_filters_file:
			kaR, kaI = calibration_parts.compute_kappaa(pipeline, calibration_parts.mkqueue(pipeline, AfctrlR), calibration_parts.mkqueue(pipeline, AfctrlI), calibration_parts.mkqueue(pipeline, head_dict["EP4_real"]), calibration_parts.mkqueue(pipeline, head_dict["EP4_imag"]), calibration_parts.mkqueue(pipeline, head_dict["EP5_real"]), calibration_parts.mkqueue(pipeline, head_dict["EP5_imag"]), compute_calib_factors_caps, compute_calib_factors_complex_caps)
		elif options.factors_from_filters_file:
			kaR, kaI = calibration_parts.compute_kappaa_from_filters_file(pipeline, calibration_parts.mkqueue(pipeline, AfctrlR), calibration_parts.mkqueue(pipeline, AfctrlI), EP4_real, EP4_imag, EP5_real, EP5_imag, compute_calib_factors_caps, compute_calib_factors_complex_caps)

		kaRteedq = pipeparts.mktee(pipeline, kaR)
		kaIteedq = pipeparts.mktee(pipeline, kaI)		
	
		kaRInRange, kaIInRange, kaRtee, kaItee = calibration_parts.average_and_check_range(pipeline, kaRteedq, kaIteedq, options.kappaa_real_ok_var, options.kappaa_imag_ok_var, options.factors_hold_time, options.expected_kappaa_real, options.expected_kappaa_imag, factors_averaging_samples, median_smoothing_samples, compute_calib_factors_caps)

		kaRout = calibration_parts.mkqueue(pipeline, kaRtee)
		kaIout = calibration_parts.mkqueue(pipeline, kaItee)

	# Finally, compute \kappa_c and f_cc
	if not options.no_kappac or not options.no_fcc:
		kc_pcalR_nocorr, kc_pcalI_nocorr = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, pcaltee), sr, kc_pcal_line_freq, caps, compute_calib_factors_caps, factors_integration_samples, td)
		kc_pcalR, kc_pcalI = calibration_parts.filter_at_line(pipeline, calibration_parts.mkqueue(pipeline, kc_pcalR_nocorr), calibration_parts.mkqueue(pipeline, kc_pcalI_nocorr), kc_pcal_corr_real, kc_pcal_corr_imag, compute_calib_factors_caps)

		kc_derrR, kc_derrI = calibration_parts.demodulate(pipeline, calibration_parts.mkqueue(pipeline, derrtee), sr, kc_pcal_line_freq, caps, compute_calib_factors_caps, factors_integration_samples, td)
		kc_derrWR, kc_derrWI = calibration_parts.filter_at_line(pipeline, calibration_parts.mkqueue(pipeline, kc_derrR), calibration_parts.mkqueue(pipeline, kc_derrI), kc_pcal_W_real, kc_pcal_W_imag, compute_calib_factors_caps)

		kc_pcal_derrR, kc_pcal_derrI = calibration_parts.complex_division(pipeline, kc_derrWR, kc_derrWI, kc_pcalR, kc_pcalI, compute_calib_factors_caps)
		
		if not options.factors_from_filters_file:
			SR, SI = calibration_parts.compute_S(pipeline, calibration_parts.mkqueue(pipeline, head_dict["EP6_real"]), calibration_parts.mkqueue(pipeline, head_dict["EP6_imag"]), calibration_parts.mkqueue(pipeline, kc_pcal_derrR), calibration_parts.mkqueue(pipeline, kc_pcal_derrI), calibration_parts.mkqueue(pipeline, ktstRteedq), calibration_parts.mkqueue(pipeline, ktstIteedq), calibration_parts.mkqueue(pipeline, kpuRteedq), calibration_parts.mkqueue(pipeline, kpuIteedq), calibration_parts.mkqueue(pipeline, head_dict["EP7_real"]), calibration_parts.mkqueue(pipeline, head_dict["EP7_imag"]), calibration_parts.mkqueue(pipeline, head_dict["EP8_real"]), calibration_parts.mkqueue(pipeline, head_dict["EP8_imag"]), calibration_parts.mkqueue(pipeline, head_dict["EP9_real"]), calibration_parts.mkqueue(pipeline, head_dict["EP9_imag"]), compute_calib_factors_caps, compute_calib_factors_complex_caps)
		elif options.factors_from_filters_file:
			SR, SI = calibration_parts.compute_S_from_filters_file(pipeline, EP6_real, EP6_imag, calibration_parts.mkqueue(pipeline, kc_pcal_derrR), calibration_parts.mkqueue(pipeline, kc_pcal_derrI), calibration_parts.mkqueue(pipeline, ktstRteedq), calibration_parts.mkqueue(pipeline, ktstIteedq), calibration_parts.mkqueue(pipeline, kpuRteedq), calibration_parts.mkqueue(pipeline, kpuIteedq), EP7_real, EP7_imag, EP8_real, EP8_imag, EP9_real, EP9_imag, compute_calib_factors_caps, compute_calib_factors_complex_caps)
		SRtee = pipeparts.mktee(pipeline, SR)
		SItee = pipeparts.mktee(pipeline, SI)
		if not options.no_kappac:
			kc = calibration_parts.compute_kappac(pipeline, calibration_parts.mkqueue(pipeline, SRtee), calibration_parts.mkqueue(pipeline, SItee), compute_calib_factors_caps)
			
			kcteedq = pipeparts.mktee(pipeline, kc)
			# Produce a channel that says whether lal_check_calib_factors will compute a good value or not.  Use this in the statevector bit for this \kappa
			kcInRange = pipeparts.mkgeneric(pipeline, calibration_parts.mkaudiorate(pipeline, calibration_parts.mkqueue(pipeline, kcteedq)), "lal_smoothcalibfactors", max_value = options.kappac_ok_var + options.expected_kappac, min_value = options.expected_kappac - options.kappac_ok_var, default_val = options.expected_kappac, statevector = True, max_size = factors_averaging_samples)

			kc = calibration_parts.average_calib_factors(pipeline, calibration_parts.mkqueue(pipeline, kcteedq), options.kappac_ok_var, options.expected_kappac, factors_averaging_samples, compute_calib_factors_caps, options.factors_hold_time, median_smoothing_samples)
			kctee = pipeparts.mktee(pipeline, kc)
			kcout = calibration_parts.mkqueue(pipeline, kctee)
		if not options.no_fcc:
			fcc = calibration_parts.compute_fcc(pipeline, calibration_parts.mkqueue(pipeline, SRtee), calibration_parts.mkqueue(pipeline, SItee), kc_pcal_line_freq, compute_calib_factors_caps)
			fccteedq = pipeparts.mktee(pipeline, fcc)
			fccInRange = pipeparts.mkgeneric(pipeline, calibration_parts.mkaudiorate(pipeline, calibration_parts.mkqueue(pipeline, fccteedq)), "lal_smoothcalibfactors", max_value = options.fcc_ok_var + options.expected_fcc, min_value = options.expected_fcc - options.fcc_ok_var, default_val = options.expected_fcc, statevector = True, max_size = factors_averaging_samples)
			fccout = calibration_parts.average_calib_factors(pipeline, calibration_parts.mkqueue(pipeline, fccteedq), options.fcc_ok_var_for_average, options.expected_fcc, factors_averaging_samples, compute_calib_factors_caps, options.factors_hold_time, median_smoothing_samples)

#
# CONTROL BRANCH
#

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank
ctrlcorrcaps = "audio/x-raw-float, width=64, channels=1, endianness=1234, rate=%d" % ctrlcorrsr
if options.partial_calibration:
	tst = calibration_parts.caps_and_progress(pipeline, head_dict["tst"], ctrl_caps, "tst")
	tst = pipeparts.mkfirbank(pipeline, tst, fir_matrix = [[0,1]], time_domain = td)
	if options.different_control_whitening:
		tst = calibration_parts.mkresample(pipeline, tst, "audio/x-raw-float, width=64, channels=1, endianness=1234, rate=%d" % tstdewhitensr)
		tst = pipeparts.mkfirbank(pipeline, tst, latency = int(tstdewhitendelay), fir_matrix = [tstdewhiten[::-1]], time_domain = td)
	tst = calibration_parts.mkresample(pipeline, tst, ctrlcorrcaps)

	pum = calibration_parts.caps_and_progress(pipeline, head_dict["pum"], ctrl_caps, "pum")
	uim = calibration_parts.caps_and_progress(pipeline, head_dict["uim"], ctrl_caps, "uim")
	pumuim = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pum, uim), ctrl_caps)
	pumuim = pipeparts.mkaudioconvert(pipeline, pumuim)
	pumuim = pipeparts.mkcapsfilter(pipeline, pumuim, ctrl_caps) 
	pumuim = pipeparts.mkfirbank(pipeline, pumuim, fir_matrix = [[0,1]])
	if options.different_control_whitening:
		pumuim = calibration_parts.mkresample(pipeline, pumuim, "audio/x-raw-float, width=64, channels=1, endianness=1234, rate=%d" % pumuimdewhitensr) 
		pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = int(pumuimdewhitendelay), fir_matrix = [pumuimdewhiten[::-1]], time_domain = td)
	pumuim = calibration_parts.mkresample(pipeline, pumuim, ctrlcorrcaps)

if options.full_calibration:
	ctrl = calibration_parts.caps_and_progress(pipeline, head_dict["ctrl"], caps, "ctrl")
	ctrl = pipeparts.mkfirbank(pipeline, ctrl, fir_matrix = [[0,1]])
	ctrl = calibration_parts.mkresample(pipeline, ctrl, "audio/x-raw-float, width=64, channels=1, endianness=1234, rate=%d" % ctrldewhitensr)
	ctrl = pipeparts.mkfirbank(pipeline, ctrl, latency = int(ctrldewhitendelay), fir_matrix = [ctrldewhiten[::-1]], time_domain = td)
	ctrltee = pipeparts.mktee(pipeline, ctrl)

	tst = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, ctrltee), "audio/x-raw-float, width=64, channels=1, endianness=1234, rate=%d" %  tstchainsr)
	tst = pipeparts.mkfirbank(pipeline, tst, latency = int(tstdelay), fir_matrix = [tstfilt[::-1]], time_domain = td)
	tst = calibration_parts.mkresample(pipeline, tst, ctrlcorrcaps)

	pumuim = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, ctrltee), "audio/x-raw-float, width=64, channels=1, endianness=1234, rate=%d" % pumuimchainsr)
	pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = int(pumuimdelay), fir_matrix = [pumuimfilt[::-1]], time_domain = td)
	pumuim = calibration_parts.mkresample(pipeline, pumuim, ctrlcorrcaps)

if options.apply_kappatst:
	# Only apply the real part of \kappa_tst as a correction to A_tst
	ktst_for_tst = calibration_parts.mkqueue(pipeline, ktstRtee)
	ktst_for_tst = calibration_parts.mkresample(pipeline, ktst_for_tst, ctrlcorrcaps)
	tst = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, ktst_for_tst, tst), ctrlcorrcaps)
	tst = pipeparts.mkaudioconvert(pipeline, tst)
	tst = pipeparts.mkcapsfilter(pipeline, tst, ctrlcorrcaps)
if options.apply_kappapu:
	# Only apply the real part of \kappa_pu as a correction to A_pu
	kpu_for_pu = calibration_parts.mkqueue(pipeline, kpuRtee)
	kpu_for_pu = calibration_parts.mkresample(pipeline, kpu_for_pu, ctrlcorrcaps)
	pumuim = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, kpu_for_pu, pumuim), ctrlcorrcaps)
	pumuim = pipeparts.mkaudioconvert(pipeline, pumuim)
	pumuim = pipeparts.mkcapsfilter(pipeline, pumuim, ctrlcorrcaps)

ctrl = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, tst, pumuim), ctrlcorrcaps)
#ctrl = pipeparts.mkaudioconvert(pipeline, ctrl)
#ctrl = pipeparts.mkcapsfilter(pipeline, ctrl, ctrlcorrcaps)
if options.partial_calibration:
	ctrl = pipeparts.mkfirbank(pipeline, ctrl, latency = int(ctrlcorrdelay), fir_matrix = [ctrlcorrfilt[::-1]], time_domain = td)
	if not options.different_control_whitening:
		ctrl = calibration_parts.mkresample(pipeline, ctrl, "audio/x-raw-float, width=64, channels=1, endianness=1234, rate=%d" % pumuimdewhitensr) 
		ctrl = pipeparts.mkfirbank(pipeline, ctrl, latency = int(pumuimdewhitendelay), fir_matrix = [pumuimdewhiten[::-1]], time_domain = td)

ctrl = calibration_parts.mkresample(pipeline, ctrl, caps)

#
# RESIDUAL BRANCH
#

res = calibration_parts.caps_and_progress(pipeline, head_dict["res"], caps, "res")
res = pipeparts.mkfirbank(pipeline, res, fir_matrix = [[0,1]]) # FIXME: Not sure why this is needed... test more without it or debug the underlying issue.

# Apply factors to actuation and sensing chains, if applicable
if options.apply_kappac:
	kc_modify_res = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, kctee), "audio/x-raw-float, width=64, channels=1, endianness=1234, rate=%d" % sr)
	res = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, res, pipeparts.mkpow(pipeline, kc_modify_res, exponent = -1.0)), "audio/x-raw-float, width=64, rate=%d, channels=1, endianness=1234" % sr)
	res = pipeparts.mkaudioconvert(pipeline, res)
	res = pipeparts.mkcapsfilter(pipeline, res, "audio/x-raw-float, width=64, rate=%d, channels=1, endianness=1234" % sr)

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank
res = pipeparts.mkfirbank(pipeline, res, latency = int(reschaindelay), fir_matrix = [reschainfilt[::-1]], time_domain = td)
res = pipeparts.mkfirbank(pipeline, res, latency = int(resdewhitendelay), fir_matrix = [resdewhiten[::-1]], time_domain = td)
		
#
# CONTROL + RESIDUAL = H(T)
#

# Add control and residual chains and divide by L to make h(t)
strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, res, ctrl), caps)
# Divide by L in a way that is compatitble with old and new filters files, since old filter files don't recored "arm length"
try:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/float(filters["arm_length"]))
except KeyError:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/3994.5)
#strain = calibration_parts.mkaudiorate(pipeline, strain)
strain = pipeparts.mkprogressreport(pipeline, strain, "progress_hoft_%s" % instrument)
	
# Put the units back to strain before writing to frames
straintee = pipeparts.mktee(pipeline, strain)
straintagstr = "units=strain,channel-name=%sCALIB_STRAIN%s,instrument=%s" % (chan_prefix, chan_suffix, instrument)
strain = pipeparts.mktaginject(pipeline, calibration_parts.mkqueue(pipeline, straintee), straintagstr)

#
# GDS-CALIB_STATE_VECTOR BRANCH
#

if not options.no_dq_vector:
	odcstatevector = calibration_parts.mkaudiorate(pipeline, odcstatevector)
	odctagstr = "channel-name=%s:%s, instrument=%s" % (instrument, options.dq_channel_name, instrument)
	odcstatevector = pipeparts.mktaginject(pipeline, odcstatevector, odctagstr)
	odcstatevector = pipeparts.mkprogressreport(pipeline, odcstatevector, "progress_odc_%s" % instrument)
	odcstatevectortee = pipeparts.mktee(pipeline, odcstatevector)

	#
	# GAP BIT BRANCH
	#	

	nogap = pipeparts.mkbitvectorgen(pipeline, calibration_parts.mkqueue(pipeline, odcgaptee), nongap_is_control = True, bit_vector = 16384) 
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, rate=%d, endianness=1234" % odcsr)
	nogap = calibration_parts.mkaudiorate(pipeline, nogap)
	nogap = pipeparts.mkgeneric(pipeline, nogap, "lal_logical_undersampler", required_on = 16384, status_out = 16384)
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, "audio/x-raw-int, rate=%d, width=32, depth=32, signed=false, channels=1, endianness=1234" % dqsr)

	# 
	# SCIENCE-INTENT BIT BRANCH
	#

	scienceintent = calibration_parts.mkqueue(pipeline, odcstatevectortee)
	scienceintent = pipeparts.mkgeneric(pipeline, scienceintent, "lal_logical_undersampler", required_on = options.science_intent_bitmask, status_out = 2)
	scienceintent = pipeparts.mkcapsfilter(pipeline, scienceintent, "audio/x-raw-int, width=32, depth=32, endianness=1234, channels=1, signed=false, rate=%d" % dqsr)
	#scienceintent = calibration_parts.mkaudiorate(pipeline, scienceintent)
	scienceintenttee = pipeparts.mktee(pipeline, scienceintent)	

	#
	# SCIENCE-QUALITY BIT BRANCH
	#

	sciencequality = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, odcstatevectortee), "lal_logical_undersampler", required_on = options.science_quality_bitmask, status_out = 4)
	sciencequality = pipeparts.mkcapsfilter(pipeline, sciencequality, "audio/x-raw-int, width=32, depth=32, channels=1, endianness=1234, signed=false, rate=%d" % dqsr)
	#sciencequality = calibration_parts.mkaudiorate(pipeline, sciencequality)
	sciencequalitytee = pipeparts.mktee(pipeline, sciencequality)
	
	#
	# H(t)-PRODUCED BIT BRANCH
	#

	htproduced = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, straintee), control = calibration_parts.mkqueue(pipeline, straintee), threshold = 0)
	htproduced = pipeparts.mkbitvectorgen(pipeline, htproduced, bit_vector = 8, nongap_is_control = True)
	htproduced = pipeparts.mkcapsfilter(pipeline, htproduced, "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, rate=%d, endianness=1234" % sr)
	htproduced = pipeparts.mkgeneric(pipeline, htproduced, "lal_logical_undersampler", required_on = 8, status_out = 8)
	htproduced = pipeparts.mkcapsfilter(pipeline, htproduced, "audio/x-raw-int, rate=%d, width=32, depth=32, signed=false, channels=1, endianness=1234" % dqsr)
	#htproduced = calibration_parts.mkaudiorate(pipeline, htproduced)

	#
	# FILTERS-OK BIT BRANCH
	#
	
	# Set the FILTERS-OK bit based on science-quality transitions
	filtersok = pipeparts.mkbitvectorgen(pipeline, calibration_parts.mkqueue(pipeline, scienceintenttee), bit_vector=16, threshold=2)
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, "audio/x-raw-int, width=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)
	#filtersok = calibration_parts.mkaudiorate(pipeline, filtersok)
	filtersok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, filtersok), control = calibration_parts.mkqueue(pipeline, scienceintenttee), threshold = 2, attack_length = -int(options.filter_settle_time) * dqsr)
	filtersok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, filtersok), control = calibration_parts.mkqueue(pipeline, sciencequalitytee), threshold = 4, attack_length = -int(options.filter_settle_time) * dqsr)

	# If we are computing any \kappas, set up a statevector to use for gating them against the start of science mode
	if not options.no_kappaa or not options.no_kappac or not options.no_kappatst or not options.no_kappapu or not options.no_fcc:	
		averageok = pipeparts.mkbitvectorgen(pipeline, calibration_parts.mkqueue(pipeline, sciencequalitytee), bit_vector=1, threshold=4)
		averageok = pipeparts.mkcapsfilter(pipeline, averageok, "audio/x-raw-int, wdith=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)
		#averageok = calibration_parts.mkaudiorate(pipeline, averageok)
		averageok = pipeparts.mktee(pipeline, averageok)

	#
	# KAPPAA-OK BIT BRANCH
	#
	if not options.no_kappaa:
		kaIdq = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, kaIteedq), "audio/x-raw-float, rate=%d, width=64, channels=1, endianness=1234" % dqsr)
		kaIdq = pipeparts.mkgeneric(pipeline, kaIdq, "lal_add_constant", constant = -options.expected_kappaa_imag)
		kaRdq = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, kaRteedq), "audio/x-raw-float, width=64, channels=1, endianness=1234, rate=%d" % dqsr)
		kaRdq = pipeparts.mkgeneric(pipeline, kaRdq, "lal_add_constant", constant = -options.expected_kappaa_real)
		
		kaok = pipeparts.mkbitvectorgen(pipeline, kaRdq, threshold = options.kappaa_real_ok_var, invert_control = True, bit_vector = 512)
		kaok = pipeparts.mkcapsfilter(pipeline, kaok, "audio/x-raw-int, depth=32, width=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)
		#kaok = calibration_parts.mkaudiorate(pipeline, kaok)
		kaok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, kaok), threshold = options.kappaa_imag_ok_var, invert_control = True, control = calibration_parts.mkqueue(pipeline, kaIdq))
		kaok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, kaok), threshold = 1, control = calibration_parts.mkqueue(pipeline, averageok), attack_length = -int(options.factors_averaging_time) * dqsr)
		kaok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, kaok), threshold = 1, control = calibration_parts.mkqueue(pipeline, kaRInRange))
		kaok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, kaok), threshold = 1, control = calibration_parts.mkqueue(pipeline, kaIInRange))
		kaok = pipeparts.mkcapsfilter(pipeline, kaok, "audio/x-raw-int, depth=32, width=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)

	#
	# KAPPAPU-OK BIT BRANCH
	#
	if not options.no_kappapu:
		kpuIdq = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, kpuIteedq), "audio/x-raw-float, rate=%d, width=64, channels=1, endianness=1234" % dqsr)
		kpuIdq = pipeparts.mkgeneric(pipeline, kpuIdq, "lal_add_constant", constant = -options.expected_kappapu_imag)
		kpuRdq = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, kpuRteedq), "audio/x-raw-float, width=64, channels=1, endianness=1234, rate=%d" % dqsr)
		kpuRdq = pipeparts.mkgeneric(pipeline, kpuRdq, "lal_add_constant", constant = -options.expected_kappapu_real)
		
		kpuok = pipeparts.mkbitvectorgen(pipeline, kpuRdq, threshold = options.kappapu_real_ok_var, invert_control = True, bit_vector = 1024)
		kpuok = pipeparts.mkcapsfilter(pipeline, kpuok, "audio/x-raw-int, depth=32, width=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)
		#kpuok = calibration_parts.mkaudiorate(pipeline, kpuok)
		kpuok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, kpuok), threshold = options.kappapu_imag_ok_var, invert_control = True, control = calibration_parts.mkqueue(pipeline, kpuIdq))
		kpuok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, kpuok), threshold = 1, control = calibration_parts.mkqueue(pipeline, averageok), attack_length = -int(options.factors_averaging_time) * dqsr)
		kpuok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, kpuok), threshold = 1, control = calibration_parts.mkqueue(pipeline, kpuRInRange))
		kpuok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, kpuok), threshold = 1, control = calibration_parts.mkqueue(pipeline, kpuIInRange))
		kpuok = pipeparts.mkcapsfilter(pipeline, kpuok, "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)

	#
	# KAPPATST-OK BIT BRANCH
	#
	if not options.no_kappatst:
		ktstIdq = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, ktstIteedq), "audio/x-raw-float, rate=%d, width=64, channels=1, endianness=1234" % dqsr)
		ktstIdq = pipeparts.mkgeneric(pipeline, ktstIdq, "lal_add_constant", constant = -options.expected_kappatst_imag)
		ktstRdq = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, ktstRteedq), "audio/x-raw-float, rate=%d, width=64, channels=1, endianness=1234" % dqsr)
		ktstRdq = pipeparts.mkgeneric(pipeline, ktstRdq, "lal_add_constant", constant = -options.expected_kappatst_real)
		
		ktstok = pipeparts.mkbitvectorgen(pipeline, ktstRdq, threshold = options.kappatst_real_ok_var, invert_control = True, bit_vector = 2048)
		ktstok = pipeparts.mkcapsfilter(pipeline, ktstok, "audio/x-raw-int, depth=32, width=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)
		#ktstok = calibration_parts.mkaudiorate(pipeline, ktstok)
		ktstok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, ktstok), threshold = options.kappatst_imag_ok_var, invert_control = True, control = calibration_parts.mkqueue(pipeline, ktstIdq)) 
		ktstok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, ktstok), threshold = 1, control = calibration_parts.mkqueue(pipeline, averageok), attack_length = -int(options.factors_averaging_time) * dqsr)
		ktstok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, ktstok), threshold = 1, control = calibration_parts.mkqueue(pipeline, ktstRInRange))
		ktstok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, ktstok), threshold = 1, control = calibration_parts.mkqueue(pipeline, ktstIInRange))
		ktstok = pipeparts.mkcapsfilter(pipeline, ktstok, "audio/x-raw-int, depth=32, width=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)

	#
	# KAPPAC-OK BIT BRANCH
	#
	if not options.no_kappac:
		kcdq = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, kcteedq), "audio/x-raw-float, rate=%d, width=64, endianness=1234, channels=1" % dqsr)
		kcdq = pipeparts.mkgeneric(pipeline, kcdq, "lal_add_constant", constant = -options.expected_kappac)
		
		kcok = pipeparts.mkbitvectorgen(pipeline, kcdq, threshold = options.kappac_ok_var, invert_control = True, bit_vector = 4096)
		kcok = pipeparts.mkcapsfilter(pipeline, kcok, "audio/x-raw-int, depth=32, width=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)
		#kcok = calibration_parts.mkaudiorate(pipeline, kcok)
		kcok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, kcok), threshold = 1, control = calibration_parts.mkqueue(pipeline, averageok), attack_length = -int(options.factors_averaging_time) * dqsr)
		kcok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, kcok), threshold = 1, control = calibration_parts.mkqueue(pipeline, kcInRange))

	#
	# FCC-OK BIT BRANCH
	#
	if not options.no_fcc:
		fccdq = calibration_parts.mkresample(pipeline, calibration_parts.mkqueue(pipeline, fccteedq), "audio/x-raw-float, rate=%d, width=64, channels=1, endianness=1234" % dqsr)
		fccdq = pipeparts.mkgeneric(pipeline, fccdq, "lal_add_constant", constant = -options.expected_fcc)
		
		fccok = pipeparts.mkbitvectorgen(pipeline, fccdq, threshold = options.fcc_ok_var, invert_control = True, bit_vector = 8192)
		fccok = pipeparts.mkcapsfilter(pipeline, fccok, "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)
		#fccok = calibration_parts.mkaudiorate(pipeline, fccok)
		fccok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, fccok), threshold = 1, control = calibration_parts.mkqueue(pipeline, averageok), attack_length = -int(options.factors_averaging_time) * dqsr)
		fccok = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, fccok), threshold = 1, control = calibration_parts.mkqueue(pipeline, fccInRange))
		
	#
	# H(T)-OK BIT BRANCH
	#
	
	# First combine higher order bits to determine h(t)-OK
	higherbits = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, filtersok, htproduced, sciencequalitytee), "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, endianness=1234, rate=%d" % dqsr)
	higherbitstee = pipeparts.mktee(pipeline, higherbits)

	# Now calculate h(t)-OK bit
	htok = pipeparts.mkbitvectorgen(pipeline, calibration_parts.mkqueue(pipeline, higherbitstee), bit_vector = 1, threshold = 28)
	htok = pipeparts.mkcapsfilter(pipeline, htok, "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, rate=%d, endianness=1234" % dqsr)
	#htok = calibration_parts.mkaudiorate(pipeline, htok)

	#
	# HW INJECTION BITS
	#	

	hwinjcbc = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, odcstatevectortee), "lal_logical_undersampler", required_on = int(options.hw_inj_cbc_bitmask), status_out = 64)
	hwinjcbc = pipeparts.mkcapsfilter(pipeline, hwinjcbc, "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, endianness=1234, rate=%d" % dqsr)
	#hwinjcbc = calibration_parts.mkaudiorate(pipeline, hwinjcbc)

	hwinjburst = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, odcstatevectortee), "lal_logical_undersampler", required_on = int(options.hw_inj_burst_bitmask), status_out = 128)
	hwinjburst = pipeparts.mkcapsfilter(pipeline, hwinjburst, "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, endianness=1234, rate=%d" % dqsr)
	#hwinjburst = calibration_parts.mkaudiorate(pipeline, hwinjburst)

	hwinjdetchar = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, odcstatevectortee), "lal_logical_undersampler", required_on = int(options.hw_inj_detchar_bitmask), status_out = 256)
	hwinjdetchar = pipeparts.mkcapsfilter(pipeline, hwinjdetchar, "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, endianness=1234, rate=%d" % dqsr)
	#hwinjdetchar = calibration_parts.mkaudiorate(pipeline, hwinjdetchar)

	hwinjstoch = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, odcstatevectortee), "lal_logical_undersampler", required_on = int(options.hw_inj_stoch_bitmask), status_out = 32)
	hwinjstoch = pipeparts.mkcapsfilter(pipeline, hwinjstoch, "audio/x-raw-int, width=32, depth=32, signed=false, channels=1, endianness=1234, rate=%d" % dqsr)
	#hwinjstoch = calibration_parts.mkaudiorate(pipeline, hwinjstoch)


	#
	# COMBINE ALL BITS TO MAKE GDS-CALIB_STATE_VECTOR
	#

	dqcaps = "audio/x-raw-int, rate=%d, width=32, depth=32, signed=false, channels=1, endianness=1234" % dqsr
	calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, nogap, higherbitstee, scienceintenttee, htok, hwinjcbc, hwinjburst, hwinjdetchar, hwinjstoch), dqcaps)
	if not options.no_kappaa:
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kaok), dqcaps)
	if not options.no_kappatst:
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, ktstok), dqcaps)
	if not options.no_kappapu:
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kpuok), dqcaps)
	if not options.no_kappac:
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, kcok), dqcaps)
	if not options.no_fcc:
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, fccok), dqcaps)

	calibstatevector = pipeparts.mkprogressreport(pipeline, calibstatevector, "progress_calibstatevec_%s" % instrument)
	dqtagstr = "channel-name=%s:GDS-CALIB_STATE_VECTOR, instrument=%s" % (instrument, instrument)
	calibstatevector = pipeparts.mktaginject(pipeline, calibstatevector, dqtagstr)
	calibstatevector = calibration_parts.mkaudiorate(pipeline, calibstatevector)

# Resample the \kappa_a channels at the specified recording sample rate and change them to single precision channels
if not options.no_kappaa:
	kaRout = pipeparts.mkaudioconvert(pipeline, kaRout)
	kaRout = pipeparts.mkcapsfilter(pipeline, kaRout, "audio/x-raw-float, channels=1, endianness=1234, width=32, rate=%d" % options.compute_factors_sr)
	kaRout = calibration_parts.mkresample(pipeline, kaRout, "audio/x-raw-float, channels=1, endianness=1234, width=32, rate=%d" % options.record_factors_sr)
	kaIout = pipeparts.mkaudioconvert(pipeline, kaIout)
	kaIout = pipeparts.mkcapsfilter(pipeline, kaIout, "audio/x-raw-float, channels=1, endianness=1234, width=32, rate=%d" % options.compute_factors_sr)
	kaIout = calibration_parts.mkresample(pipeline, kaIout, "audio/x-raw-float, width=32, endianness=1234, channels=1, rate=%d" % options.record_factors_sr)

# Resample the \kappa_pu channels at the specified recording sample rate and change them to single precision channels
if not options.no_kappapu:
	kpuRout = pipeparts.mkaudioconvert(pipeline, kpuRout)
	kpuRout = pipeparts.mkcapsfilter(pipeline, kpuRout, "audio/x-raw-float, channels=1, endianness=1234, width=32, rate=%d" % options.compute_factors_sr)
	kpuRout = calibration_parts.mkresample(pipeline, kpuRout, "audio/x-raw-float, width=32, channels=1, endianness=1234, rate=%d" % options.record_factors_sr)
	kpuIout = pipeparts.mkaudioconvert(pipeline, kpuIout)
	kpuIout = pipeparts.mkcapsfilter(pipeline, kpuIout, "audio/x-raw-float, width=32, channels=1, endianness=1234, rate=%d" % options.compute_factors_sr)
	kpuIout = calibration_parts.mkresample(pipeline, kpuIout, "audio/x-raw-float, width=32, channels=1, endianness=1234, rate=%d" % options.record_factors_sr)

# Resample the \kappa_tst channels at the specified recording sample rate and change them to single precision channels
if not options.no_kappatst:
	ktstRout = pipeparts.mkaudioconvert(pipeline, ktstRout)
	ktstRout = pipeparts.mkcapsfilter(pipeline, ktstRout, "audio/x-raw-float, channels=1, endianness=1234, width=32, rate=%d" % options.compute_factors_sr)
	ktstRout = calibration_parts.mkresample(pipeline, ktstRout, "audio/x-raw-float, width=32, channels=1, endianness=1234, rate=%d" % options.record_factors_sr)
	ktstIout = pipeparts.mkaudioconvert(pipeline, ktstIout)
	ktstIout = pipeparts.mkcapsfilter(pipeline, ktstIout, "audio/x-raw-float, channels=1, endianness=1234, width=32, rate=%d" % options.compute_factors_sr)
	ktstIout = calibration_parts.mkresample(pipeline, ktstIout, "audio/x-raw-float, width=32, channels=1, endianness=1234, rate=%d" % options.record_factors_sr)

# Resample the \kappa_c channel at the specified recording sample rate and change it to a single precision channel
if not options.no_kappac:
	kcout = pipeparts.mkaudioconvert(pipeline, kcout)
	kcout = pipeparts.mkcapsfilter(pipeline, kcout, "audio/x-raw-float, width=32, channels=1, endianness=1234, rate=%d" % options.compute_factors_sr)
	kcout = calibration_parts.mkresample(pipeline, kcout, "audio/x-raw-float, width=32, channels=1, endianness=1234, rate=%d" % options.record_factors_sr)

# Resample the f_cc channel at the specified recording sample rate and change it to a single precision channel
if not options.no_fcc:
	fccout = pipeparts.mkaudioconvert(pipeline, fccout)
	fccout = pipeparts.mkcapsfilter(pipeline, fccout, "audio/x-raw-float, width=32, channels=1, endianness=1234, rate=%d" % options.compute_factors_sr)
	fccout = calibration_parts.mkresample(pipeline, fccout, "audio/x-raw-float, width=32, channels=1, endianness=1234, rate=%d" % options.record_factors_sr)

# Gate the strain channel with all of the channels we want in frames
if not options.no_dq_vector:
	strain, calibstatevector = calibration_parts.gate_strain_for_output_frames(pipeline, strain, calibstatevector)
	strain, odcstatevectorout = calibration_parts.gate_strain_for_output_frames(pipeline, strain, odcstatevectortee)
if not options.no_kappatst:
	strain, ktstRout = calibration_parts.gate_strain_for_output_frames(pipeline, strain, ktstRout)
	strain, ktstIout = calibration_parts.gate_strain_for_output_frames(pipeline, strain, ktstIout)
if not options.no_kappapu:
	strain, kpuRout = calibration_parts.gate_strain_for_output_frames(pipeline, strain, kpuRout)
	strain, kpuIout = calibration_parts.gate_strain_for_output_frames(pipeline, strain, kpuIout)
if not options.no_kappaa:
	strain, kaRout = calibration_parts.gate_strain_for_output_frames(pipeline, strain, kaRout)
	strain, kaIout = calibration_parts.gate_strain_for_output_frames(pipeline, strain, kaIout)
if not options.no_kappac:
	strain, kcout = calibration_parts.gate_strain_for_output_frames(pipeline, strain, kcout)
if not options.no_fcc:
	strain, fccout = calibration_parts.gate_strain_for_output_frames(pipeline, strain, fccout)

# Gate everything with the strain channel so that no frames get written without a strain channel or any other channel already gated with the strain channel
straintee = pipeparts.mktee(pipeline, strain)
if not options.no_dq_vector:
	calibstatevector = calibration_parts.gate_other_with_strain(pipeline, calibstatevector, straintee)
	odcstatevectorout = calibration_parts.gate_other_with_strain(pipeline, odcstatevectorout, straintee)
if not options.no_kappatst:
	ktstRout = calibration_parts.gate_other_with_strain(pipeline, ktstRout, straintee)
	ktstIout = calibration_parts.gate_other_with_strain(pipeline, ktstIout, straintee)
if not options.no_kappapu:
	kpuRout = calibration_parts.gate_other_with_strain(pipeline, kpuRout, straintee)
	kpuIout = calibration_parts.gate_other_with_strain(pipeline, kpuIout, straintee)
if not options.no_kappaa:
	kaRout = calibration_parts.gate_other_with_strain(pipeline, kaRout, straintee)
	kaIout = calibration_parts.gate_other_with_strain(pipeline, kaIout, straintee)
if not options.no_kappac:
	kcout = calibration_parts.gate_other_with_strain(pipeline, kcout, straintee)
if not options.no_fcc:
	fccout = calibration_parts.gate_other_with_strain(pipeline, fccout, straintee)
	
# If the calibration factors are bad and we are NOT in science mode, set the strain channel to a gap. This is to avoid issues with reproducibility of the pipeline.  Note: If the calibration factors are bad for an extended period of time and we ARE in science mode, there will be problems.  I'm not fixing this on purpose.
strain = calibration_parts.mkqueue(pipeline, straintee)
if not options.no_dq_vector and (options.apply_kappatst or options.apply_kappac or options.apply_kappapu):
	calibstatevectortee = pipeparts.mktee(pipeline, calibstatevector)
	if options.apply_kappatst:
		ktstbadstate = pipeparts.mkstatevector(pipeline, calibration_parts.mkqueue(pipeline, calibstatevectortee), required_off = 2052)
		strain = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, strain), control = calibration_parts.mkqueue(pipeline, ktstbadstate), threshold = 1, invert_control = True)
	if options.apply_kappac:
		kcbadstate = pipeparts.mkstatevector(pipeline, calibration_parts.mkqueue(pipeline, calibstatevectortee), required_off = 4100)
		strain = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, strain), control = calibration_parts.mkqueue(pipeline, kcbadstate), threshold = 1, invert_control = True)
	if options.apply_kappapu:
		kpubadstate = pipeparts.mkstatevector(pipeline, calibration_parts.mkqueue(pipeline, calibstatevectortee), required_off = 1028)
		strain = pipeparts.mkgate(pipeline, calibration_parts.mkqueue(pipeline, strain), control = calibration_parts.mkqueue(pipeline, kpubadstate), threshold = 1, invert_control = True)
	calibstatevector = calibration_parts.mkqueue(pipeline, calibstatevectortee)
	strain = pipeparts.mkfirbank(pipeline, strain, fir_matrix = [[0,1]])
	strain = calibration_parts.mkaudiorate(pipeline, strain)

#
# CREATE MUXER AND HOOK EVERYTHING UP TO IT
#

mux = pipeparts.mkframecppchannelmux(pipeline, None)

if options.frame_duration is not None:
        mux.set_property("frame-duration", options.frame_duration)
if options.frames_per_file is not None:
        mux.set_property("frames-per-file", options.frames_per_file)
mux.set_property("compression-scheme", options.compression_scheme)
mux.set_property("compression-level", options.compression_level)

# Link the output DQ vectors up to the muxer, if applicable
if not options.no_dq_vector:
	calibration_parts.mkqueue(pipeline, calibstatevector).get_pad("src").link(mux.get_pad("%s:%sCALIB_STATE_VECTOR%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, odcstatevectorout).get_pad("src").link(mux.get_pad("%s:%s" % (instrument, options.dq_channel_name)))

# Link the strain branch to the muxer
strain.get_pad("src").link(mux.get_pad("%s:%sCALIB_STRAIN%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of \kappa_a to the muxer
if not options.no_kappaa:
	calibration_parts.mkqueue(pipeline, kaRout).get_pad("src").link(mux.get_pad("%s:%sCALIB_KAPPA_A_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, kaIout).get_pad("src").link(mux.get_pad("%s:%sCALIB_KAPPA_A_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of \kappa_tst to the muxer
if not options.no_kappatst:
	calibration_parts.mkqueue(pipeline, ktstRout).get_pad("src").link(mux.get_pad("%s:%sCALIB_KAPPA_TST_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, ktstIout).get_pad("src").link(mux.get_pad("%s:%sCALIB_KAPPA_TST_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))

# Link the real and imaginary parts of \kappa_pu to the muxer
if not options.no_kappapu:
	calibration_parts.mkqueue(pipeline, kpuRout).get_pad("src").link(mux.get_pad("%s:%sCALIB_KAPPA_PU_REAL%s" % (instrument, chan_prefix, chan_suffix)))
	calibration_parts.mkqueue(pipeline, kpuIout).get_pad("src").link(mux.get_pad("%s:%sCALIB_KAPPA_PU_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)))

# Link the \kappa_c to the muxer
if not options.no_kappac:
	calibration_parts.mkqueue(pipeline, kcout).get_pad("src").link(mux.get_pad("%s:%sCALIB_KAPPA_C%s" % (instrument, chan_prefix, chan_suffix)))

# Link the f_cc to the muxer
if not options.no_fcc:
	calibration_parts.mkqueue(pipeline, fccout).get_pad("src").link(mux.get_pad("%s:%sCALIB_F_CC%s" % (instrument, chan_prefix, chan_suffix)))

if options.wings is not None:
	def clip_wings(pad, obj, (wings, start, end)):
		if isinstance(obj, gst.Buffer):
			startts = lal.LIGOTimeGPS(0, obj.timestamp)
			if startts >= (start + wings) and startts < (end - wings):
				return True
			elif startts < (start + wings) or startts >= (end - wings):
				return False
		elif isinstance(obj, gst.Event):
			return True
	mux.get_pad("src").add_data_probe(clip_wings, (lal.LIGOTimeGPS(options.wings, 0), lal.LIGOTimeGPS(int(options.gps_start_time), 0), lal.LIGOTimeGPS(int(options.gps_end_time), 0)))

def no_short_frames(pad, obj, (frame_duration)):
	if isinstance(obj, gst.Buffer):
		duration = lal.LIGOTimeGPS(0, obj.duration)
		if duration != frame_duration:
			return False
		else:
			return True
	elif isinstance(obj, gst.Event):
		return True
mux.get_pad("src").add_data_probe(no_short_frames, (lal.LIGOTimeGPS(options.frame_duration * options.frames_per_file, 0)))

mux = pipeparts.mkprogressreport(pipeline, mux, "progress_sink_%s" % instrument)

if options.write_to_shm_partition is not None:
	lvshmsink = gst.element_factory_make("gds_lvshmsink")
	lvshmsink.set_property("sync", False)
	lvshmsink.set_property("async", False)
	lvshmsink.set_property("shm-name", options.write_to_shm_partition)
	lvshmsink.set_property("num-buffers", 10)
	lvshmsink.set_property("blocksize", options.frame_size * options.frame_duration * options.frames_per_file)
	lvshmsink.set_property("buffer-mode", options.buffer_mode)
	pipeline.add(lvshmsink)
	mux.link(lvshmsink)
else:
	pipeparts.mkframecppfilesink(pipeline, mux, frame_type = options.frame_type, path = options.output_path, instrument = instrument) 

# Run pipeline

if options.write_pipeline is not None:
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(options.write_pipeline, "NULL"), verbose = options.verbose)

# Seek the pipeline when necessary.  Note: The seekevent for frames is set above when command line is being parsed/sanity checked.
if options.data_source == "frames":
	datasource.do_seek(pipeline, seekevent)	
	print >>sys.stderr, "seeking GPS start and stop times ..."

if options.verbose:
	print >>sys.stderr, "setting pipeline state to playing ..."
if pipeline.set_state(gst.STATE_PLAYING) == gst.STATE_CHANGE_FAILURE:
	raise RuntimeError("pipeline failed to enter PLAYING state")
else:
	print "set to playing successfully"
if options.write_pipeline is not None:
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(options.write_pipeline, "PLAYING"), verbose = options.verbose)
	
if options.verbose:
	print >>sys.stderr, "running pipeline ..."

mainloop.run()
