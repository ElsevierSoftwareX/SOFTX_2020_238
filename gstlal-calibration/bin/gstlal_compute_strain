#!/usr/bin/env python
#
# Copyright (C) 2010-2015  Jordi Burguet-Castell, Madeline Wade, Aaron Viets
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


"""
This pipeline produces h(t) given DARM_ERR and DARM_CTRL or given DELTAL_RESIDUAL and DELTAL_CTRL. It can be run online in real-time or offline on frame files.  It can write h(t) frames to frame files or to a shared memory partition.

The differential arm length resulting from external sources is						

\Delta L_{ext} = ((f^2 + f_s^2 - i * f * f_s / Q) / f^2)							
* ((1 + i * f / f_cc) / (\kappa_c C_res)) * d_{err}							     
+ (A_tst * \kappa_tst + A_pu * \kappa_pu) * d_{ctrl}							    

where C is the static portion of the sensing function, A_tst is the TST actuation function, A_pu is the PUM+UIM actuation, \kappa_c is the time-dependent gain of the sensing function, \kappa_tst is the time-dependent gain of TST actuation, and \kappa_pu is the time-dependent gain of the PUM/UIM actuation.  \Delta L_{ext} is divided by the average arm length (4000 m) to obtain h(t), the external strain in the detectors,												

h(t) = \Delta L_{ext} / L .										  

The time-dependent gains (\kappa's) as well as the value for the coupled cavity pole f_cc and SRC detuning parameters f_s and Q are calcuated in this pipeline as well.

This pipeline will most often be run in a format where it picks up after part of the actuation and sensing functions have been applied to the appropriate channels.  In this mode, the input channels are \Delta L_{res} and \Delta L_{ctrl, i}.  This pipeline then applies further high frequency corrections to each of these channels, applies the appropriate time delay to each channel, adds the channels together, and divides by L.											

h(t) = (((f^2 + f_s^2 - i * f * f_s / Q) / f^2)							     
* ((1 + i * f / f_cc) / \kappa_c) * corrections * \Delta L_{res}						    
+ \kappa_tst * \Delta L_{ctrl, TST}										 
+ \kappa_pu * (\Delta L_{ctrl, P} + \Delta L_{ctrl, U})) / L							

Note: The actuation \kappa's are complex numbers.  Only the real part of the computed \kappa's are applied as time-dependent gain corrections.

Further documentation explaining the time domain calibration procedure can be found in LIGO DCC #T1400256 and #P1700236.

For a full list of example command lines that were used to create the O1 h(t) frames, see https://wiki.ligo.org/Calibration/GDSCalibrationConfigurationsO1.
For a full list of example command lines that were used to create the O2 h(t) frames, see https://wiki.ligo.org/Calibration/GDSCalibrationConfigurationsO2.

Type gstlal_compute_strain --help to see the full list of command line options.
"""

from __future__ import print_function

import os
import sys
import numpy
import time
import resource

from optparse import OptionParser, Option
import ConfigParser

import gi
gi.require_version('Gst', '1.0')
from gi.repository import GObject, Gst
GObject.threads_init()
Gst.init(None)

import lal

from gstlal import pipeparts
from gstlal import calibration_parts
from gstlal import datasource
from gstlal import calibhandler
from gstlal import simplehandler

from ligo import segments

#
# Function definition for writing pipeline graph
#

def write_graph(demux):
	pipeparts.write_dump_dot(pipeline, "%s.%s" % (DebuggingConfigs["pipelinegraphfilename"], "PLAYING"), verbose = True)

#
# Make sure we have sufficient resources
# We allocate far more memory than we need, so this is okay
#

def setrlimit(res, lim):
	hard_lim = resource.getrlimit(res)[1]
	resource.setrlimit(res, (lim if lim is not None else hard_lim, hard_lim))
# set the number of processes and total set size up to hard limit and
# shrink the per-thread stack size (default is 10 MiB)
setrlimit(resource.RLIMIT_NPROC, None)
setrlimit(resource.RLIMIT_AS, None)
setrlimit(resource.RLIMIT_RSS, None)
setrlimit(resource.RLIMIT_STACK, 1024*1024)

#
# Function definition to obtain the current GPS time
#

def now():
	return lal.LIGOTimeGPS(lal.UTCToGPS(time.gmtime()), 0)
	
#
# Function definition to check a string to see if it is a number
#

def is_number(s):
	try:
		float(s)
		return True
	except ValueError:
		return False

#
# Function to update FIR matrix property
#

def fir_matrix_update(elem, arg, filtered):
	filtered.set_property("kernel", elem.get_property("fir_matrix")[0][::-1])
	print("fir matrix updated")

#############################################################################
##################### Program Command Line Options ##########################
#############################################################################

parser = OptionParser(description = __doc__)

# Append program specific options

# These options should be used whether the pipeline runs in full calibration mode or partial calibration mode
parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the start time of the segment to analyze in GPS seconds. This is required iff DataSource is frames")
parser.add_option("--gps-end-time", metavar = "seconds", help = "Set the end time of the segment to analyze in GPS seconds. This is required iff DataSource is =frames")
parser.add_option("--frame-cache", metavar = "filename", help = "Set the name of the LAL cache listing the LIGO .gwf frame files (optional).  This is required iff DataSource is frames")
parser.add_option("--output-path", metavar = "name", default = ".", help = "Set the output path for writing frame files. (Default=Current)")
parser.add_option("--wings", metavar = "seconds", default = 0, type = "int", help = "Number of seconds to trim off of the beginning and end of the output. Should only be used if DataSource is frames.")
parser.add_option("--frame-duration", metavar = "seconds", type = "int", default = 4, help = "Set the number of seconds for each frame. (Default = 4)")
parser.add_option("--frames-per-file", metavar = "count", type = "int", default = 1, help = "Set the number of frames per frame file. (Default = 1)")
parser.add_option("--config-file", metavar = "name", help = "Full path to configuration file for running.")

# Parse options
options, filenames = parser.parse_args()

#############################################################################
######################### Config File Options  ##############################
#############################################################################

def ConfigSectionMap(section):
	dict1 = {}
	options = Config.options(section)
	for option in options:
		try:
			dict1[option] = Config.get(section, option)
			if dict1[option] == -1:
				DebugPrint("skip: %s" % option)
		except:
			print("exception on %s!" % option)
			dict[option] = None
	return dict1

Config = ConfigParser.ConfigParser()
Config.read(options.config_file)

InputConfigs = ConfigSectionMap("InputConfigurations")
OutputConfigs = ConfigSectionMap("OutputConfigurations")
CalibrationConfigs = ConfigSectionMap("CalibrationConfigurations")
DebuggingConfigs = ConfigSectionMap("DebuggingConfigurations")
TDCFConfigs = ConfigSectionMap("TDCFConfigurations")
ChannelNames = ConfigSectionMap("ChannelNames")
SampleRates = ConfigSectionMap("SampleRates")
Bitmasks = ConfigSectionMap("Bitmasks")
PipelineConfigs = ConfigSectionMap("PipelineConfigurations")
DataCleaningConfigs = ConfigSectionMap("DataCleaningConfigurations")
try:
	MonitorConfigs = ConfigSectionMap("MonitoringConfigurations")
	kafka_server = MonitorConfigs["kafkaserver"]
except:
	kafka_server = None
try:
	latency_suffix = MonitorConfigs["latencysuffix"]
except:
	latency_suffix = None

# Sanity checks for command line options
data_sources = set(("frames", "lvshm"))

if InputConfigs["datasource"] not in data_sources:
	raise ValueError("DataSource must be one of %s" % ",".join(data_sources))

if InputConfigs["datasource"] == "frames" and options.frame_cache is None:
	raise ValueError("FrameCache must be specified when using DataSource: frames")

if int(options.wings != 0) and InputConfigs["datasource"] != "frames":
	raise ValueError("Wings can only be set when DataSource: frames")

if CalibrationConfigs["ifo"] is None:
	raise ValueError("must specify IFO")

if InputConfigs["datasource"] == "frames" and (options.gps_start_time is None or options.gps_end_time is None):
	raise ValueError("must specify --gps-start-time and --gps-end-time when DataSource: frames")

if (CalibrationConfigs["calibrationmode"] != "Full") and (CalibrationConfigs["calibrationmode"] != "Partial"):
	raise ValueError("must specify either Full or Partial for CalibrationMode")

if int(SampleRates["recordfactorssr"]) > int(SampleRates["computefactorssr"]):
	raise ValueError("RecordFactorsSR must be less than or equal to ComputeFactorsSR")

if (Config.getboolean("TDCFConfigurations", "applycomplexkappapum") or Config.getboolean("TDCFConfigurations", "applykappapum") or Config.getboolean("TDCFConfigurations", "applycomplexkappauim") or Config.getboolean("TDCFConfigurations", "applykappauim")) and (Config.getboolean("TDCFConfigurations", "applycomplexkappapu") or Config.getboolean("TDCFConfigurations", "applykappapu")):
	raise ValueError("Cannot apply any corrections for kappa_PU if corrections are already being applied for kappa_PUM or kappa_UIM")

if TDCFConfigs["factorsfromfiltersfile"] is "No" and (TDCFConfigs["computefs"] is "Yes" or TDCFConfigs["computesrcq"] is "Yes") and ((InputConfigs["datasource"] is "frames" and int(options.gps_start_time) < 1175954418)):
	raise ValueError("Cannot compute SRC detuning parameters as the needed EPICS channels are not in the frames until GPS time 1175954418. Set ComputeFs: No and ComputeSRCQ: No.")

if options.gps_start_time is not None:
	if options.gps_end_time is None:
		raise ValueError("must provide both --gps-start-time and --gps-end-time")
	if InputConfigs["datasource"] == "lvshm":
		raise ValueError("cannot set --gps-start-time or --gps-end-time with DataSource: lvshm")
	if int(options.gps_start_time) >= int(options.gps_end_time):
		raise ValueError("--gps-start-time must be < --gps-end-time: %s < %s" % (options.gps_start_time, options.gps_end_time))
elif options.gps_end_time is not None:
	raise ValueError("must provide both --gps-start-time and --gps-end-time")

###################################################################################################
######################################## Setup ####################################################
###################################################################################################

# Set up instrument and channel name info from command line options
instrument = CalibrationConfigs["ifo"]

if options.gps_start_time is not None and options.gps_end_time is not None:
	gps_start_time = int(options.gps_start_time)
	gps_end_time = int(options.gps_end_time)

if InputConfigs["datasource"] == "frames":
	start = gps_start_time
elif InputConfigs["datasource"] == "lvshm":
	tm = time.gmtime()
	start = int(lal.UTCToGPS(tm))

# Set up short-cut names for each of the sample rates used throughout the pipeline and establish caps string shortcuts
hoft_sr = int(SampleRates["hoftsr"]) # Sample rate for h(t)
calibstate_sr = int(SampleRates["calibstatesr"]) # Sample rate for the CALIB_STATE_VECTOR
obsintent_sr = int(SampleRates["obsintentsr"]) if "obsintentsr" in SampleRates else int(SampleRates["odcsr"]) # Sample rate of the ODC channel that is read in
lownoise_sr = int(SampleRates["lownoisesr"]) if "lownoisesr" in SampleRates else int(SampleRates["odcsr"])
filterclock_sr_list = SampleRates["filterclocksrlist"].split(';') if "filterclocksrlist" in SampleRates else [lownoise_sr]
hwinj_sr = int(SampleRates["hwinjsr"]) if "hwinjsr" in SampleRates else int(SampleRates["odcsr"])
ctrl_sr = int(SampleRates["ctrlsr"]) # Sample rate of the control channel (such as DARM_CTRL or DELTAL_CTRL)
tst_exc_sr = int(SampleRates["tstexcsr"])
pum_exc_sr = int(SampleRates["pumexcsr"])
uim_exc_sr = int(SampleRates["uimexcsr"])
coh_sr = int(SampleRates["cohsr"]) # Sample rate for the coherence uncertainty channels
epics_sr = int(SampleRates["epicsrefsr"]) # Sample rate for EPICS records used for TDCFs
compute_factors_sr = int(SampleRates["computefactorssr"]) # Sample rate for computing TDCFs
record_factors_sr = int(SampleRates["recordfactorssr"]) # Sample rate for recording TDCFs
metrics_sr = int(SampleRates["metricssr"])  if "metricssr" in SampleRates else 1 # Sample rate for recording metrics from pipeline
hoft_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % hoft_sr
ctrl_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % ctrl_sr
latency_metrics_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % metrics_sr
calibstate_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % calibstate_sr
calibstate_metrics_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % metrics_sr
obsintent_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % obsintent_sr
lownoise_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % lownoise_sr
filterclock_caps = []
for i in range(len(filterclock_sr_list)):
	filterclock_caps.append("audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % int(filterclock_sr_list[i]))
hwinj_caps = "audio/x-raw, format=U32LE, rate=%d, channel-mask=(bitmask)0x0" % hwinj_sr
coh_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % coh_sr
ref_factors_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0x0" % epics_sr
compute_calib_factors_caps = "audio/x-raw, format=F64LE, rate=%d, channel-mask=(bitmask)0X0" % compute_factors_sr
compute_calib_factors_complex_caps = "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % compute_factors_sr

# Short cut names for a few other items that appear numerous times
input_frame_duration = int(InputConfigs["inputframeduration"])
wait_time = float(InputConfigs["waittime"]) if ("waittime" in InputConfigs and InputConfigs["datasource"] == "lvshm") else 0.0
filter_latency_factor = float(PipelineConfigs["filterlatency"])
demodulation_filter_time = int(TDCFConfigs["demodulationfiltertime"])
coherence_unc_threshold = float(TDCFConfigs["coherenceuncthreshold"])
actuation_filter_update_time = float(TDCFConfigs["actuationfilterupdatetime"])
actuation_filter_averaging_time = float(TDCFConfigs["actuationfilteraveragingtime"])
actuation_filter_taper_length = int(TDCFConfigs["actuationfiltertaperlength"])
sensing_filter_update_time = float(TDCFConfigs["sensingfilterupdatetime"])
sensing_filter_averaging_time = float(TDCFConfigs["sensingfilteraveragingtime"])
sensing_filter_taper_length = int(TDCFConfigs["sensingfiltertaperlength"])
pcal_sign = float(TDCFConfigs["pcalsign"]) if "pcalsign" in TDCFConfigs else 1.0
cleaning_check_rms_time = float(DataCleaningConfigs["cleaningcheckrmstime"])
cleaning_check_range_low_min = float(DataCleaningConfigs["cleaningcheckrangelowmin"])
cleaning_check_range_low_max = float(DataCleaningConfigs["cleaningcheckrangelowmax"])
cleaning_check_range_mid_min = float(DataCleaningConfigs["cleaningcheckrangemidmin"])
cleaning_check_range_mid_max = float(DataCleaningConfigs["cleaningcheckrangemidmax"])
powerlines_tf_median_time = float(DataCleaningConfigs["powerlinestfmediantime"]) if "powerlinestfmediantime" in DataCleaningConfigs else 128.0
powerlines_tf_averaging_time = float(DataCleaningConfigs["powerlinestfaveragingtime"]) if "powerlinestfaveragingtime" in DataCleaningConfigs else 1.0
powerlines_freq_var = float(DataCleaningConfigs["powerlinesfreqvar"]) if "powerlinesfreqvar" in DataCleaningConfigs else 0.02
witness_channel_fft_time = float(DataCleaningConfigs["witnesschannelffttime"])
num_witness_ffts = int(DataCleaningConfigs["numwitnessffts"])
min_witness_ffts = int(DataCleaningConfigs["minwitnessffts"])
witness_fir_length = DataCleaningConfigs["witnessfirlength"].split(";")
witness_frequency_resolution = float(DataCleaningConfigs["witnessfrequencyresolution"])
witness_tf_update_time = float(DataCleaningConfigs["witnesstfupdatetime"])
critical_lock_loss_time = float(DataCleaningConfigs["criticallocklosstime"])
witness_filter_taper_time = float(DataCleaningConfigs["witnessfiltertapertime"])
witness_tf_time_shift = float(DataCleaningConfigs["witnesstftimeshift"]) if "witnesstftimeshift" in DataCleaningConfigs else 0.0
witness_tf_filename = DataCleaningConfigs["witnesstffilename"] if DataCleaningConfigs["witnesstffilename"] != "None" else None
strain_channel_transition_time = float(DataCleaningConfigs["strainchanneltransitiontime"]) if "strainchanneltransitiontime" in DataCleaningConfigs else 1.0

expected_kappatst_real = float(TDCFConfigs["expectedkappatstreal"])
expected_kappatst_imag = float(TDCFConfigs["expectedkappatstimag"])
expected_kappapu_real = float(TDCFConfigs["expectedkappapureal"])
expected_kappapu_imag = float(TDCFConfigs["expectedkappapuimag"])
expected_kappapum_real = float(TDCFConfigs["expectedkappapumreal"])
expected_kappapum_imag = float(TDCFConfigs["expectedkappapumimag"])
expected_kappauim_real = float(TDCFConfigs["expectedkappauimreal"])
expected_kappauim_imag = float(TDCFConfigs["expectedkappauimimag"])
expected_kappac = float(TDCFConfigs["expectedkappac"])
expected_fcc = float(TDCFConfigs["expectedfcc"]) if "expectedfcc" in TDCFConfigs else 0.0
# Note: fs and Q are handled later due to the fact that they are handled as complex values
kappatst_real_var = float(TDCFConfigs["kappatstrealvar"])
kappatst_imag_var = float(TDCFConfigs["kappatstimagvar"])
kappapu_real_var = float(TDCFConfigs["kappapurealvar"])
kappapu_imag_var = float(TDCFConfigs["kappapuimagvar"])
kappapum_real_var = float(TDCFConfigs["kappapumrealvar"])
kappapum_imag_var = float(TDCFConfigs["kappapumimagvar"])
kappauim_real_var = float(TDCFConfigs["kappauimrealvar"])
kappauim_imag_var = float(TDCFConfigs["kappauimimagvar"])
kappac_var = float(TDCFConfigs["kappacvar"])
fcc_var = float(TDCFConfigs["fccvar"])
fs_var = float(TDCFConfigs["fsvar"])
srcQinv_min = float(TDCFConfigs["srcqinvmin"])
srcQinv_max = float(TDCFConfigs["srcqinvmax"])

# Set up smoothing, averaging and integration sample sizes for kappa calulations
integration_samples = demodulation_filter_time * compute_factors_sr
factors_average_samples = int(TDCFConfigs["tdcfaveragingtime"]) * compute_factors_sr
median_smoothing_samples = int(TDCFConfigs["mediansmoothingtime"]) * compute_factors_sr
kappa_gate_attack_length = -integration_samples * (1.0 - filter_latency_factor)
kappa_gate_hold_length = -integration_samples * filter_latency_factor - (filter_latency_factor != 0) * int(TDCFConfigs["coherencetime"]) * compute_factors_sr

# Set up string for the channels suffix and prefix as provided by the user
if OutputConfigs["chansuffix"] != "None":
	chan_suffix = OutputConfigs["chansuffix"]
else:
	chan_suffix = ""
chan_prefix = OutputConfigs["chanprefix"]

# Set up shortcut variables for boolean options
# Booleans for TDCFs
compute_kappatst = Config.getboolean("TDCFConfigurations", "computekappatst")
compute_kappapu = Config.getboolean("TDCFConfigurations", "computekappapu")
compute_kappapum = Config.getboolean("TDCFConfigurations", "computekappapum")
compute_kappauim = Config.getboolean("TDCFConfigurations", "computekappauim")
compute_kappac = Config.getboolean("TDCFConfigurations", "computekappac")
compute_fcc = Config.getboolean("TDCFConfigurations", "computefcc")
compute_fs = Config.getboolean("TDCFConfigurations", "computefs")
compute_srcq = Config.getboolean("TDCFConfigurations", "computesrcq")
apply_kappatst = Config.getboolean("TDCFConfigurations", "applykappatst")
apply_complex_kappatst = Config.getboolean("TDCFConfigurations", "applycomplexkappatst")
apply_kappapu = Config.getboolean("TDCFConfigurations", "applykappapu")
apply_complex_kappapu = Config.getboolean("TDCFConfigurations", "applycomplexkappapu")
apply_kappapum = Config.getboolean("TDCFConfigurations", "applykappapum")
apply_complex_kappapum = Config.getboolean("TDCFConfigurations", "applycomplexkappapum")
apply_kappauim = Config.getboolean("TDCFConfigurations", "applykappauim")
apply_complex_kappauim = Config.getboolean("TDCFConfigurations", "applycomplexkappauim")
apply_kappac = Config.getboolean("TDCFConfigurations", "applykappac")
apply_fcc = Config.getboolean("TDCFConfigurations", "applyfcc")
apply_srcq = Config.getboolean("TDCFConfigurations", "applysrcq")
apply_fs = Config.getboolean("TDCFConfigurations", "applyfs")
minimize_adaptive_sensfilt = Config.getboolean("TDCFConfigurations", "minimizeadaptivesensingfilter") if "minimizeadaptivesensingfilter" in TDCFConfigs else False
use_coherence = Config.getboolean("TDCFConfigurations", "usecoherence")
tdcf_default_to_median = Config.getboolean("TDCFConfigurations", "tdcfdefaulttomedian")
compute_exact_kappas = Config.getboolean("TDCFConfigurations", "computeexactkappas") if "computeexactkappas" in TDCFConfigs else False
# Boolean for state vector computation
compute_calib_statevector = Config.getboolean("CalibrationConfigurations", "computecalibstatevector")
# Boolean for computing factors from filters file
factors_from_filters_file = Config.getboolean("TDCFConfigurations", "factorsfromfiltersfile")
# Boolean for removing calibration lines, power lines, DC component, using median in witness transfer functions
remove_cal_lines = Config.getboolean("DataCleaningConfigurations", "removecallines")
remove_power_lines = Config.getboolean("DataCleaningConfigurations", "removepowerlines") if "removepowerlines" in DataCleaningConfigs else False
remove_dc = Config.getboolean("DataCleaningConfigurations", "removedc")
witness_tf_use_median = Config.getboolean("DataCleaningConfigurations", "witnesstfusemedian")
witness_tf_parallel_mode = Config.getboolean("DataCleaningConfigurations", "witnesstfparallelmode") if "witnesstfparallelmode" in DataCleaningConfigs else False
pick_cleanest_strain_channel = Config.getboolean("DataCleaningConfigurations", "pickcleaneststrainchannel") if "pickcleaneststrainchannel" in DataCleaningConfigs else False
# If td is true we will perform filtering in the time domain (direct convolution) in all FIR filtering routines below
td = not Config.getboolean("PipelineConfigurations", "frequencydomainfiltering")
# Boolean for dewhitening
dewhitening = Config.getboolean("PipelineConfigurations", "dewhitening")
# Boolean for verboseness
verbose = Config.getboolean("DebuggingConfigurations", "verbose")
# Boolean for file_check_sum
file_check_sum = Config.getboolean("InputConfigurations", "filechecksum")
skip_bad_files = Config.getboolean("InputConfigurations", "skipbadfiles")
# Booleans for calibration tests
test_latency = Config.getboolean("DebuggingConfigurations", "testlatency") if "testlatency" in DebuggingConfigs else False
test_filters = Config.getboolean("DebuggingConfigurations", "testfilters") if "testfilters" in DebuggingConfigs else False
monitor_statevector = Config.getboolean("DebuggingConfigurations", "monitorstatevector") if "monitorstatevector" in DebuggingConfigs else False

# Silence latency metric output from stdout if not running in "test_latency" mode
if test_latency:
	silent = False
else:
	silent = True

#
# Load in the filters file that contains filter coefficients, etc.
#

# Search the directory tree for files with names matching the one we want.
filters_name = InputConfigs["filtersfilename"]
if filters_name.count('/') > 0:
	# Then the path to the filters file was given
	filters = numpy.load(filters_name)
else:
	# We need to search for the filters file
	filters_paths = []
	print("\nSearching for %s ..." % filters_name)
	# Check the user's home directory
	for dirpath, dirs, files in os.walk(os.environ['HOME']):
		if filters_name in files:
			# We prefer filters that came directly from a GDSFilters directory of the calibration SVN
			if dirpath.count("GDSFilters") > 0:
				filters_paths.insert(0, os.path.join(dirpath, filters_name))
			else:
				filters_paths.append(os.path.join(dirpath, filters_name))
	# Check if there is a checkout of the entire calibration SVN
	for dirpath, dirs, files in os.walk('/ligo/svncommon/CalSVN/aligocalibration/trunk/Runs/'):
		if filters_name in files:
			# We prefer filters that came directly from a GDSFilters directory of the calibration SVN
			if dirpath.count("GDSFilters") > 0:
				filters_paths.insert(0, os.path.join(dirpath, filters_name))
			else:
				filters_paths.append(os.path.join(dirpath, filters_name))
	if not len(filters_paths):
		raise ValueError("Cannot find filters file %s in home directory %s or in /ligo/svncommon/CalSVN/aligocalibration/trunk/Runs/*/GDSFilters", (filters_name, os.environ['HOME']))
	print("Loading calibration filters from %s\n" % filters_paths[0])
	filters = numpy.load(filters_paths[0])

# In case we want to remove calibration lines, we will fill these dictionaries
pcal_line_removal_dict = {}
act_line_removal_dict = {}

# Load all of the calibration line frequencies and and pcal correction factors
try:
	act_pcal_line_freq = float(filters["ka_pcal_line_freq"])
	pcal_corr_at_act_freq_real = float(filters["ka_pcal_corr_re"])
	pcal_corr_at_act_freq_imag = float(filters["ka_pcal_corr_im"])
	if act_pcal_line_freq > 10:
		pcal_line_removal_dict["pcal1_linefreq"] = [None, act_pcal_line_freq, pcal_corr_at_act_freq_real, pcal_corr_at_act_freq_imag, False]
except:
	if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		raise ValueError("Cannot compute any time-dependent correction factors, as the ~30 Hz pcal line frequency is not in the filters file")
try:
	darm_ctrl_line_freq = float(filters["ka_esd_line_freq"])
except:
	if compute_kappapu:
		raise ValueError("Cannot compute kappa_PU using DARM ctrl line, because the specified filters do not have the DARM ctrl line frequency")
try:
	opt_gain_fcc_line_freq = float(filters["kc_pcal_line_freq"])
	pcal_corr_at_opt_gain_fcc_freq_real = float(filters["kc_pcal_corr_re"])
	pcal_corr_at_opt_gain_fcc_freq_imag = float(filters["kc_pcal_corr_im"])
	if opt_gain_fcc_line_freq > 10:
		pcal_line_removal_dict["pcal2_linefreq"] = [None, opt_gain_fcc_line_freq, pcal_corr_at_opt_gain_fcc_freq_real, pcal_corr_at_opt_gain_fcc_freq_imag, False]
except:
	if compute_kappac or compute_fcc or compute_fs or compute_srcq:
		raise ValueError("Cannot compute kappa_C, f_cc, f_s, or Q, as the ~300 Hz pcal line is not in the filters file")
try:
	esd_act_line_freq = float(filters["ktst_esd_line_freq"])
	if esd_act_line_freq > 10:
		act_line_removal_dict["tstexc_linefreq"] = [None, esd_act_line_freq, "EP10_real", "EP10_imag", False, apply_complex_kappatst, apply_kappatst, None]
except:
	if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		raise ValueError("Cannot compute time-dependent correction factors, as the ESD line frequency is not in the filters file")
try:
	pum_act_line_freq = float(filters["pum_act_line_freq"])
	if pum_act_line_freq > 10:
		act_line_removal_dict["pumexc_linefreq"] = [None, pum_act_line_freq, "EP23_real", "EP23_imag", False, apply_complex_kappapum, apply_kappapum, None]
except:
	if compute_kappapum or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
		raise ValueError("Cannot compute kappa_PUM, as the specified filters file does not contain the needed calibration line frequency")
try:
	uim_act_line_freq = float(filters["uim_act_line_freq"])
	if uim_act_line_freq > 10:
		act_line_removal_dict["uimexc_linefreq"] = [None, uim_act_line_freq, "EP24_real", "EP24_imag", False, apply_complex_kappauim, apply_kappauim, None]
except:
	if compute_kappauim or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
		raise ValueError("Cannot compute kappa_UIM using the UIM actuation line, as the specified filters file does not contain that calibration line frequency")

try:
	src_pcal_line_freq = float(filters["src_pcal_line_freq"])
	pcal_corr_at_src_freq_real = float(filters["src_pcal_corr_re"])
	pcal_corr_at_src_freq_imag = float(filters["src_pcal_corr_im"])
	if src_pcal_line_freq > 10.0 and src_pcal_line_freq != act_pcal_line_freq:
		pcal_line_removal_dict["pcal4_linefreq"] = [None, src_pcal_line_freq, pcal_corr_at_src_freq_real, pcal_corr_at_src_freq_imag, False]
	elif src_pcal_line_freq == act_pcal_line_freq and "low_pcal_line_freq" in filters:
		if float(filters["low_pcal_line_freq"]) > 10.0:
			pcal_line_removal_dict["pcal4_linefreq"] = [None, float(filters["low_pcal_line_freq"]), float(filters["low_pcal_corr_re"]), float(filters["low_pcal_corr_im"]), False]

except:
	if compute_srcq or compute_fs:
		raise ValueError("Cannot compute SRC spring frequency or Q, as the calibration line frequency is not contained in the specified filters file.")
try:
	high_pcal_line_freq = float(filters["high_pcal_line_freq"])
	pcal_corr_at_high_line_freq_real = float(filters["high_pcal_corr_re"])
	pcal_corr_at_high_line_freq_imag = float(filters["high_pcal_corr_im"])
	if high_pcal_line_freq > 10:
		pcal_line_removal_dict["pcal3_linefreq"] = [None, high_pcal_line_freq, pcal_corr_at_high_line_freq_real, pcal_corr_at_high_line_freq_imag, False]
except Exception:
	pass
try:
	roaming_pcal_line_freq = float(filters["roaming_pcal_line_freq"])
	pcal_corr_at_roaming_line_real = float(filters["roaming_pcal_corr_re"])
	pcal_corr_at_roaming_line_imag = float(filters["roaming_pcal_corr_im"])
	if roaming_pcal_line_freq > 10:
		pcal_line_removal_dict["pcal5_linefreq"] = [None, roaming_pcal_line_freq, pcal_corr_at_roaming_line_real, pcal_corr_at_roaming_line_imag, False]
except Exception:
	pass
try:
	fcc_default = float(filters["fcc"])
except:
	fcc_default = expected_fcc
	if fcc_default == 0.0:
		print("Warning: Could not find expected fcc in filters file or config file.  Setting to zero.")
if "fs_squared" in filters:
	fs_squared_default = float(filters["fs_squared"])
elif "expectedfssquared" in TDCFConfigs:
	fs_squared_default = float(TDCFConfigs["expectedfssquared"])
elif "fs" in filters:
	fs_squared_default = pow(float(filters["fs"]), 2)
elif "expectedfs" in TDCFConfigs:
	fs_squared_default = pow(float(TDCFConfigs["expectedfs"]), 2)
else:
	print("Warning: Could not find expected fs in filters file or config file.  Setting to zero.")
	fs_squared_default = 0

# fs_squared_default cannot be exactly zero, as it is later the deniminator of a division
if fs_squared_default == 0:
	fs_squared_default = 0.01

fs_default = numpy.sqrt(complex(fs_squared_default))

if "srcQ" in filters:
	srcQ_default = complex(filters["srcQ"])
elif "expectedsrcq" in TDCFConfigs:
	srcQ_default = complex(TDCFConfigs["expectedsrcq"])
else:
	print("Warning: Could not find expected srcQ in filters file or config file.  Setting to zero.")
	srcQ_default = 0 + 0j

if fs_squared_default < 0:
	srcQ_default = 1j * srcQ_default

# Load kappa dewhitening factors
if dewhitening:
	try:
		derr_dewhiten_at_darm_act_freq_real = float(filters["ka_pcal_whitener_re"])
		derr_dewhiten_at_darm_act_freq_imag = float(filters["ka_pcal_whitener_im"])
		derr_dewhiten_at_pu_act_freq_real = float(filters["ka_esd_whitener_re"])
		derr_dewhiten_at_pu_act_freq_imag = float(filters["ka_esd_whitener_im"])
		derr_dewhiten_at_opt_gain_fcc_freq_real = float(filters["kc_pcal_whitener_re"])
		derr_dewhiten_at_opt_gain_fcc_freq_imag = float(filters["kc_pcal_whitener_im"])
		derr_dewhiten_at_esd_act_freq_real = float(filters["ktst_esd_whitener_re"])
		derr_dewhiten_at_esd_act_freq_imag = float(filters["ktst_esd_whitener_im"])
	except:
		derr_dewhiten_at_darm_act_freq_real = 1.0
		derr_dewhiten_at_darm_act_freq_imag = 0.0
		derr_dewhiten_at_pu_act_freq_real = 1.0
		derr_dewhiten_at_pu_act_freq_imag = 0.0
		derr_dewhiten_at_opt_gain_fcc_freq_real = 1.0
		derr_dewhiten_at_opt_gain_fcc_freq_imag = 0.0
		derr_dewhiten_at_esd_act_freq_real = 1.0
		derr_dewhiten_at_esd_act_freq_imag = 0.0

# If we're reading the reference model factors from the filters file or comparing them to the front-end factors, load them

# The gstlal calibration pipeline uses a historical numbering of the EPICS records
# in order to maintain backwards compatibility. The pyDARM code has a different numbering.
# Here are the conversions:
#
# pyDARM | gstlal
# -------|-------
#    EP0 | ka_pcal_corr
#    EP1 | EP1
#    EP2 | EP15
#    EP3 | EP22
#    EP4 | EP6
#    EP5 | EP7
#    EP6 | EP8
#    EP7 | EP18
#    EP8 | EP19
#    EP9 | kc_pcal_corr
#   EP10 | EP11
#   EP11 | EP12
#   EP12 | EP13
#   EP13 | EP20
#   EP14 | EP21
#   EP15 | pcal_corr_at_src_freq
#   EP16 | EP24
#   EP17 | EP23
#   EP18 | EP10
# absent | EP2
# absent | EP3
# absent | EP4
# absent | EP5
# absent | EP9
# absent | EP14
# absent | EP16
# absent | EP17

if factors_from_filters_file or compute_calib_statevector:
	try:
		EP1_real = float(filters["EP1_real"])
		EP1_imag = float(filters["EP1_imag"])
		EP2_real = float(filters["EP2_real"])
		EP2_imag = float(filters["EP2_imag"])
		EP3_real = float(filters["EP3_real"])
		EP3_imag = float(filters["EP3_imag"])
		EP4_real = float(filters["EP4_real"])
		EP4_imag = float(filters["EP4_imag"])
		EP5_real = float(filters["EP5_real"])
		EP5_imag = float(filters["EP5_imag"])
		EP6_real = float(filters["EP6_real"])
		EP6_imag = float(filters["EP6_imag"])
		EP7_real = float(filters["EP7_real"])
		EP7_imag = float(filters["EP7_imag"])
		EP8_real = float(filters["EP8_real"])
		EP8_imag = float(filters["EP8_imag"])
		EP9_real = float(filters["EP9_real"])
		EP9_imag = float(filters["EP9_imag"])
	except:
		if factors_from_filters_file:
			raise ValueError("Cannot compute time-dependent correction factors, as the needed EPICS are not contained in the specified filters file.")
	try:
		EP10_real = float(filters["EP10_real"])
		EP10_imag = float(filters["EP10_imag"])
	except:
		if factors_from_filters_file and "tstexc_linefreq" in act_line_removal_dict.keys():
			del act_line_removal_dict["tstexc_linefreq"]
	try:
		EP11_real = float(filters["EP11_real"])
		EP11_imag = float(filters["EP11_imag"])
		EP12_real = float(filters["EP12_real"])
		EP12_imag = float(filters["EP12_imag"])
		EP13_real = float(filters["EP13_real"])
		EP13_imag = float(filters["EP13_imag"])
		EP14_real = float(filters["EP14_real"])
		EP14_imag = float(filters["EP14_imag"])
	except:
		if factors_from_filters_file and (compute_srcq or compute_fs):
			raise ValueError("Cannot compute SRC spring frequency or Q, as the needed EPICS are not contained in the specified filters file.")

	try:
		EP15_real = float(filters["EP15_real"])
		EP15_imag = float(filters["EP15_imag"])
		EP16_real = float(filters["EP16_real"])
		EP16_imag = float(filters["EP16_imag"])
		EP17_real = float(filters["EP17_real"])
		EP17_imag = float(filters["EP17_imag"])
		EP18_real = float(filters["EP18_real"])
		EP18_imag = float(filters["EP18_imag"])
		EP19_real = float(filters["EP19_real"])
		EP19_imag = float(filters["EP19_imag"])
		EP20_real = float(filters["EP20_real"])
		EP20_imag = float(filters["EP20_imag"])
		EP21_real = float(filters["EP21_real"])
		EP21_imag = float(filters["EP21_imag"])
		EP22_real = float(filters["EP22_real"])
		EP22_imag = float(filters["EP22_imag"])
		EP23_real = float(filters["EP23_real"])
		EP23_imag = float(filters["EP23_imag"])
		EP24_real = float(filters["EP24_real"])
		EP24_imag = float(filters["EP24_imag"])
	except:
		if factors_from_filters_file and (compute_kappapum or compute_kappauim):
			raise ValueError("Cannot compute kappa_PUM or kappa_UIM, as the needed EPICS are not contained in the specified filters file.")

	try:
		EP25_real = float(filters["EP25_real"])
		EP25_imag = float(filters["EP25_imag"])
		EP26_real = float(filters["EP26_real"])
		EP26_imag = float(filters["EP26_imag"])
		EP27_real = float(filters["EP27_real"])
		EP27_imag = float(filters["EP27_imag"])
		EP28_real = float(filters["EP28_real"])
		EP28_imag = float(filters["EP28_imag"])
		EP29_real = float(filters["EP29_real"])
		EP29_imag = float(filters["EP29_imag"])
		EP30_real = float(filters["EP30_real"])
		EP30_imag = float(filters["EP30_imag"])
		EP31_real = float(filters["EP31_real"])
		EP31_imag = float(filters["EP31_imag"])
		EP32_real = float(filters["EP32_real"])
		EP32_imag = float(filters["EP32_imag"])
		EP33_real = float(filters["EP33_real"])
		EP33_imag = float(filters["EP33_imag"])
		EP34_real = float(filters["EP34_real"])
		EP34_imag = float(filters["EP34_imag"])
		EP35_real = float(filters["EP35_real"])
		EP35_imag = float(filters["EP35_imag"])
		EP36_real = float(filters["EP36_real"])
		EP36_imag = float(filters["EP36_imag"])
		EP37_real = float(filters["EP37_real"])
		EP37_imag = float(filters["EP37_imag"])
		EP38_real = float(filters["EP38_real"])
		EP38_imag = float(filters["EP38_imag"])
		EP39_real = float(filters["EP39_real"])
		EP39_imag = float(filters["EP39_imag"])
		EP40_real = float(filters["EP40_real"])
		EP40_imag = float(filters["EP40_imag"])
		EP41_real = float(filters["EP41_real"])
		EP41_imag = float(filters["EP41_imag"])
		EP42_real = float(filters["EP42_real"])
		EP42_imag = float(filters["EP42_imag"])
	except:
		if compute_exact_kappas and (compute_kappatst or compute_kappapum or compute_kappauim or compute_kappac or compute_fcc or compute_srcq or compute_fs):
			raise ValueError("Cannot use ComputeExactKappas, as the needed EPICS (25 - 42) are not in the filters file")

if compute_exact_kappas and (compute_kappatst or compute_kappapum or compute_kappauim or compute_kappac or compute_fcc or compute_srcq or compute_fs):
	try:
		EP43_real = float(filters["EP43_real"])
		EP43_imag = float(filters["EP43_imag"])
		EP44_real = float(filters["EP44_real"])
		EP44_imag = float(filters["EP44_imag"])
		EP45_real = float(filters["EP45_real"])
		EP45_imag = float(filters["EP45_imag"])
		EP46_real = float(filters["EP46_real"])
		EP46_imag = float(filters["EP46_imag"])
		EP47_real = float(filters["EP47_real"])
		EP47_imag = float(filters["EP47_imag"])
	except:
		raise ValueError("Cannot use ComputeExactKappas, as EPICS 43 - 47 are not in the filters file.")

# Load the high-pass filters for h(t)
if "ctrl_highpass" in filters:
	act_highpass = filters["ctrl_highpass"]
	act_highpass_delay = int(filters['ctrl_highpass_delay'])
elif "actuation_highpass" in filters:
	act_highpass = filters["actuation_highpass"]
	act_highpass_delay = int(filters['actuation_highpass_delay'])
else:
	act_highpass = []
if "res_highpass" in filters:
	invsens_highpass = filters["res_highpass"]
	invsens_highpass_delay = int(filters['res_highpass_delay'])
	invsens_highpass_sr = int(filters['res_highpass_sr']) if 'res_highpass_sr' in filters else hoft_sr
elif "inv_sensing_highpass" in filters:
	invsens_highpass = filters["inv_sensing_highpass"]
	invsens_highpass_delay = int(filters['invsens_highpass_delay'])
	invsens_highpass_sr = int(filters['invsens_highpass_sr']) if 'invsens_highpass_sr' in filters else hoft_sr
else:
	invsens_highpass = []

# If we're performing partial calibration, load the deltal filters
if CalibrationConfigs["calibrationmode"] == "Partial":
	reschaindelay = int(filters["res_corr_delay"])
	if minimize_adaptive_sensfilt and apply_fcc and (apply_fs or apply_srcq):
		reschainfilt = filters["res_corr_nopole_filter"]
	elif apply_fcc:
		reschainfilt = filters["res_corr_noccpole_filter"]
	else:
		reschainfilt = filters["res_corr_filter"]
	tstdelay = pumdelay = uimdelay = pumuimdelay = int(filters["ctrl_corr_delay"])
	tstfilt = filters["TST_corr_filter"] if "TST_corr_filter" in filters else filters["ctrl_corr_filter"]
	pumfilt = filters["PUM_corr_filter"] if "PUM_corr_filter" in filters else filters["ctrl_corr_filter"]
	uimfilt = filters["UIM_corr_filter"] if "UIM_corr_filter" in filters else filters["ctrl_corr_filter"]
	pumuimfilt = filters["ctrl_corr_filter"]
	tstchainsr = pumchainsr = uimchainsr = pumuimchainsr = int(filters["ctrl_corr_sr"])
	reschainfilt_model = filters["res_corr_filt_model"] if "res_corr_filt_model" else None
	tstfilt_model = filters["TST_corr_filt_model"] if "TST_corr_filt_model" in filters else filters["ctrl_corr_filt_model"] if "ctrl_corr_filt_model" in filters else None
	pumfilt_model = filters["PUM_corr_filt_model"] if "PUM_corr_filt_model" in filters else filters["ctrl_corr_filt_model"] if "ctrl_corr_filt_model" in filters else None
	uimfilt_model = filters["UIM_corr_filt_model"] if "UIM_corr_filt_model" in filters else filters["ctrl_corr_filt_model"] if "ctrl_corr_filt_model" in filters else None
	pumuimfilt_model = filters["ctrl_corr_filt_model"] if "ctrl_corr_filt_model" in filters else None
	if dewhitening:
		tstdewhitensr = int(filters["deltal_tst_dewhiten_sr"])
		tstdewhitendelay = int(filters["deltal_tst_dewhiten_delay"])
		tstdewhiten = filters["deltal_tst_dewhiten"]
		if apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim:
			pumdewhitensr = int(filters["deltal_pum_dewhiten_sr"])
			pumdewhitendelay = int(filters["deltal_pum_dewhiten_delay"])
			pumdewhiten = filters["deltal_pum_dewhiten"]
			uimdewhitensr = int(filters["deltal_uim_dewhiten_sr"])
			uimdewhitendelay = int(filters["deltal_uim_dewhiten_delay"])
			uimdewhiten = filters["deltal_uim_dewhiten"]
		else:
			pumuimdewhitensr = int(filters["deltal_pumuim_dewhiten_sr"])
			pumuimdewhitendelay = int(filters["deltal_pumuim_dewhiten_delay"])
			pumuimdewhiten = filters["deltal_pumuim_dewhiten"]
		resdewhitendelay = int(filters["deltal_res_dewhiten_delay"])
		resdewhiten = filters["deltal_res_dewhiten"]

# If we're performing full calibration, load the actuation, sensing filters
if CalibrationConfigs["calibrationmode"] == "Full":
	tstchainsr = int(filters["actuation_tst_sr"])
	tstdelay = int(filters["actuation_tst_delay"])
	tstfilt = filters["actuation_tst"]
	tstfilt_model = filters["tstfilt_model"] if "tstfilt_model" in filters else None
	try:
		pumchainsr = int(filters["actuation_pum_sr"])
		pumdelay = int(filters["actuation_pum_delay"])
		pumfilt = filters["actuation_pum"]
		pumfilt_model = filters["pumfilt_model"] if "pumfilt_model" in filters else None
		uimchainsr = int(filters["actuation_uim_sr"])
		uimdelay = int(filters["actuation_uim_delay"])
		uimfilt = filters["actuation_uim"]
		uimfilt_model = filters["uimfilt_model"] if "uimfilt_model" in filters else None
	except:
		if apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim:
			raise ValueError("PUM and UIM actuation filters are needed since the PUM and UIM stages are being split")
	try:
		pumuimchainsr = int(filters["actuation_pumuim_sr"])
		pumuimdelay = int(filters["actuation_pumuim_delay"])
		pumuimfilt = filters["actuation_pumuim"]
		pumuimfilt_model = filters["pumuimfilt_model"] if "pumuimfilt_model" in filters else None
	except:
		if not (apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim):
			raise ValueError("PUM/UIM actuation filter is needed since the PUM and UIM stages are not being split")
	reschaindelay = int(filters["inv_sens_delay"])
	if minimize_adaptive_sensfilt and apply_fcc and (apply_fs or apply_srcq):
		reschainfilt = filters["inv_sensing_nopole"]
	elif minimize_adaptive_sensfilt and apply_fcc:
		reschainfilt = filters["inv_sensing_noccpole"]
	else:
		reschainfilt = filters["inv_sensing"]
	reschainfilt_model = filters["invsensfilt_model"] if "invsensfilt_model" in filters else None
	if dewhitening:
		ctrldewhitendelay = int(filters["dewhiten_ctrl_delay"])
		ctrldewhiten = filters["dewhiten_ctrl"]
		ctrldewhitensr = int(filters["dewhiten_ctrl_sr"])
		resdewhitendelay = int(filters["dewhiten_err_delay"])
		resdewhiten = filters["dewhiten_err"]

invsens_window_type = str(filters["invsens_window_type"]) if "invsens_window_type" in filters else 'dpss'
act_window_type = str(filters["act_window_type"]) if "act_window_type" in filters else 'dpss'
invsens_freq_res = float(filters["invsens_freq_res"]) if "invsens_freq_res" in filters else 3.0
act_freq_res = float(filters["act_freq_res"]) if "act_freq_res" in filters else 3.0


# If we are reading EPICS from the frames and want to remove calibration lines, account for the fact that not all EPICS were available at all times.
if not factors_from_filters_file and InputConfigs["datasource"] == "frames" and ((instrument == "H1" and gps_start_time < 1175976256) or (instrument == "L1" and gps_start_time < 1179588864)) and "tstexc_linefreq" in act_line_removal_dict.keys():
	del act_line_removal_dict["tstexc_linefreq"]

#
# Set up the appropriate channel list. In this section, we also fill a list called headkeys
# that will be the keys for the dictionary holding each pipeline branch name, and we set up
# a dictionary that will be populated with pipeline branch names based on the channel list.
#

head_dict = {}
channel_list = []
headkeys = []

# If we are computing the CALIB_STATE_VECTOR, we need input DQ channel(s)
if compute_calib_statevector:
	obsintent_channel_name = ChannelNames["obsintentchannel"] if "obsintentchannel" in ChannelNames else ChannelNames["inputdqchannel"]
	obsintent_bitmask = int(Bitmasks["obsintentbitmask"])
	lownoise_channel_name = ChannelNames["lownoisestatechannel"] if "lownoisestatechannel" in ChannelNames else ChannelNames["inputdqchannel"]
	lownoise_bitmask = int(Bitmasks["lownoisebitmask"]) if "lownoisebitmask" in Bitmasks else int(Bitmasks["obsreadybitmask"])
	filterclock_channel_list = ChannelNames["filterclockchannellist"].split(';') if "filterclockchannellist" in ChannelNames else [lownoise_channel_name]
	filterclock_bitmask_list = Bitmasks["filterclockbitmasklist"].split(';') if "filterclockbitmasklist" in Bitmasks else [lownoise_bitmask]
	hwinj_channel_name = ChannelNames["hwinjchannel"] if "hwinjchannel" in ChannelNames else ChannelNames["inputdqchannel"]
	cbchwinj_bitmask = int(Bitmasks["cbchwinjbitmask"]) if "cbchwinjbitmask" in Bitmasks else None
	cbchwinj_offbitmask = int(Bitmasks["cbchwinjoffbitmask"]) if "cbchwinjoffbitmask" in Bitmasks else None
	bursthwinj_bitmask = int(Bitmasks["bursthwinjbitmask"]) if "bursthwinjbitmask" in Bitmasks else None
	bursthwinj_offbitmask = int(Bitmasks["bursthwinjoffbitmask"]) if "bursthwinjoffbitmask" in Bitmasks else None
	detcharhwinj_bitmask = int(Bitmasks["detcharhwinjbitmask"]) if "detcharhwinjbitmask" in Bitmasks else None
	detcharhwinj_offbitmask = int(Bitmasks["detcharhwinjoffbitmask"]) if "detcharhwinjoffbitmask" in Bitmasks else None
	stochhwinj_bitmask = int(Bitmasks["stochhwinjbitmask"]) if "stochhwinjbitmask" in Bitmasks else None
	stochhwinj_offbitmask = int(Bitmasks["stochhwinjoffbitmask"]) if "stochhwinjoffbitmask" in Bitmasks else None

	channel_list.append((instrument, obsintent_channel_name))
	headkeys.append("obsintent")
	if lownoise_channel_name != obsintent_channel_name:
		channel_list.append((instrument, lownoise_channel_name))
		headkeys.append("lownoise")
	if hwinj_channel_name != obsintent_channel_name and hwinj_channel_name != lownoise_channel_name:
		channel_list.append((instrument, hwinj_channel_name))
		headkeys.append("hwinj")

	if len(filterclock_bitmask_list) != len(filterclock_channel_list) or len(filterclock_bitmask_list) != len(filterclock_sr_list):
		raise ValueError("FilterClockChannelList, FilterClockBitmaskList, and FilterClockSRList must all be the same length.")
	for i in range(len(filterclock_channel_list)):
		filterclock_channel_list[i] = filterclock_channel_list[i].split(',')
		for j in range(len(filterclock_channel_list[i])):
			if filterclock_channel_list[i][j] != obsintent_channel_name and filterclock_channel_list[i][j] != lownoise_channel_name:
				channel_list.append((instrument, filterclock_channel_list[i][j]))
				headkeys.append(filterclock_channel_list[i][j])
		filterclock_sr_list[i] = int(filterclock_sr_list[i])
		filterclock_bitmask_list[i] = int(filterclock_bitmask_list[i])

# If we are using the front-end EPICS records to either compute the TDCFs or the CALIB_STATE_VECTOR, we need to add those channels
# Needed for kappa_tst, kappa_pum, kappa_uim, kappa_pu, kappa_c, f_cc, f_s, and Q
if not factors_from_filters_file or compute_calib_statevector:
	# Needed for kappa_TST
	if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		channel_list.extend(((instrument, ChannelNames["ep1realchannel"]), (instrument, ChannelNames["ep1imagchannel"])))
		headkeys.extend(("EP1_real", "EP1_imag"))
	# These are needed for kappa_PUM
	if compute_kappapum or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
		channel_list.extend(((instrument, ChannelNames["ep15realchannel"]), (instrument, ChannelNames["ep15imagchannel"])))
		headkeys.extend(("EP15_real", "EP15_imag"))
	# These are needed for kappa_UIM
	if compute_kappauim or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
		channel_list.extend(((instrument, ChannelNames["ep22realchannel"]), (instrument, ChannelNames["ep22imagchannel"])))
		headkeys.extend(("EP22_real", "EP22_imag"))
	# These are needed for kappa_PU
	if compute_kappapu:
		channel_list.extend(((instrument, ChannelNames["ep2realchannel"]), (instrument, ChannelNames["ep2imagchannel"]), (instrument, ChannelNames["ep3realchannel"]), (instrument, ChannelNames["ep3imagchannel"]), (instrument, ChannelNames["ep4realchannel"]), (instrument, ChannelNames["ep4imagchannel"])))
		headkeys.extend(("EP2_real", "EP2_imag", "EP3_real", "EP3_imag", "EP4_real", "EP4_imag"))
	# These are needed for kappa_C and f_cc
	if compute_kappac or compute_fcc or compute_fs or compute_srcq:
		if compute_kappapu:
			channel_list.extend(((instrument, ChannelNames["ep6realchannel"]), (instrument, ChannelNames["ep6imagchannel"]), (instrument, ChannelNames["ep7realchannel"]), (instrument, ChannelNames["ep7imagchannel"]), (instrument, ChannelNames["ep8realchannel"]), (instrument, ChannelNames["ep8imagchannel"]), (instrument, ChannelNames["ep9realchannel"]), (instrument, ChannelNames["ep9imagchannel"])))
			headkeys.extend(("EP6_real", "EP6_imag", "EP7_real", "EP7_imag", "EP8_real", "EP8_imag", "EP9_real", "EP9_imag"))
		else:
			channel_list.extend(((instrument, ChannelNames["ep6realchannel"]), (instrument, ChannelNames["ep6imagchannel"]), (instrument, ChannelNames["ep7realchannel"]), (instrument, ChannelNames["ep7imagchannel"]), (instrument, ChannelNames["ep8realchannel"]), (instrument, ChannelNames["ep8imagchannel"]), (instrument, ChannelNames["ep18realchannel"]), (instrument, ChannelNames["ep18imagchannel"]), (instrument, ChannelNames["ep19realchannel"]), (instrument, ChannelNames["ep19imagchannel"])))
			headkeys.extend(("EP6_real", "EP6_imag", "EP7_real", "EP7_imag", "EP8_real", "EP8_imag", "EP18_real", "EP18_imag", "EP19_real", "EP19_imag"))

	# These are needed if we compute the optical spring frequency and/or Q-factor of the Signal Recycling Cavity (SRC)
	if compute_fs or compute_srcq:
		if compute_kappapu:
			channel_list.extend(((instrument, ChannelNames["ep11realchannel"]), (instrument, ChannelNames["ep11imagchannel"]), (instrument, ChannelNames["ep12realchannel"]), (instrument, ChannelNames["ep12imagchannel"]), (instrument, ChannelNames["ep13realchannel"]), (instrument, ChannelNames["ep13imagchannel"]), (instrument, ChannelNames["ep14realchannel"]), (instrument, ChannelNames["ep14imagchannel"])))
			headkeys.extend(("EP11_real", "EP11_imag", "EP12_real", "EP12_imag", "EP13_real", "EP13_imag", "EP14_real", "EP14_imag"))
		else:
			channel_list.extend(((instrument, ChannelNames["ep11realchannel"]), (instrument, ChannelNames["ep11imagchannel"]), (instrument, ChannelNames["ep12realchannel"]), (instrument, ChannelNames["ep12imagchannel"]), (instrument, ChannelNames["ep13realchannel"]), (instrument, ChannelNames["ep13imagchannel"]), (instrument, ChannelNames["ep20realchannel"]), (instrument, ChannelNames["ep20imagchannel"]), (instrument, ChannelNames["ep21realchannel"]), (instrument, ChannelNames["ep21imagchannel"])))
			headkeys.extend(("EP11_real", "EP11_imag", "EP12_real", "EP12_imag", "EP13_real", "EP13_imag", "EP20_real", "EP20_imag", "EP21_real", "EP21_imag"))
	# EP10 is needed to remove the ESD line
	if remove_cal_lines and "tstexc_linefreq" in act_line_removal_dict.keys():
		channel_list.extend(((instrument, ChannelNames["ep10realchannel"]), (instrument, ChannelNames["ep10imagchannel"])))
		headkeys.extend(("EP10_real", "EP10_imag"))
	# EP23 is needed to remove the PUM line
	if remove_cal_lines and "pumexc_linefreq" in act_line_removal_dict.keys():
		channel_list.extend(((instrument, ChannelNames["ep23realchannel"]), (instrument, ChannelNames["ep23imagchannel"])))
		headkeys.extend(("EP23_real", "EP23_imag"))
	# EP24 is needed to remove the UIM line
	if remove_cal_lines and "uimexc_linefreq" in act_line_removal_dict.keys():
		channel_list.extend(((instrument, ChannelNames["ep24realchannel"]), (instrument, ChannelNames["ep24imagchannel"])))
		headkeys.extend(("EP24_real", "EP24_imag"))

	# If we are using pre-computed coherence to gate kappas
if use_coherence:
	if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		channel_list.append((instrument, ChannelNames["cohuncpcalyline1channel"]))
		headkeys.append("pcaly_line1_coh")
	if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		channel_list.append((instrument, ChannelNames["cohuncsusline3channel"]))
		headkeys.append("sus_line3_coh")
	if compute_kappapu:
		channel_list.append((instrument, ChannelNames["cohuncdarmline1channel"]))
		headkeys.append("darm_coh")
	if compute_kappapum or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
		channel_list.append((instrument, ChannelNames["cohuncsusline2channel"]))
		headkeys.append("sus_line2_coh")
	if compute_kappauim or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
		channel_list.append((instrument, ChannelNames["cohuncsusline1channel"]))
		headkeys.append("sus_line1_coh")
	if compute_kappac or compute_fcc or compute_fs or compute_srcq:
		channel_list.append((instrument, ChannelNames["cohuncpcalyline2channel"]))
		headkeys.append("pcaly_line2_coh")
	if compute_fs or compute_srcq:
		if src_pcal_line_freq != act_pcal_line_freq:
			channel_list.append((instrument, ChannelNames["cohuncpcalyline4channel"]))
			headkeys.append("pcaly_line4_coh")

# We also need excitation channels for computing kappas
if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq or (remove_cal_lines and "tstexc_linefreq" in act_line_removal_dict.keys()):
	channel_list.append((instrument, ChannelNames["tstexcchannel"]))
	headkeys.append("tstexc")
	# If reading EPICS from the frames, also read the line frequency from the frames if we can
	if not factors_from_filters_file and "tstexclinefreqchannel" in ChannelNames:
		if ChannelNames["tstexclinefreqchannel"] != "None":
			channel_list.append((instrument, ChannelNames["tstexclinefreqchannel"]))
			headkeys.append("tstexc_linefreq")
if compute_kappapum or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)) or (remove_cal_lines and "pumexc_linefreq" in act_line_removal_dict.keys()):
	channel_list.append((instrument, ChannelNames["pumexcchannel"]))
	headkeys.append("pumexc")
	# If reading EPICS from the frames, also read the line frequency from the frames if we can
	if not factors_from_filters_file and "pumexclinefreqchannel" in ChannelNames:
		if ChannelNames["pumexclinefreqchannel"] != "None":
			channel_list.append((instrument, ChannelNames["pumexclinefreqchannel"]))
			headkeys.append("pumexc_linefreq")
if compute_kappauim or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)) or (remove_cal_lines and "uimexc_linefreq" in act_line_removal_dict.keys()):
	channel_list.append((instrument, ChannelNames["uimexcchannel"]))
	headkeys.append("uimexc")
	# If reading EPICS from the frames, also read the line frequency from the frames if we can
	if not factors_from_filters_file and "uimexclinefreqchannel" in ChannelNames:
		if ChannelNames["uimexclinefreqchannel"] != "None":
			channel_list.append((instrument, ChannelNames["uimexclinefreqchannel"]))
			headkeys.append("uimexc_linefreq")
if compute_kappapu:
	channel_list.append((instrument, ChannelNames["darmexcchannel"]))
	headkeys.append("darmexc")
	# If reading EPICS from the frames, also read the line frequency from the frames if we can
	if not factors_from_filters_file and "darmexclinefreqchannel" in ChannelNames:
		if ChannelNames["darmexclinefreqchannel"] != "None":
			channel_list.append((instrument, ChannelNames["darmexclinefreqchannel"]))
			headkeys.append("darmexc_linefreq")

# We need the PCAL channel if we are computing \kappas or removing the calibration lines
if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq or remove_cal_lines:
	channel_list.append((instrument, ChannelNames["pcalchannel"]))
	headkeys.append("pcal")
	# If reading EPICS from the frames, also read the line frequencies from the frames if we can.
	# We need the pcal correction factors as well if we are going to update pcal line frequencies.
	if not factors_from_filters_file and "pcalline1freqchannel" in ChannelNames and "pcalline1corrrealchannel" in ChannelNames and "pcalline1corrimagchannel" in ChannelNames:
		if ChannelNames["pcalline1freqchannel"] != "None" and ChannelNames["pcalline1corrrealchannel"] != "None" and ChannelNames["pcalline1corrimagchannel"] != "None":
			channel_list.append((instrument, ChannelNames["pcalline1freqchannel"]))
			headkeys.append("pcal1_linefreq")
			channel_list.append((instrument, ChannelNames["pcalline1corrrealchannel"]))
			headkeys.append("pcal1_line_corr_real")
			channel_list.append((instrument, ChannelNames["pcalline1corrimagchannel"]))
			headkeys.append("pcal1_line_corr_imag")
	if not factors_from_filters_file and "pcalline2freqchannel" in ChannelNames and "pcalline2corrrealchannel" in ChannelNames and "pcalline2corrimagchannel" in ChannelNames:
		if ChannelNames["pcalline2freqchannel"] != "None" and ChannelNames["pcalline2corrrealchannel"] != "None" and ChannelNames["pcalline2corrimagchannel"] != "None":
			channel_list.append((instrument, ChannelNames["pcalline2freqchannel"]))
			headkeys.append("pcal2_linefreq")
			channel_list.append((instrument, ChannelNames["pcalline2corrrealchannel"]))
			headkeys.append("pcal2_line_corr_real")
			channel_list.append((instrument, ChannelNames["pcalline2corrimagchannel"]))
			headkeys.append("pcal2_line_corr_imag")
	if not factors_from_filters_file and "pcalline3freqchannel" in ChannelNames and "pcalline3corrrealchannel" in ChannelNames and "pcalline3corrimagchannel" in ChannelNames:
		if ChannelNames["pcalline3freqchannel"] != "None" and ChannelNames["pcalline3corrrealchannel"] != "None" and ChannelNames["pcalline3corrimagchannel"] != "None":
			channel_list.append((instrument, ChannelNames["pcalline3freqchannel"]))
			headkeys.append("pcal3_linefreq")
			channel_list.append((instrument, ChannelNames["pcalline3corrrealchannel"]))
			headkeys.append("pcal3_line_corr_real")
			channel_list.append((instrument, ChannelNames["pcalline3corrimagchannel"]))
			headkeys.append("pcal3_line_corr_imag")
	if not factors_from_filters_file and "pcalline4freqchannel" in ChannelNames and "pcalline4corrrealchannel" in ChannelNames and "pcalline4corrimagchannel" in ChannelNames:
		if ChannelNames["pcalline4freqchannel"] != "None" and ChannelNames["pcalline4corrrealchannel"] != "None" and ChannelNames["pcalline4corrimagchannel"] != "None":
			channel_list.append((instrument, ChannelNames["pcalline4freqchannel"]))
			headkeys.append("pcal4_linefreq")
			channel_list.append((instrument, ChannelNames["pcalline4corrrealchannel"]))
			headkeys.append("pcal4_line_corr_real")
			channel_list.append((instrument, ChannelNames["pcalline4corrimagchannel"]))
			headkeys.append("pcal4_line_corr_imag")

# For full calibration we need DARM_ERR and DARM_CTRL as our input channels
if CalibrationConfigs["calibrationmode"] == "Full":
	channel_list.extend(((instrument, ChannelNames["darmerrchannel"]), (instrument, ChannelNames["darmctrlchannel"])))
	headkeys.extend(("res", "ctrl"))
# For partial calibration we need DELTAL_TST, DELTAL_PUM, DELTAL_UIM, and DELTAL_RES
elif CalibrationConfigs["calibrationmode"] == "Partial":
	channel_list.extend(((instrument, ChannelNames["deltalreschannel"]), (instrument, ChannelNames["deltaltstchannel"]), (instrument, ChannelNames["deltalpumchannel"]), (instrument, ChannelNames["deltaluimchannel"])))
	headkeys.extend(("res", "tst", "pum", "uim"))
	if test_filters:
		# Then we need DARM_ERR and DARM_CTRL to test filters
		channel_list.extend(((instrument, ChannelNames["darmerrchannel"]), (instrument, ChannelNames["darmctrlchannel"])))
		headkeys.extend(("darm_err", "ctrl"))
	elif compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		# We also need DARM_ERR if we are computing the kappas
		channel_list.append((instrument, ChannelNames["darmerrchannel"]))
		headkeys.append("darm_err")

# If we are removing lines using witness channels (e.g., 60 Hz lines and harmonics), add the witness channels
line_witness_channel_list = []
line_witness_freqs = []
line_witness_freq_vars = []
line_witness_tf_median_time = None
line_witness_tf_averaging_time = None
if (ChannelNames["linewitnesschannellist"] != "None") if "linewitnesschannellist" in ChannelNames else False:
	line_witness_channel_list = ChannelNames["linewitnesschannellist"].split(';')
	line_witness_freqs = DataCleaningConfigs["linewitnessfreqs"].split(';')
	line_witness_freq_vars = DataCleaningConfigs["linewitnessfreqvars"].split(';')
	line_witness_tf_median_time = float(DataCleaningConfigs["linewitnesstfmediantime"])
	line_witness_tf_averaging_time = float(DataCleaningConfigs["linewitnesstfaveragingtime"])
	for i in range(0, len(line_witness_channel_list)):
		line_witness_channel_list[i] = line_witness_channel_list[i].split(',')
		for j in range(0, len(line_witness_channel_list[i])):
			if (instrument, line_witness_channel_list[i][j]) not in channel_list:
				channel_list.append((instrument, line_witness_channel_list[i][j]))
				headkeys.append(line_witness_channel_list[i][j])
	for i in range(0, len(line_witness_freqs)):
		line_witness_freqs[i] = line_witness_freqs[i].split(',')
		for j in range(0, len(line_witness_freqs[i])):
			line_witness_freqs[i][j] = float(line_witness_freqs[i][j])
	for i in range(0, len(line_witness_freq_vars)):
		line_witness_freq_vars[i] = float(line_witness_freq_vars[i])
	# Channels that contain frequencies of lines to be removed
	if "linewitnessfrequencychannellist" in ChannelNames:
		line_witness_frequency_channel_list = ChannelNames["linewitnessfrequencychannellist"].split(';')
		for i in range(0, len(line_witness_frequency_channel_list)):
			line_witness_frequency_channel_list[i] = line_witness_frequency_channel_list[i].split(',')
			for j in range(0, len(line_witness_frequency_channel_list[i])):
				if line_witness_frequency_channel_list[i][j] == "None":
					line_witness_frequency_channel_list[i][j] = None
				elif is_number(line_witness_frequency_channel_list[i][j]):
					line_witness_frequency_channel_list[i][j] = float(line_witness_frequency_channel_list[i][j])
				elif (instrument, line_witness_frequency_channel_list[i][j]) not in channel_list:
					channel_list.append((instrument, line_witness_frequency_channel_list[i][j]))
					headkeys.append(line_witness_frequency_channel_list[i][j])
				else:
					line_witness_frequency_channel_list[i][j] = headkeys[channel_list.index((instrument, line_witness_frequency_channel_list[i][j]))]
	else:
		line_witness_frequency_channel_list = []
		for i in range(0, len(line_witness_freqs)):
			line_witness_frequency_channel_list.append([])
			for j in range(0, len(line_witness_freqs[i])):
				line_witness_frequency_channel_list[i].append(None)
else:
	line_witness_frequency_channel_list = []

if (ChannelNames["powerlineschannel"] not in headkeys) if remove_power_lines else False:
	channel_list.append((instrument, ChannelNames["powerlineschannel"]))
	headkeys.append(ChannelNames["powerlineschannel"])
	line_witness_channel_list.append([ChannelNames["powerlineschannel"]])
	line_witness_freqs.append([60.0, 120.0, 180.0, 240.0, 300.0])
	line_witness_freq_vars.append(powerlines_freq_var)
	if line_witness_tf_median_time is None:
		line_witness_tf_median_time = powerlines_tf_median_time
	if line_witness_tf_averaging_time is None: 
		line_witness_tf_averaging_time = powerlines_tf_averaging_time

# If we are using witness channels to clean h(t), add those to the channel list
witness_channel_list = []
if ChannelNames["witnesschannellist"] != "None":
	witness_channel_list = ChannelNames["witnesschannellist"].split(';')
	witness_notch_frequencies = DataCleaningConfigs["witnessnotchfrequencies"].split(';')
	witness_rates = SampleRates["witnesschannelsr"].split(';')
	witness_highpasses = DataCleaningConfigs['witnesshighpasses'].split(';') if "witnesshighpasses" in DataCleaningConfigs else list(15 * numpy.ones(len(witness_channel_list)))
	if len(witness_channel_list) != len(witness_notch_frequencies) or len(witness_channel_list) != len(witness_rates):
		raise ValueError("WitnessChannelList, WitnessChannelSR, and WitnessNotchFrequencies must all be the same length, i.e., they must all have the same number of semicolons (;)")
	for i in range(0, len(witness_channel_list)):
		witness_channel_list[i] = witness_channel_list[i].split(',')
		for j in range(0, len(witness_channel_list[i])):
			channel_list.append((instrument, witness_channel_list[i][j]))
			headkeys.append(witness_channel_list[i][j])
		witness_rates[i] = int(witness_rates[i])
		witness_highpasses[i] = float(witness_highpasses[i])
		witness_notch_frequencies[i] = witness_notch_frequencies[i].split(',')
		if len(witness_notch_frequencies[i]) <= 1:
			witness_notch_frequencies[i] = []
		else:
			for j in range(0, len(witness_notch_frequencies[i])):
				witness_notch_frequencies[i][j] = float(witness_notch_frequencies[i][j])

# If we are gating the noise or 60 Hz line subtraction with something other than the ODC state vector, add that channel
if compute_calib_statevector:
	noisesub_gate_channel = ChannelNames["noisesubgatechannel"] if "noisesubgatechannel" in ChannelNames else lownoise_channel_name 
	noisesub_gate_bitmask = int(Bitmasks["noisesubgatebitmask"]) if "noisesubgatebitmask" in Bitmasks else lownoise_bitmask
if compute_calib_statevector and (any(line_witness_channel_list) or any(witness_channel_list)) and noisesub_gate_channel != obsintent_channel_name and noisesub_gate_channel != lownoise_channel_name and noisesub_gate_channel != hwinj_channel_name and noisesub_gate_channel not in numpy.concatenate(filterclock_channel_list) and noisesub_gate_bitmask > 0 and noisesub_gate_channel != "None":
	channel_list.append((instrument, noisesub_gate_channel))
	headkeys.append("noisesubgatechannel")

####################################################################################################
####################################### Main Pipeline ##############################################
####################################################################################################

pipeline = Gst.Pipeline(name="gstlal_compute_strain")
mainloop = GObject.MainLoop()
if kafka_server is not None:
	handler = calibhandler.Handler(mainloop, pipeline, kafka_server = kafka_server, verbose = verbose, latency_suffix = latency_suffix)
else:
	print("Using simple handler")
	handler = simplehandler.Handler(mainloop, pipeline)

# 
# Turn off debugging tools or verboseness
#

pipeparts.mkchecktimestamps = lambda pipeline, src, *args: src # comment this line out to turn on the checktimestamps debugging
if not verbose:
	pipeparts.mkprogressreport = lambda pipeline, src, *args: src

#
# Read in data from frames or shared memory
#

if InputConfigs["datasource"] == "lvshm": # Data is to be read from shared memory; "low-latency" mode
	src = pipeparts.mklvshmsrc(pipeline, shm_name = InputConfigs["shmpartition"], assumed_duration = input_frame_duration)
elif InputConfigs["datasource"] == "frames": # Data is to be read from frame files; "offline" mode
	src = pipeparts.mklalcachesrc(pipeline, location = options.frame_cache, cache_dsc_regex = instrument, use_mmap = True)

# FIXME: I don't think I need to add a resampler before this latency element since it's hooked right up to the frames, which are already only coming in at a rate of 1 Hz.
if (test_latency or InputConfigs["datasource"] == "lvshm"):
	src = pipeparts.mktee(pipeline, src)
	src_latency = pipeparts.mklatency(pipeline, src, name = "%s_src" % OutputConfigs["frametype"], silent = silent)
	if kafka_server is not None:
		src_latency.connect("notify::current-latency", handler.latency_new_buffer)
	pipeparts.mkfakesink(pipeline, src_latency)


#
# Hook up the relevant channels to the demuxer
#

demux = pipeparts.mkframecppchanneldemux(pipeline, src, do_file_checksum = file_check_sum, skip_bad_files = skip_bad_files, channel_list = map("%s:%s".__mod__, channel_list))

# Write the pipeline graph after pads have been hooked up to the demuxer
if DebuggingConfigs["pipelinegraphfilename"] != "None":
	demux.connect("no-more-pads", write_graph)	


# Get everything hooked up and fill in discontinuities
for key, chan in zip(headkeys, channel_list):
	head_dict[key] = calibration_parts.hook_up(pipeline, demux, chan[1], instrument, float(PipelineConfigs["bufferlength"]), wait_time = wait_time)

# The DARM_ERR channel follows different paths if we're doing full vs. partial calibration
if CalibrationConfigs["calibrationmode"] == "Full":
	darm_err = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "darm_err")
	derrtee = pipeparts.mktee(pipeline, darm_err)
elif compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_srcq or compute_fs or test_filters:
	darm_err = calibration_parts.caps_and_progress(pipeline, head_dict["darm_err"], hoft_caps, "darm_err")
	derrtee = pipeparts.mktee(pipeline, darm_err)

# pcal excitation channel, which will be demodulated
if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_srcq or compute_fs or (remove_cal_lines and len(pcal_line_removal_dict) > 0):
	pcal = calibration_parts.caps_and_progress(pipeline, head_dict["pcal"], hoft_caps, "pcal")
	pcaltee = pipeparts.mktee(pipeline, pcal)
	# Check if we are also using pcal as a witness for line subtraction
	for i in range(0, len(line_witness_channel_list)):
		for j in range(0, len(line_witness_channel_list[i])):
			if line_witness_channel_list[i][j] == ChannelNames["pcalchannel"]:
				line_witness_channel_list[i][j] = pcaltee
	for pcal_line_name in pcal_line_removal_dict.keys():
		pcal_line_removal_dict[pcal_line_name][0] = pcaltee

#
# TIME-VARYING FACTORS COMPUTATIONS
#

A_epics_dict = {}
D_epics_dict = {}
C_epics_dict = {}
misc_epics_dict = {}
for key in headkeys:
	if key.endswith("linefreq") or key in [item for sublist in line_witness_frequency_channel_list for item in sublist]:
		head_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		head_dict[key] = pipeparts.mkgeneric(pipeline, head_dict[key], "lal_property", update_when_change = True)
		for i in range(0, len(line_witness_frequency_channel_list)):
			if key in line_witness_frequency_channel_list[i]:
				j = line_witness_frequency_channel_list[i].index(key)
				line_witness_frequency_channel_list[i][j] = head_dict[key]
	elif key.endswith("line_corr_real") or key.endswith("line_corr_imag"):
		head_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		head_dict[key] = pipeparts.mkaudioamplify(pipeline, head_dict[key], pcal_sign)
		head_dict[key] = pipeparts.mkgeneric(pipeline, head_dict[key], "lal_property", update_when_change = True)
	elif key.startswith("EP6_") or key.startswith("EP11_"):
		C_epics_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		C_epics_dict[key] = calibration_parts.mkresample(pipeline, C_epics_dict[key], 0, False, compute_calib_factors_caps)
		C_epics_dict[key] = (pipeparts.mktee(pipeline, C_epics_dict[key]), float(filters[key]) if key in filters else numpy.inf)
	elif key.startswith("EP7_") or key.startswith("EP12_"):
		D_epics_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		D_epics_dict[key] = calibration_parts.mkresample(pipeline, D_epics_dict[key], 0, False, compute_calib_factors_caps)
		D_epics_dict[key] = (pipeparts.mktee(pipeline, D_epics_dict[key]), float(filters[key]) if key in filters else numpy.inf)
	elif key.startswith("EP1_") or key.startswith("EP2_") or key.startswith("EP15_") or key.startswith("EP22_"):
		misc_epics_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		misc_epics_dict[key] = calibration_parts.mkresample(pipeline, misc_epics_dict[key], 0, False, compute_calib_factors_caps)
		misc_epics_dict[key] = (pipeparts.mktee(pipeline, misc_epics_dict[key]), float(filters[key]) if key in filters else numpy.inf)
	elif key.startswith("EP"):
		A_epics_dict[key] = calibration_parts.caps_and_progress(pipeline, head_dict[key], ref_factors_caps, key)
		A_epics_dict[key] = calibration_parts.mkresample(pipeline, A_epics_dict[key], 0, False, compute_calib_factors_caps)
		A_epics_dict[key] = (pipeparts.mktee(pipeline, A_epics_dict[key]), float(filters[key]) if key in filters else numpy.inf)

if use_coherence:
	if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		pcaly_line1_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line1_coh"], coh_caps, "pcaly_line1_coh")
		pcaly_line1_coh = calibration_parts.mkresample(pipeline, pcaly_line1_coh, 0, False, compute_calib_factors_caps)
		pcaly_line1_coh = pipeparts.mktee(pipeline, pcaly_line1_coh)
	if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
		sus_line3_coh = calibration_parts.caps_and_progress(pipeline, head_dict["sus_line3_coh"], coh_caps, "sus_line3_coh")
		sus_line3_coh = calibration_parts.mkresample(pipeline, sus_line3_coh, 0, False, compute_calib_factors_caps)
		sus_line3_coh = pipeparts.mktee(pipeline, sus_line3_coh)
	if compute_kappapum or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
		sus_line2_coh = calibration_parts.caps_and_progress(pipeline, head_dict["sus_line2_coh"], coh_caps, "sus_line2_coh")
		sus_line2_coh = calibration_parts.mkresample(pipeline, sus_line2_coh, 0, False, compute_calib_factors_caps)
		sus_line2_coh = pipeparts.mktee(pipeline, sus_line2_coh)
	if compute_kappauim or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
		sus_line1_coh = calibration_parts.caps_and_progress(pipeline, head_dict["sus_line1_coh"], coh_caps, "sus_line1_coh")
		sus_line1_coh = calibration_parts.mkresample(pipeline, sus_line1_coh, 0, False, compute_calib_factors_caps)
		sus_line1_coh = pipeparts.mktee(pipeline, sus_line1_coh)
	if compute_kappapu:
		darm_coh = calibration_parts.caps_and_progress(pipeline, head_dict["darm_coh"], coh_caps, "darm_coh")
		darm_coh = calibration_parts.mkresample(pipeline, darm_coh, 0, False, compute_calib_factors_caps)
		darm_coh = pipeparts.mktee(pipeline, darm_coh)
	if compute_kappac or compute_fcc or compute_fs or compute_srcq:
		pcaly_line2_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line2_coh"], coh_caps, "pcaly_line2_coh")
		pcaly_line2_coh = calibration_parts.mkresample(pipeline, pcaly_line2_coh, 0, False, compute_calib_factors_caps)
		pcaly_line2_coh = pipeparts.mktee(pipeline, pcaly_line2_coh)
	if compute_fs or compute_srcq:
		if src_pcal_line_freq != act_pcal_line_freq:
			pcaly_line4_coh = calibration_parts.caps_and_progress(pipeline, head_dict["pcaly_line4_coh"], coh_caps, "pcaly_line4_coh")
			pcaly_line4_coh = calibration_parts.mkresample(pipeline, pcaly_line4_coh, 0, False, compute_calib_factors_caps)
			pcaly_line4_coh = pipeparts.mktee(pipeline, pcaly_line4_coh)
		else:
			pcaly_line4_coh = pcaly_line1_coh

if compute_kappatst or compute_exact_kappas or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq or (remove_cal_lines and "tstexc_linefreq" in act_line_removal_dict.keys()):
	tstexccaps = "audio/x-raw, format=F64LE, rate=%d" % tst_exc_sr
	tstexc = calibration_parts.caps_and_progress(pipeline, head_dict["tstexc"], tstexccaps, "tstexc")
	tstexc = pipeparts.mktee(pipeline, tstexc)
	# Check if we are also using the TST excitation channel as a witness for line subtraction
	for i in range(0, len(line_witness_channel_list)):
		for j in range(0, len(line_witness_channel_list[i])):
			if line_witness_channel_list[i][j] == ChannelNames["tstexcchannel"]:
				line_witness_channel_list[i][j] = tstexc
	if "tstexc_linefreq" in act_line_removal_dict:
		act_line_removal_dict["tstexc_linefreq"][0] = tstexc
if compute_kappapum or compute_exact_kappas or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)) or (remove_cal_lines and "pumexc_linefreq" in act_line_removal_dict.keys()):
	pumexccaps = "audio/x-raw, format=F64LE, rate=%d" % pum_exc_sr
	pumexc = calibration_parts.caps_and_progress(pipeline, head_dict["pumexc"], pumexccaps, "pumexc")
	pumexc = pipeparts.mktee(pipeline, pumexc)
	# Check if we are also using the PUM excitation channel as a witness for line subtraction
	for i in range(0, len(line_witness_channel_list)):
		for j in range(0, len(line_witness_channel_list[i])):
			if line_witness_channel_list[i][j] == ChannelNames["pumexcchannel"]:
				line_witness_channel_list[i][j] = pumexc
	if "pumexc_linefreq" in act_line_removal_dict:
		act_line_removal_dict["pumexc_linefreq"][0] = pumexc
if compute_kappauim or compute_exact_kappas or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)) or (remove_cal_lines and "uimexc_linefreq" in act_line_removal_dict.keys()):
	uimexccaps = "audio/x-raw, format=F64LE, rate=%d" % uim_exc_sr
	uimexc = calibration_parts.caps_and_progress(pipeline, head_dict["uimexc"], uimexccaps, "uimexc")
	uimexc = pipeparts.mktee(pipeline, uimexc)
	# Check if we are also using the UIM excitation channel as a witness for line subtraction
	for i in range(0, len(line_witness_channel_list)):
		for j in range(0, len(line_witness_channel_list[i])):
			if line_witness_channel_list[i][j] == ChannelNames["uimexcchannel"]:
				line_witness_channel_list[i][j] = uimexc
	if "uimexc_linefreq" in act_line_removal_dict:
		act_line_removal_dict["uimexc_linefreq"][0] = uimexc

if compute_kappapu:
	darmexc = calibration_parts.caps_and_progress(pipeline, head_dict["darmexc"], hoft_caps, "darmexc")

# Set up computations for kappa_tst, kappa_pum, kappa_uim, kappa_pu,kappa_c, f_cc, f_s, and Q, if applicable
if compute_exact_kappas and (compute_kappatst or compute_kappapum or compute_kappauim or compute_kappac or compute_fcc or compute_srcq or compute_fs):
	# Use the "exact" algebraic solution of P1900052, Section 5.2.6.
	# Do all the demodulation up front.  We need DARM_ERR and either Pcal or an actuator
	# injection channel at each calibration line frequency used for the TDCFs.  We will
	# also take the ratios injection(f) / DARM_ERR(f) at all the calibration lines and
	# apply the gating and smoothing here, before computing the TDCFs.

	# First, the actuation Pcal line, starting with DARM_ERR.
	derr_at_act_pcal_freq = calibration_parts.demodulate(pipeline, derrtee, act_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["pcal1_linefreq"] if "pcal1_linefreq" in head_dict else None)
	# Now Pcal
	pcal_at_act_pcal_freq = calibration_parts.demodulate(pipeline, pcaltee, act_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, prefactor_real = pcal_sign * pcal_corr_at_act_freq_real, prefactor_imag = pcal_sign * pcal_corr_at_act_freq_imag, freq_update = [head_dict["pcal1_linefreq"], head_dict["pcal1_line_corr_real"], head_dict["pcal1_line_corr_imag"]] if "pcal1_linefreq" in head_dict else None)
	pcal_at_act_pcal_freq = pipeparts.mktee(pipeline, pcal_at_act_pcal_freq)
	if remove_cal_lines:
		# This will save having to demodulate it again
		pcal_line_removal_dict["pcal1_linefreq"][0] = pcal_at_act_pcal_freq
		pcal_line_removal_dict["pcal1_linefreq"][4] = True

	# Take the ratio X1 = Pcal(f1) / DARM_ERR(f1)
	X1 = calibration_parts.complex_division(pipeline, pcal_at_act_pcal_freq, derr_at_act_pcal_freq)

	# Now the gating and smoothing
	if use_coherence:
		X1 = calibration_parts.mkgate(pipeline, X1, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'pcal_line1_gate')
		X1 = calibration_parts.smooth_complex_kappas(pipeline, X1, EP43_real, EP43_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)
	else:
		var = 0.2 * abs(EP43_real + 1j * EP43_imag)
		X1 = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, X1, var, var, EP43_real, EP43_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	# The sensing Pcal line (~400 Hz), starting with DARM_ERR.
	derr_at_opt_gain_freq = calibration_parts.demodulate(pipeline, derrtee, opt_gain_fcc_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["pcal2_linefreq"] if "pcal2_linefreq" in head_dict else None)
	# Now Pcal
	pcal_at_opt_gain_freq = calibration_parts.demodulate(pipeline, pcaltee, opt_gain_fcc_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, prefactor_real = pcal_sign * pcal_corr_at_opt_gain_fcc_freq_real, prefactor_imag = pcal_sign * pcal_corr_at_opt_gain_fcc_freq_imag, freq_update = [head_dict["pcal2_linefreq"], head_dict["pcal2_line_corr_real"], head_dict["pcal2_line_corr_imag"]] if "pcal2_linefreq" in head_dict else None)
	if remove_cal_lines:
		# This will save having to demodulate it again
		pcal_at_opt_gain_freq = pipeparts.mktee(pipeline, pcal_at_opt_gain_freq)
		pcal_line_removal_dict["pcal2_linefreq"][0] = pcal_at_opt_gain_freq
		pcal_line_removal_dict["pcal2_linefreq"][4] = True

	# Take the ratio X2 = Pcal(f2) / DARM_ERR(f2)
	X2 = calibration_parts.complex_division(pipeline, pcal_at_opt_gain_freq, derr_at_opt_gain_freq)

	# Now the gating and smoothing
	if use_coherence:
		X2 = calibration_parts.mkgate(pipeline, X2, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'pcal_line2_gate')
		X2 = calibration_parts.smooth_complex_kappas(pipeline, X2, EP44_real, EP44_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)
	else:
		var = 0.2 * abs(EP44_real + 1j * EP44_imag)
		X2 = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, X2, var, var, EP44_real, EP44_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	# Now the ESD/TST/L3 actuator line, starting with DARM_ERR.
	derr_at_esd_act_freq = calibration_parts.demodulate(pipeline, derrtee, esd_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["tstexc_linefreq"] if "tstexc_linefreq" in head_dict else None)
	# Now the TST excitation channel
	tstexc_at_esd_act_freq = calibration_parts.demodulate(pipeline, tstexc, esd_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["tstexc_linefreq"] if "tstexc_linefreq" in head_dict else None)
	if "tstexc_linefreq" in act_line_removal_dict.keys():
		tstexc_at_esd_act_freq = pipeparts.mktee(pipeline, tstexc_at_esd_act_freq)
		act_line_removal_dict["tstexc_linefreq"][0] = tstexc_at_esd_act_freq
		act_line_removal_dict["tstexc_linefreq"][4] = True

	# Take the ratio X_T = Pcal(f_T) / DARM_ERR(f_T)
	X_T = calibration_parts.complex_division(pipeline, tstexc_at_esd_act_freq, derr_at_esd_act_freq)

	# Now the gating and smoothing
	if use_coherence:
		X_T = calibration_parts.mkgate(pipeline, X_T, sus_line3_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'sus_line3_gate')
		X_T = calibration_parts.smooth_complex_kappas(pipeline, X_T, EP45_real, EP45_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)
	else:
		var = 0.2 * abs(EP45_real + 1j * EP45_imag)
		X_T = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, X_T, var, var, EP45_real, EP45_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	# Now the PUM/L2 actuator line, starting with DARM_ERR.
	derr_at_pum_act_freq = calibration_parts.demodulate(pipeline, derrtee, pum_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["pumexc_linefreq"] if "pumexc_linefreq" in head_dict else None)
	# Now the PUM excitation channel
	pumexc_at_pum_act_freq = calibration_parts.demodulate(pipeline, pumexc, pum_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["pumexc_linefreq"] if "pumexc_linefreq" in head_dict else None)
	if "pumexc_linefreq" in act_line_removal_dict.keys():
		pumexc_at_pum_act_freq = pipeparts.mktee(pipeline, pumexc_at_pum_act_freq)
		act_line_removal_dict["pumexc_linefreq"][0] = pumexc_at_pum_act_freq
		act_line_removal_dict["pumexc_linefreq"][4] = True

	# Take the ratio X_P = Pcal(f_P) / DARM_ERR(f_P)
	X_P = calibration_parts.complex_division(pipeline, pumexc_at_pum_act_freq, derr_at_pum_act_freq)

	# Now the gating and smoothing
	if use_coherence:
		X_P = calibration_parts.mkgate(pipeline, X_P, sus_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'sus_line2_gate')
		X_P = calibration_parts.smooth_complex_kappas(pipeline, X_P, EP46_real, EP46_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)
	else:
		var = 0.2 * abs(EP46_real + 1j * EP46_imag)
		X_P = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, X_P, var, var, EP46_real, EP46_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	# Now the UIM/L3 actuator line, starting with DARM_ERR.
	derr_at_uim_act_freq = calibration_parts.demodulate(pipeline, derrtee, uim_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["uimexc_linefreq"] if "uimexc_linefreq" in head_dict else None)
	# Now the UIM excitation channel
	uimexc_at_uim_act_freq = calibration_parts.demodulate(pipeline, uimexc, uim_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["uimexc_linefreq"] if "uimexc_linefreq" in head_dict else None)
	if "uimexc_linefreq" in act_line_removal_dict.keys():
		uimexc_at_uim_act_freq = pipeparts.mktee(pipeline, uimexc_at_uim_act_freq)
		act_line_removal_dict["uimexc_linefreq"][0] = uimexc_at_uim_act_freq
		act_line_removal_dict["uimexc_linefreq"][4] = True

	# Take the ratio X_U = Pcal(f_U) / DARM_ERR(f_U)
	X_U = calibration_parts.complex_division(pipeline, uimexc_at_uim_act_freq, derr_at_uim_act_freq)

	# Now the gating and smoothing
	if use_coherence:
		X_U = calibration_parts.mkgate(pipeline, X_U, sus_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'sus_line1_gate')
		X_U = calibration_parts.smooth_complex_kappas(pipeline, X_U, EP47_real, EP47_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)
	else:
		var = 0.2 * abs(EP47_real + 1j * EP47_imag)
		X_U = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, X_U, var, var, EP47_real, EP47_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	# Finally, compute the kappas
	if factors_from_filters_file:
		X_list = [X1, X2, X_T, X_P, X_U]
		freq_list = [act_pcal_line_freq, opt_gain_fcc_line_freq, esd_act_line_freq, pum_act_line_freq, uim_act_line_freq]
		EPICS_list = [EP11_real, EP11_imag, EP25_real, EP25_imag, EP26_real, EP26_imag, EP27_real, EP27_imag, EP6_real, EP6_imag, EP28_real, EP28_imag, EP29_real, EP29_imag, EP30_real, EP30_imag, EP31_real, EP31_imag, EP32_real, EP32_imag, EP33_real, EP33_imag, EP34_real, EP34_imag, EP35_real, EP35_imag, EP36_real, EP36_imag, EP37_real, EP37_imag, EP38_real, EP38_imag, EP39_real, EP39_imag, EP40_real, EP40_imag, EP41_real, EP41_imag, EP42_real, EP42_imag]

		[ktst, kpum, kuim, tau_tst, tau_pum, tau_uim, kc, fcc, fs_squared, fs_over_Q] = calibration_parts.compute_exact_kappas_from_filters_file(pipeline, X_list, freq_list, EPICS_list, compute_factors_sr)

	#else: use non-existent channels in the raw frames

	# A little bit of processing is necessary to ensure backwards compatibility
	if compute_kappatst:
		smooth_ktsttee = pipeparts.mktee(pipeline, calibration_parts.mkmultiplier(pipeline, [pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, ktst, matrix = [[1.0, 0.0]])), pipeparts.mkgeneric(pipeline, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, tau_tst, matrix = [[0.0, 2.0 * numpy.pi * esd_act_line_freq]])), "cexp")]))
		smooth_ktstR, smooth_ktstI = calibration_parts.split_into_real(pipeline, smooth_ktsttee)
		smooth_ktstRtee = pipeparts.mktee(pipeline, smooth_ktstR)
		smooth_ktstItee = pipeparts.mktee(pipeline, smooth_ktstI)
		smooth_ktstR_nogate = smooth_ktstRtee
		smooth_ktstI_nogate = smooth_ktstItee
	else:
		pipeparts.mkfakesink(pipeline, ktst)
		pipeparts.mkfakesink(pipeline, tau_tst)

	if compute_kappapum:
		smooth_kpumtee = pipeparts.mktee(pipeline, calibration_parts.mkmultiplier(pipeline, [pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, kpum, matrix = [[1.0, 0.0]])), pipeparts.mkgeneric(pipeline, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, tau_pum, matrix = [[0.0, 2.0 * numpy.pi * pum_act_line_freq]])), "cexp")]))
		smooth_kpumR, smooth_kpumI = calibration_parts.split_into_real(pipeline, smooth_kpumtee)
		smooth_kpumRtee = pipeparts.mktee(pipeline, smooth_kpumR)
		smooth_kpumItee = pipeparts.mktee(pipeline, smooth_kpumI)
		smooth_kpumR_nogate = smooth_kpumRtee
		smooth_kpumI_nogate = smooth_kpumItee
	else:
		pipeparts.mkfakesink(pipeline, kpum)
		pipeparts.mkfakesink(pipeline, tau_pum)

	if compute_kappauim:
		smooth_kuimtee = pipeparts.mktee(pipeline, calibration_parts.mkmultiplier(pipeline, [pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, kuim, matrix = [[1.0, 0.0]])), pipeparts.mkgeneric(pipeline, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, tau_uim, matrix = [[0.0, 2.0 * numpy.pi * uim_act_line_freq]])), "cexp")]))
		smooth_kuimR, smooth_kuimI = calibration_parts.split_into_real(pipeline, smooth_kuimtee)
		smooth_kuimRtee = pipeparts.mktee(pipeline, smooth_kuimR)
		smooth_kuimItee = pipeparts.mktee(pipeline, smooth_kuimI)
		smooth_kuimR_nogate = smooth_kuimRtee
		smooth_kuimI_nogate = smooth_kuimItee
	else:
		pipeparts.mkfakesink(pipeline, kuim)
		pipeparts.mkfakesink(pipeline, tau_uim)

	if compute_kappac:
		smooth_kctee = smooth_kc_nogate = pipeparts.mktee(pipeline, kc)
	else:
		pipeparts.mkfakesink(pipeline, kc)

	if compute_fcc:
		smooth_fcctee = smooth_fcc_nogate = pipeparts.mktee(pipeline, fcc)
	else:
		pipeparts.mkfakesink(pipeline, fcc)

	if compute_fs:
		smooth_fs_squared_nogate = smooth_fs_squared = pipeparts.mktee(pipeline, fs_squared)
	else:
		pipeparts.mkfakesink(pipeline, fs_squared)

	if compute_srcq:
		# fs / Q is a real-valued quantity, but fs and Q are not necessarily, so we compute a complex-valued 1/Q.
		smooth_srcQ_inv = pipeparts.mktee(pipeline, calibration_parts.mkmultiplier(pipeline, [pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, fs_over_Q, matrix = [[1.0, 0.0]])), calibration_parts.mkpow(pipeline, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, smooth_fs_squared, matrix = [[1.0, 0.0]])), exponent = -0.5)]))
		# We need a real-valued version of Q^(-1) to write the the frames.  If we have
		# an optical spring, the computed Q^(-1) is imaginary, and if we have an optical
		# antispring, the computed Q^(-1) is real.  To get a sensible real value either
		# way AND INCLUDE ANY MINUS SIGN, we use Re(Q^(-1)) + Im(Q^(-1)).
		smooth_srcQ_inv_real = smooth_srcQ_inv_nogate = pipeparts.mktee(pipeline, calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pipeparts.mkgeneric(pipeline, smooth_srcQ_inv, "creal"), pipeparts.mkgeneric(pipeline, smooth_srcQ_inv, "cimag"))))

	else:
		pipeparts.mkfakesink(pipeline, fs_over_Q)

elif compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_srcq or compute_fs:
	# Use the solution in T1700106.
	# demodulate the PCAL channel and apply the PCAL correction factor at the actuation Pcal line frequency
	pcal_at_act_pcal_freq = calibration_parts.demodulate(pipeline, pcaltee, act_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, prefactor_real = pcal_sign * pcal_corr_at_act_freq_real, prefactor_imag = pcal_sign * pcal_corr_at_act_freq_imag, freq_update = [head_dict["pcal1_linefreq"], head_dict["pcal1_line_corr_real"], head_dict["pcal1_line_corr_imag"]] if "pcal1_linefreq" in head_dict else None)
	pcal_at_act_pcal_freq = pipeparts.mktee(pipeline, pcal_at_act_pcal_freq)
	if remove_cal_lines:
		# This will save having to demodulate it again
		pcal_line_removal_dict["pcal1_linefreq"][0] = pcal_at_act_pcal_freq
		pcal_line_removal_dict["pcal1_linefreq"][4] = True

	# demodulate DARM_ERR at the actuation pcal line frequency
	derr_at_act_pcal_freq = calibration_parts.demodulate(pipeline, derrtee, act_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["pcal1_linefreq"] if "pcal1_linefreq" in head_dict else None)
	if dewhitening:
		# dewhiten DARM_ERR at the ~30 Hz pcal line frequency
		derr_at_act_pcal_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_act_pcal_freq, derr_dewhiten_at_darm_act_freq_real, derr_dewhiten_at_darm_act_freq_imag)
	derr_at_act_pcal_freq = pipeparts.mktee(pipeline, derr_at_act_pcal_freq)

	# demodulate the TST excitation channel at the ESD actuation line frequency
	tstexc_at_esd_act_freq = calibration_parts.demodulate(pipeline, tstexc, esd_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["tstexc_linefreq"] if "tstexc_linefreq" in head_dict else None)
	if "tstexc_linefreq" in act_line_removal_dict.keys():
		tstexc_at_esd_act_freq = pipeparts.mktee(pipeline, tstexc_at_esd_act_freq)
		act_line_removal_dict["tstexc_linefreq"][0] = tstexc_at_esd_act_freq
		act_line_removal_dict["tstexc_linefreq"][4] = True

	# demodulate DARM_ERR at the ESD actuation line frequency
	derr_at_esd_act_freq = calibration_parts.demodulate(pipeline, derrtee, esd_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["tstexc_linefreq"] if "tstexc_linefreq" in head_dict else None)
	if dewhitening:
		# dewhiten DARM_ERR at the ESD actuation line frequency
		derr_at_esd_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_esd_act_freq, derr_dewhiten_at_esd_act_freq_real, derr_dewhiten_at_esd_act_freq_imag)

	# compute kappa_tst, either using reference factors from the filters file or reading them from EPICS channels
	if not factors_from_filters_file:
		EP1 = calibration_parts.merge_into_complex(pipeline, misc_epics_dict["EP1_real"][0], misc_epics_dict["EP1_imag"][0])
		ktst = calibration_parts.compute_kappatst(pipeline, derr_at_esd_act_freq, tstexc_at_esd_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP1)
	elif factors_from_filters_file:
		ktst = calibration_parts.compute_kappatst_from_filters_file(pipeline, derr_at_esd_act_freq, tstexc_at_esd_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP1_real, EP1_imag)

	ktst = pipeparts.mktee(pipeline, ktst)

	# Now apply the gating and smoothing to \kappa_tst
	if compute_kappatst:
		smooth_ktst_nogate = pipeparts.mkgeneric(pipeline, ktst, "lal_smoothkappas", default_kappa_re = expected_kappatst_real, default_kappa_im = expected_kappatst_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)
		smooth_ktstR_nogate, smooth_ktstI_nogate = calibration_parts.split_into_real(pipeline, smooth_ktst_nogate)

		if use_coherence:
			# Gate kappa_tst with the coherence of the PCALY_line1 line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'ktstgate1')
			# Gate kappa_tst with the coherence of the TST (L3) suspension line
			ktst_gated = calibration_parts.mkgate(pipeline, ktst_gated, sus_line3_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'ktstgate2')

			# Smooth kappa_tst
			smooth_ktst = calibration_parts.smooth_complex_kappas(pipeline, ktst_gated, expected_kappatst_real, expected_kappatst_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		else:
			# Smooth kappa_tst
			smooth_ktst = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, ktst, kappatst_real_var, kappatst_imag_var, expected_kappatst_real, expected_kappatst_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		smooth_ktsttee = pipeparts.mktee(pipeline, smooth_ktst)
		smooth_ktstR, smooth_ktstI = calibration_parts.split_into_real(pipeline, smooth_ktsttee)

		smooth_ktstRtee = pipeparts.mktee(pipeline, smooth_ktstR)
		smooth_ktstItee = pipeparts.mktee(pipeline, smooth_ktstI)

		if "tstexc_linefreq" in act_line_removal_dict.keys():
			if apply_complex_kappatst:
				act_line_removal_dict["tstexc_linefreq"][7] = smooth_ktsttee
			elif apply_kappatst:
				act_line_removal_dict["tstexc_linefreq"][7] = smooth_ktstRtee

# Check if we need to compute kappa_pum
if not compute_exact_kappas and (compute_kappapum or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq))):
	# demodulate the PUM excitation channel at the PUM actuation line frequency
	pumexc_at_pum_act_freq = calibration_parts.demodulate(pipeline, pumexc, pum_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["pumexc_linefreq"] if "pumexc_linefreq" in head_dict else None)
	if "pumexc_linefreq" in act_line_removal_dict.keys():
		pumexc_at_pum_act_freq = pipeparts.mktee(pipeline, pumexc_at_pum_act_freq)
		act_line_removal_dict["pumexc_linefreq"][0] = pumexc_at_pum_act_freq
		act_line_removal_dict["pumexc_linefreq"][4] = True

	# demodulate DARM_ERR at the PUM actuation line frequency
	derr_at_pum_act_freq = calibration_parts.demodulate(pipeline, derrtee, pum_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["pumexc_linefreq"] if "pumexc_linefreq" in head_dict else None)

	# Compute kappa_pum, either using reference factors from the filters file or reading them from EPICS channels
	if not factors_from_filters_file:
		EP15 = calibration_parts.merge_into_complex(pipeline, misc_epics_dict["EP15_real"][0], misc_epics_dict["EP15_imag"][0])
		kpum = calibration_parts.compute_kappapum(pipeline, derr_at_pum_act_freq, pumexc_at_pum_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP15)
	else:
		kpum = calibration_parts.compute_kappapum_from_filters_file(pipeline, derr_at_pum_act_freq, pumexc_at_pum_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP15_real, EP15_imag)

	kpum = pipeparts.mktee(pipeline, kpum)

	# Now apply the gating and smoothing to kappa_pum
	if compute_kappapum:
		smooth_kpum_nogate = pipeparts.mkgeneric(pipeline, kpum, "lal_smoothkappas", default_kappa_re = expected_kappapum_real, default_kappa_im = expected_kappapum_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)
		smooth_kpumR_nogate, smooth_kpumI_nogate = calibration_parts.split_into_real(pipeline, smooth_kpum_nogate)

		if use_coherence:
			# Gate kappa_pum with the coherence of the PCALY_line1 line
			kpum_gated = calibration_parts.mkgate(pipeline, kpum, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kpumgate1')
			# Gate kappa_pum with the coherence of the PUM (L2) suspension line
			kpum_gated = calibration_parts.mkgate(pipeline, kpum_gated, sus_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kpumgate2')

			# Smooth kappa_pum
			smooth_kpum = calibration_parts.smooth_complex_kappas(pipeline, kpum_gated, expected_kappapum_real, expected_kappapum_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		else:
			# Smooth kappa_pum
			smooth_kpum = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, kpum, kappapum_real_var, kappapum_imag_var, expected_kappapum_real, expected_kappapum_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		smooth_kpumtee = pipeparts.mktee(pipeline, smooth_kpum)
		smooth_kpumR, smooth_kpumI = calibration_parts.split_into_real(pipeline, smooth_kpumtee)

		smooth_kpumRtee = pipeparts.mktee(pipeline, smooth_kpumR)
		smooth_kpumItee = pipeparts.mktee(pipeline, smooth_kpumI)

		if "pumexc_linefreq" in act_line_removal_dict.keys():
			if apply_complex_kappapum:
				act_line_removal_dict["pumexc_linefreq"][7] = smooth_kpumtee
			elif apply_kappapum:
				act_line_removal_dict["pumexc_linefreq"][7] = smooth_kpumRtee

# Check if we need to compute kappa_uim
if not compute_exact_kappas and (compute_kappauim or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq))):
	# Demodulate DARM_ERR and the UIM excitation channel at the UIM actuation line frequency
	derr_at_uim_act_freq = calibration_parts.demodulate(pipeline, derrtee, uim_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["uimexc_linefreq"] if "uimexc_linefreq" in head_dict else None)
	uimexc_at_uim_act_freq = calibration_parts.demodulate(pipeline, uimexc, uim_act_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["uimexc_linefreq"] if "uimexc_linefreq" in head_dict else None)
	if "uimexc_linefreq" in act_line_removal_dict.keys():
		uimexc_at_uim_act_freq = pipeparts.mktee(pipeline, uimexc_at_uim_act_freq)
		act_line_removal_dict["uimexc_linefreq"][0] = uimexc_at_uim_act_freq
		act_line_removal_dict["uimexc_linefreq"][4] = True

	# Compute kappa_uim, either using reference factors from the filters file or reading them from EPICS channels
	if not factors_from_filters_file:
		EP22 = calibration_parts.merge_into_complex(pipeline, misc_epics_dict["EP22_real"][0], misc_epics_dict["EP22_imag"][0])
		kuim = calibration_parts.compute_kappauim_uim_line(pipeline, derr_at_uim_act_freq, uimexc_at_uim_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP22)
	else:
		kuim = calibration_parts.compute_kappauim_from_filters_file_uim_line(pipeline, derr_at_uim_act_freq, uimexc_at_uim_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP22_real, EP22_imag)

	kuim = pipeparts.mktee(pipeline, kuim)

	# Now apply the gating and smoothing to kappa_uim
	if compute_kappauim:
		smooth_kuim_nogate = pipeparts.mkgeneric(pipeline, kuim, "lal_smoothkappas", default_kappa_re = expected_kappauim_real, default_kappa_im = expected_kappauim_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)
		smooth_kuimR_nogate, smooth_kuimI_nogate = calibration_parts.split_into_real(pipeline, smooth_kuim_nogate)

		if use_coherence:
			# Gate kappa_uim with the coherence of the PCALY_line1 line
			kuim_gated = calibration_parts.mkgate(pipeline, kuim, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kuimgate1')
			# Gate kappa_uim with the coherence of the UIM (L1) suspension line
			kuim_gated = calibration_parts.mkgate(pipeline, kuim_gated, sus_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kuimgate2')

			# Smooth kappa_uim
			smooth_kuim = calibration_parts.smooth_complex_kappas(pipeline, kuim_gated, expected_kappauim_real, expected_kappauim_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		else:
			# Smooth kappa_uim
			smooth_kuim = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, kuim, kappauim_real_var, kappauim_imag_var, expected_kappauim_real, expected_kappauim_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		smooth_kuimtee = pipeparts.mktee(pipeline, smooth_kuim)
		smooth_kuimR, smooth_kuimI = calibration_parts.split_into_real(pipeline, smooth_kuimtee)

		smooth_kuimRtee = pipeparts.mktee(pipeline, smooth_kuimR)
		smooth_kuimItee = pipeparts.mktee(pipeline, smooth_kuimI)

		if "uimexc_linefreq" in act_line_removal_dict.keys():
			if apply_complex_kappauim:
				act_line_removal_dict["uimexc_linefreq"][7] = smooth_kuimtee
			elif apply_kappauim:
				act_line_removal_dict["uimexc_linefreq"][7] = smooth_kuimRtee

# Check if we need to compute kappa_PU
if compute_kappapu:
	# demodulate excitation channel at darm actuation line frequency
	darmexc_at_darm_act_freq = calibration_parts.demodulate(pipeline, darmexc, darm_ctrl_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["darmexc_linefreq"] if "darmexc_linefreq" in head_dict else None)

	# demodulate DARM_ERR at the darm actuation line frequency
	derr_at_darm_act_freq = calibration_parts.demodulate(pipeline, derrtee, darm_ctrl_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["darmexc_linefreq"] if "darmexc_linefreq" in head_dict else None)
	if dewhitening:
		# dewhiten DARM_ERR at the darm actuation line frequency
		derr_at_darm_act_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_darm_act_freq, derr_dewhiten_at_pu_act_freq_real, derr_dewhiten_at_pu_act_freq_imag)

	# compute the factor A(fctrl) that will be used in the computation of kappa_pu, either using reference factors from the filters file or reading them from EPICS channels
	if not factors_from_filters_file:
		EP2 = calibration_parts.merge_into_complex(pipeline, misc_epics_dict["EP2_real"][0], misc_epics_dict["EP2_imag"][0])
		EP3 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP3_real"][0], A_epics_dict["EP3_imag"][0])
		EP4 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP4_real"][0], A_epics_dict["EP4_imag"][0])
		afctrl = calibration_parts.compute_afctrl(pipeline, derr_at_darm_act_freq, darmexc_at_darm_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP2)
		kpu = calibration_parts.compute_kappapu(pipeline, EP3, afctrl, ktst, EP4)
	else:
		afctrl = calibration_parts.compute_afctrl_from_filters_file(pipeline, derr_at_darm_act_freq, darmexc_at_darm_act_freq, pcal_at_act_pcal_freq, derr_at_act_pcal_freq, EP2_real, EP2_imag)
		kpu = calibration_parts.compute_kappapu_from_filters_file(pipeline, EP3_real, EP3_imag, afctrl, ktst, EP4_real, EP4_imag)

	kpu = pipeparts.mktee(pipeline, kpu)

	# Now apply the gating and smoothing to \kappa_pu
	smooth_kpu_nogate = pipeparts.mkgeneric(pipeline, kpu, "lal_smoothkappas", default_kappa_re = expected_kappapu_real, default_kappa_im = expected_kappapu_imag, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)
	smooth_kpuR_nogate, smooth_kpuI_nogate = calibration_parts.split_into_real(pipeline, smooth_kpu_nogate)

	if use_coherence:
		# Gate kappa_pu with the coherence of the DARM line
		kpu_gated = calibration_parts.mkgate(pipeline, kpu, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kpugate1')
		# Gate kappa_pu with the coherence of the PCALY_line1 line
		kpu_gated = calibration_parts.mkgate(pipeline, kpu_gated, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kpugate2')
		# Gate kappa_pu with the coherence of the suspension coherence
		kpu_gated = calibration_parts.mkgate(pipeline, kpu_gated, sus_line3_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kpugate3')
		# Smooth kappa_pu
		smooth_kpu = calibration_parts.smooth_complex_kappas(pipeline, kpu_gated, expected_kappapu_real, expected_kappapu_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	else:
		# Smooth kappa_pu
		smooth_kpu = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, kpu, kappapu_real_var, kappapu_imag_var, expected_kappapu_real, expected_kappapu_imag, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	smooth_kputee = pipeparts.mktee(pipeline, smooth_kpu)
	smooth_kpuR, smooth_kpuI = calibration_parts.split_into_real(pipeline, smooth_kputee)

	smooth_kpuRtee = pipeparts.mktee(pipeline, smooth_kpuR)
	smooth_kpuItee = pipeparts.mktee(pipeline, smooth_kpuI)	

# Compute \kappa_c and f_cc
if not compute_exact_kappas and (compute_kappac or compute_fcc or compute_fs or compute_srcq):
	# demodulate the PCAL channel and apply the PCAL correction factor at optical gain and f_cc line frequency
	pcal_at_opt_gain_freq = calibration_parts.demodulate(pipeline, pcaltee, opt_gain_fcc_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, prefactor_real = pcal_sign * pcal_corr_at_opt_gain_fcc_freq_real, prefactor_imag = pcal_sign * pcal_corr_at_opt_gain_fcc_freq_imag, freq_update = [head_dict["pcal2_linefreq"], head_dict["pcal2_line_corr_real"], head_dict["pcal2_line_corr_imag"]] if "pcal2_linefreq" in head_dict else None)
	if remove_cal_lines:
		# This will save having to demodulate it again
		pcal_at_opt_gain_freq = pipeparts.mktee(pipeline, pcal_at_opt_gain_freq)
		pcal_line_removal_dict["pcal2_linefreq"][0] = pcal_at_opt_gain_freq
		pcal_line_removal_dict["pcal2_linefreq"][4] = True

	# demodulate DARM_ERR at optical gain and f_cc line frequency
	derr_at_opt_gain_freq = calibration_parts.demodulate(pipeline, derrtee, opt_gain_fcc_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["pcal2_linefreq"] if "pcal2_linefreq" in head_dict else None)
	if dewhitening:
		# dewhiten DARM_ERR at optical gain and f_cc line frequency
		derr_at_opt_gain_freq = calibration_parts.complex_audioamplify(pipeline, derr_at_opt_gain_freq, derr_dewhiten_at_opt_gain_fcc_freq_real, derr_dewhiten_at_opt_gain_fcc_freq_imag)

	# Compute the factor S which will be used for the kappa_c and f_cc calculations
	# Tha actuation kappas need to be evaluated at the higher pcal line frequency
	ktst_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, ktst, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / esd_act_line_freq)
	if not factors_from_filters_file:
		EP6 = calibration_parts.merge_into_complex(pipeline, C_epics_dict["EP6_real"][0], C_epics_dict["EP6_imag"][0])
		EP7 = calibration_parts.merge_into_complex(pipeline, D_epics_dict["EP7_real"][0], D_epics_dict["EP7_imag"][0])
		EP8 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP8_real"][0], A_epics_dict["EP8_imag"][0])
		if not compute_kappapu:
			kpum_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kpum, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / pum_act_line_freq)
			kuim_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kuim, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / uim_act_line_freq)
			EP18 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP18_real"][0], A_epics_dict["EP18_imag"][0])
			EP19 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP19_real"][0], A_epics_dict["EP19_imag"][0])
			S = calibration_parts.compute_S_split_act(pipeline, EP6, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7, ktst_at_opt_gain_freq, EP8, kpum_at_opt_gain_freq, EP18, kuim_at_opt_gain_freq, EP19)
		else:
			kpu_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kpu, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / darm_ctrl_line_freq)
			EP9 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP9_real"][0], A_epics_dict["EP9_imag"][0])
			S = calibration_parts.compute_S(pipeline, EP6, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7, ktst_at_opt_gain_freq, EP8, kpu_at_opt_gain_freq, EP9)

	else:
		if not compute_kappapu:
			kpum_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kpum, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / pum_act_line_freq)
			kuim_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kuim, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / uim_act_line_freq)
			S = calibration_parts.compute_S_from_filters_file_split_act(pipeline, EP6_real, EP6_imag, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7_real, EP7_imag, ktst_at_opt_gain_freq, EP8_real, EP8_imag, kpum_at_opt_gain_freq, EP18_real, EP18_imag, kuim_at_opt_gain_freq, EP19_real, EP19_imag)
		else:
			kpu_at_opt_gain_freq = pipeparts.mkgeneric(pipeline, kpu, "lpshiftfreq", frequency_ratio = opt_gain_fcc_line_freq / darm_ctrl_line_freq)
			S = calibration_parts.compute_S_from_filters_file(pipeline, EP6_real, EP6_imag, pcal_at_opt_gain_freq, derr_at_opt_gain_freq, EP7_real, EP7_imag, ktst_at_opt_gain_freq, EP8_real, EP8_imag, kpu_at_opt_gain_freq, EP9_real, EP9_imag)

	S = pipeparts.mktee(pipeline, S)

	SR, SI = calibration_parts.split_into_real(pipeline, S)

	if compute_kappac and compute_fcc:
		SR = pipeparts.mktee(pipeline, SR)
		SI = pipeparts.mktee(pipeline, SI)

	# compute kappa_c
	if compute_kappac or compute_srcq or compute_fs:
		kc = calibration_parts.compute_kappac(pipeline, SR, SI)
	if compute_kappac:
		kc = pipeparts.mktee(pipeline, kc)
		smooth_kc_nogate = pipeparts.mkgeneric(pipeline, kc, "lal_smoothkappas", default_kappa_re = expected_kappac, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)

		if use_coherence:
			# Gate kappa_c with the coherence of all of the calibration lines used to compute it
			kc_gated = calibration_parts.mkgate(pipeline, kc, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kcgate1')
			kc_gated = calibration_parts.mkgate(pipeline, kc_gated, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kcgate2')
			if compute_kappapu:
				kc_gated = calibration_parts.mkgate(pipeline, kc_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kcgate3')
			else:
				kc_gated = calibration_parts.mkgate(pipeline, kc_gated, sus_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kcgate4')
				kc_gated = calibration_parts.mkgate(pipeline, kc_gated, sus_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kcgate5')
				kc_gated = calibration_parts.mkgate(pipeline, kc_gated, sus_line3_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'kcgate6')

			# Smooth kappa_c
			smooth_kc = calibration_parts.smooth_kappas(pipeline, kc_gated, expected_kappac, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		else:
			# Smooth kappa_c
			smooth_kc = calibration_parts.smooth_kappas_no_coherence(pipeline, kc, kappac_var, expected_kappac, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

		smooth_kctee = pipeparts.mktee(pipeline, smooth_kc)

	# compute f_cc
	if compute_fcc or compute_srcq or compute_fs:
		fcc = calibration_parts.compute_fcc(pipeline, SR, SI, opt_gain_fcc_line_freq, freq_update = head_dict["pcal2_linefreq"] if "pcal2_linefreq" in head_dict else None)
	if compute_fcc:
		fcc = pipeparts.mktee(pipeline, fcc)
		smooth_fcc_nogate = pipeparts.mkgeneric(pipeline, fcc, "lal_smoothkappas", default_kappa_re = fcc_default, array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)

		if use_coherence:
			# Gate f_cc with all four of the calibration lines
			fcc_gated = calibration_parts.mkgate(pipeline, fcc, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'fccgate1')
			fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'fccgate2')
			if compute_kappapu:
				fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'fccgate3')
			else:
				fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, sus_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'fccgate4')
				fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, sus_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'fccgate5')
				fcc_gated = calibration_parts.mkgate(pipeline, fcc_gated, sus_line3_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True, name = 'fccgate6')

			# Smooth f_cc
			smooth_fcc = calibration_parts.smooth_kappas(pipeline, fcc_gated, fcc_default, median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)
		else:
			# Smooth f_cc
			smooth_fcc = calibration_parts.smooth_kappas_no_coherence(pipeline, fcc, fcc_var, fcc_default, median_smoothing_samples, factors_average_samples, kappas_default_to_median, filter_latency_factor)

		smooth_fcctee = pipeparts.mktee(pipeline, smooth_fcc)

#		if apply_fcc:
#			update_fcc = calibration_parts.mkfccupdate(pipeline, smooth_fcctee, data_rate = hoft_sr, fcc_rate = compute_factors_sr, fcc_model = fcc_default, averaging_time = float(TDCFConfigs["fccaveragingtime"]), filter_duration = float(TDCFConfigs["fccfilterduration"]))
#			pipeparts.mkfakesink(pipeline, update_fcc)

# compute f_s and Q
if not compute_exact_kappas and (compute_fs or compute_srcq):
	expected_Xi = complex((fs_squared_default - 1j * src_pcal_line_freq * fs_default / srcQ_default) / (src_pcal_line_freq * src_pcal_line_freq))
	Xi_real_var = float((pow(abs(fs_default) + fs_var, 2.0) - pow(abs(fs_default), 2.0)) / pow(src_pcal_line_freq, 2))
	Xi_imag_var = float(fs_var / (abs(srcQ_default) * src_pcal_line_freq))

	# demodulate PCAL channel and apply the PCAL correction factor at SRC detuning line frequency
	if src_pcal_line_freq == act_pcal_line_freq:
		pcal_at_src_freq = pcal_at_act_pcal_freq
	else:
		pcal_at_src_freq = calibration_parts.demodulate(pipeline, pcaltee, src_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, prefactor_real = pcal_sign * pcal_corr_at_src_freq_real, prefactor_imag = pcal_sign * pcal_corr_at_src_freq_imag, freq_update = [head_dict["pcal4_linefreq"], head_dict["pcal4_line_corr_real"], head_dict["pcal4_line_corr_imag"]] if "pcal4_linefreq" in head_dict else None)
		pcal_at_src_freq = pipeparts.mktee(pipeline, pcal_at_src_freq)
		if "pcal4_linefreq" in pcal_line_removal_dict:
			# This will save having to demodulate it again
			pcal_line_removal_dict["pcal4_linefreq"][0] = pcal_at_src_freq
			pcal_line_removal_dict["pcal4_linefreq"][4] = True

	# demodulate DARM_ERR at SRC detuning line frequency
	if src_pcal_line_freq == act_pcal_line_freq:
		derr_at_src_freq = derr_at_act_pcal_freq
	else:
		derr_at_src_freq = calibration_parts.demodulate(pipeline, derrtee, src_pcal_line_freq, td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict["pcal4_linefreq"] if "pcal4_linefreq" in head_dict else None)

	# Compute the factor Xi which will be used for the f_s and src_Q calculations
	# The actuation kappas need to be evaluated at the SRC pcal line frequency
	ktst_at_src_freq = pipeparts.mkgeneric(pipeline, ktst, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / esd_act_line_freq)
	if not factors_from_filters_file:
		EP11 = calibration_parts.merge_into_complex(pipeline, C_epics_dict["EP11_real"][0], C_epics_dict["EP11_imag"][0])
		EP12 = calibration_parts.merge_into_complex(pipeline, D_epics_dict["EP12_real"][0], D_epics_dict["EP12_imag"][0])
		EP13 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP13_real"][0], A_epics_dict["EP13_imag"][0])
		if not compute_kappapu:
			kpum_at_src_freq = pipeparts.mkgeneric(pipeline, kpum, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / pum_act_line_freq)
			kuim_at_src_freq = pipeparts.mkgeneric(pipeline, kuim, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / uim_act_line_freq)
			EP20 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP20_real"][0], A_epics_dict["EP20_imag"][0])
			EP21 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP21_real"][0], A_epics_dict["EP21_imag"][0])
			Xi = calibration_parts.compute_Xi_split_act(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11, EP12, EP13, EP20, EP21, ktst_at_src_freq, kpum_at_src_freq, kuim_at_src_freq, kc, fcc)
		else:
			kpu_at_src_freq = pipeparts.mkgeneric(pipeline, kpu, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / darm_ctrl_line_freq)
			EP14 = calibration_parts.merge_into_complex(pipeline, A_epics_dict["EP14_real"][0], A_epics_dict["EP14_imag"][0])
			Xi = calibration_parts.compute_Xi(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11, EP12, EP13, EP14, ktst_at_src_freq, kpu_at_src_freq, kc, fcc)
	else:
		if not compute_kappapu:
			kpum_at_src_freq = pipeparts.mkgeneric(pipeline, kpum, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / pum_act_line_freq)
			kuim_at_src_freq = pipeparts.mkgeneric(pipeline, kuim, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / uim_act_line_freq)
			Xi = calibration_parts.compute_Xi_from_filters_file_split_act(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11_real, EP11_imag, EP12_real, EP12_imag, EP13_real, EP13_imag, EP20_real, EP20_imag, EP21_real, EP21_imag, ktst_at_src_freq, kpum_at_src_freq, kuim_at_src_freq, kc, fcc)
		else:
			kpu_at_src_freq = pipeparts.mkgeneric(pipeline, kpu, "lpshiftfreq", frequency_ratio = src_pcal_line_freq / darm_ctrl_line_freq)
			Xi = calibration_parts.compute_Xi_from_filters_file(pipeline, pcal_at_src_freq, derr_at_src_freq, src_pcal_line_freq, EP11_real, EP11_imag, EP12_real, EP12_imag, EP13_real, EP13_imag, EP14_real, EP14_imag, ktst_at_src_freq, kpu_at_src_freq, kc, fcc)

	Xi = pipeparts.mktee(pipeline, Xi)
	smooth_Xi_nogate = pipeparts.mkgeneric(pipeline, Xi, "lal_smoothkappas", default_kappa_re = float(numpy.real(expected_Xi)), default_kappa_im = float(numpy.imag(expected_Xi)), array_size = median_smoothing_samples, avg_array_size = factors_average_samples, default_to_median = tdcf_default_to_median, filter_latency = filter_latency_factor)

	if use_coherence:
		# Gate Xi with all coherences. We apply the gating and smoothing here since Q depends on the inverse of Im(Xi), which fluctuates about zero.
		Xi_gated = calibration_parts.mkgate(pipeline, Xi, pcaly_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, pcaly_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, pcaly_line4_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, sus_line3_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		if compute_kappapu:
			Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, darm_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
		else:
			Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, sus_line1_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)
			Xi_gated = calibration_parts.mkgate(pipeline, Xi_gated, sus_line2_coh, coherence_unc_threshold, attack_length = kappa_gate_attack_length, hold_length = kappa_gate_hold_length, invert_control = True)

		smooth_Xi = calibration_parts.smooth_complex_kappas(pipeline, Xi_gated, float(numpy.real(expected_Xi)), float(numpy.imag(expected_Xi)), median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	else:
		smooth_Xi = calibration_parts.smooth_complex_kappas_no_coherence(pipeline, Xi, Xi_real_var, Xi_real_var, float(numpy.real(expected_Xi)), float(numpy.imag(expected_Xi)), median_smoothing_samples, factors_average_samples, tdcf_default_to_median, filter_latency_factor)

	if not compute_srcq:
		# the imaginary part is only used to compute Q
		smooth_XiR = pipeparts.mkgeneric(pipeline, smooth_Xi, "creal")
		smooth_XiR_nogate = pipeparts.mkgeneric(pipeline, smooth_Xi_nogate, "creal")
	else:
		smooth_XiR, smooth_XiI = calibration_parts.split_into_real(pipeline, smooth_Xi)
		smooth_XiR_nogate, smooth_XiI_nogate = calibration_parts.split_into_real(pipeline, smooth_Xi_nogate)

	if compute_fs and compute_srcq:
		smooth_XiR = pipeparts.mktee(pipeline, smooth_XiR)
		smooth_XiR_nogate = pipeparts.mktee(pipeline, smooth_XiR_nogate)

	# compute f_s
	if compute_fs:
		smooth_fs_squared_almost = pipeparts.mkaudioamplify(pipeline, smooth_XiR, src_pcal_line_freq)
		smooth_fs_squared = pipeparts.mkaudioamplify(pipeline, smooth_fs_squared_almost, src_pcal_line_freq)
		smooth_fs_squared_almost_nogate = pipeparts.mkaudioamplify(pipeline, smooth_XiR_nogate, src_pcal_line_freq)
		smooth_fs_squared_nogate = pipeparts.mkaudioamplify(pipeline, smooth_fs_squared_almost_nogate, src_pcal_line_freq)
		if src_pcal_line_freq == act_pcal_line_freq and "pcal1_linefreq" in head_dict:
			head_dict["pcal1_linefreq"].connect("notify::timestamped-average", calibration_parts.update_timestamped_property, smooth_fs_squared_almost, "timestamped_average", "amplification", 1)
			head_dict["pcal1_linefreq"].connect("notify::timestamped-average", calibration_parts.update_timestamped_property, smooth_fs_squared, "timestamped_average", "amplification", 1)
			head_dict["pcal1_linefreq"].connect("notify::timestamped-average", calibration_parts.update_timestamped_property, smooth_fs_squared_almost_nogate, "timestamped_average", "amplification", 1)
			head_dict["pcal1_linefreq"].connect("notify::timestamped-average", calibration_parts.update_timestamped_property, smooth_fs_squared_nogate, "timestamped_average", "amplification", 1)
		elif src_pcal_line_freq != act_pcal_line_freq and "pcal4_linefreq" in head_dict:
			head_dict["pcal4_linefreq"].connect("notify::timestamped-average", calibration_parts.update_timestamped_property, smooth_fs_squared_almost, "timestamped_average", "amplification", 1)
			head_dict["pcal4_linefreq"].connect("notify::timestamped-average", calibration_parts.update_timestamped_property, smooth_fs_squared, "timestamped_average", "amplification", 1)
			head_dict["pcal4_linefreq"].connect("notify::timestamped-average", calibration_parts.update_timestamped_property, smooth_fs_squared_almost_nogate, "timestamped_average", "amplification", 1)
			head_dict["pcal4_linefreq"].connect("notify::timestamped-average", calibration_parts.update_timestamped_property, smooth_fs_squared_nogate, "timestamped_average", "amplification", 1)

		smooth_fs_squared = pipeparts.mktee(pipeline, smooth_fs_squared)

	# compute SRC Q_inv
	if compute_srcq:
		smooth_sqrtXiR_inv = calibration_parts.mkpow(pipeline, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, smooth_XiR, matrix = [[1.0, 0.0]])), exponent = -0.5)
		smooth_sqrtXiR_inv_nogate = calibration_parts.mkpow(pipeline, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, smooth_XiR_nogate, matrix = [[1.0, 0.0]])), exponent = -0.5)
		smooth_srcQ_inv = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, smooth_sqrtXiR_inv, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, smooth_XiI, matrix = [[-1.0, 0.0]]))))
		smooth_srcQ_inv_nogate = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, smooth_sqrtXiR_inv_nogate, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, smooth_XiI_nogate, matrix = [[-1.0, 0.0]]))))

		smooth_srcQ_inv = pipeparts.mktee(pipeline, smooth_srcQ_inv)
		smooth_srcQ_inv_nogate = pipeparts.mktee(pipeline, smooth_srcQ_inv_nogate)

		# We need a real-valued version of Q^(-1) to write the the frames.  If we have
		# an optical spring, the computed Q^(-1) is imaginary, and if we have an optical
		# antispring, the computed Q^(-1) is real.  To get a sensible real value either
		# way AND INCLUDE ANY MINUS SIGN, we use Re(Q^(-1)) + Im(Q^(-1)).
		smooth_srcQ_inv_real = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pipeparts.mkgeneric(pipeline, smooth_srcQ_inv, "creal"), pipeparts.mkgeneric(pipeline, smooth_srcQ_inv, "cimag")))
		smooth_srcQ_inv_nogate = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pipeparts.mkgeneric(pipeline, smooth_srcQ_inv_nogate, "creal"), pipeparts.mkgeneric(pipeline, smooth_srcQ_inv_nogate, "cimag")))

		smooth_srcQ_inv_real = pipeparts.mktee(pipeline, smooth_srcQ_inv_real)

#
# TIME-VARYING FACTORS COMPENSATIONS
#

if apply_complex_kappatst:
	# We will apply an adaptive FIR filter to the TST component of the actuation that includes time-dependence in the gain and computational time delay
	adaptive_tst_filter = calibration_parts.mkadaptivefirfilt(pipeline, smooth_ktsttee, static_model = tstfilt_model, static_filter = tstfilt, update_samples = int(actuation_filter_update_time * compute_factors_sr), average_samples = int(actuation_filter_averaging_time * compute_factors_sr), phase_measurement_frequency = esd_act_line_freq, adaptive_filter_length = len(tstfilt), frequency_resolution = act_freq_res, window_type = act_window_type, filter_sample_rate = tstchainsr, filter_timeshift = 1000000000 * actuation_filter_update_time, name = "adaptive_tst_filter")

if apply_complex_kappapum:
	# We will apply an adaptive FIR filter to the PUM component of the actuation that includes time-dependence in the gain and computational time delay
	adaptive_pum_filter = calibration_parts.mkadaptivefirfilt(pipeline, smooth_kpumtee, static_model = pumfilt_model, static_filter = pumfilt, update_samples = int(actuation_filter_update_time * compute_factors_sr), average_samples = int(actuation_filter_averaging_time * compute_factors_sr), phase_measurement_frequency = esd_act_line_freq, adaptive_filter_length = len(pumfilt), frequency_resolution = act_freq_res, window_type = act_window_type, filter_sample_rate = pumchainsr, filter_timeshift = 1000000000 * actuation_filter_update_time, name = "adaptive_pum_filter")

if apply_complex_kappauim:
	# We will apply an adaptive FIR filter to the UIM component of the actuation that includes time-dependence in the gain and computational time delay
	adaptive_uim_filter = calibration_parts.mkadaptivefirfilt(pipeline, smooth_kuimtee, static_model = uimfilt_model, static_filter = uimfilt, update_samples = int(actuation_filter_update_time * compute_factors_sr), average_samples = int(actuation_filter_averaging_time * compute_factors_sr), phase_measurement_frequency = esd_act_line_freq, adaptive_filter_length = len(uimfilt), frequency_resolution = act_freq_res, window_type = act_window_type, filter_sample_rate = uimchainsr, filter_timeshift = 1000000000 * actuation_filter_update_time, name = "adaptive_uim_filter")

if apply_complex_kappapu:
	# We will apply an adaptive FIR filter to the PUM/UIM component of the actuation that includes time-dependence in the gain and computational time delay
	adaptive_pumuim_filter = calibration_parts.mkadaptivefirfilt(pipeline, smooth_kputee, static_model = pumuimfilt_model, static_filter = pumuimfilt, update_samples = int(actuation_filter_update_time * compute_factors_sr), average_samples = int(actuation_filter_averaging_time * compute_factors_sr), phase_measurement_frequency = darm_ctrl_line_freq, adaptive_filter_length = len(pumuimfilt), frequency_resolution = act_freq_res, window_type = act_window_type, filter_sample_rate = pumuimchainsr, filter_timeshift = 1000000000 * actuation_filter_update_time, name = "adaptive_pumuim_filter")

if apply_fcc or apply_fs or apply_srcq:
	# We will apply an adaptive FIR filter to DARM_ERR that allows corrections for poles, zeros, and gain
	# We need to track the number of time-dependent and static zeros and poles in the adaptive filter
	variable_invsens_zeros = 0
	static_invsens_poles = []
	tdep_zpk = []
	if apply_fcc:
		variable_invsens_zeros += 1
		# The real part of the pole is 0.0, and fcc_default is the imaginary part
		static_invsens_poles.extend([fcc_default, 0.0])

		# (1 + i * f / f_cc) is a zero in the variable inverse sensing filter
		complex_fcc = pipeparts.mkmatrixmixer(pipeline, smooth_fcctee, matrix = [[1.0, 0.0]])
		complex_fcc = pipeparts.mktogglecomplex(pipeline, complex_fcc)

		tdep_zpk.append(complex_fcc)

	# There are two zeros that depend on fs and Q, both of which depend on both fs and Q
	if apply_fs or apply_srcq:
		variable_invsens_zeros += 2
		SRC_pole1 = (fs_default / 2.0) * (pow(srcQ_default, -1.0) + pow(pow(srcQ_default, -2.0) + 4.0, 0.5))
		SRC_pole2 = (fs_default / 2.0) * (pow(srcQ_default, -1.0) - pow(pow(srcQ_default, -2.0) + 4.0, 0.5))
		static_invsens_poles.extend([numpy.real(SRC_pole1), numpy.imag(SRC_pole1)])
		static_invsens_poles.extend([numpy.real(SRC_pole2), numpy.imag(SRC_pole2)])

		smooth_fs = calibration_parts.mkpow(pipeline, pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, smooth_fs_squared, matrix = [[1.0, 0.0]])), exponent = 0.5)
		smooth_fs = pipeparts.mktee(pipeline, smooth_fs)

	if apply_fs and apply_srcq:
		# The variable zeros depend on the computed values of fs and Q
		Q_inv_squared = calibration_parts.mkpow(pipeline, smooth_srcQ_inv, exponent = 2.0)
		sqrt_Q_inv_squared_plus4 = calibration_parts.mkpow(pipeline, pipeparts.mkgeneric(pipeline, Q_inv_squared, "lal_add_constant", value = 4.0), exponent = 0.5)
		sqrt_Q_inv_squared_plus4 = pipeparts.mktee(pipeline, sqrt_Q_inv_squared_plus4)

		SRC_zero1 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, sqrt_Q_inv_squared_plus4))
		SRC_zero1 = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, SRC_zero1, smooth_fs))
		SRC_zero1 = calibration_parts.complex_audioamplify(pipeline, SRC_zero1, 0.5, 0.0)

		SRC_zero2 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, calibration_parts.complex_audioamplify(pipeline, sqrt_Q_inv_squared_plus4, -1.0, 0.0)))
		SRC_zero2 = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, SRC_zero2, smooth_fs))
		SRC_zero2 = calibration_parts.complex_audioamplify(pipeline, SRC_zero2, 0.5, 0.0)

		tdep_zpk.extend([SRC_zero1, SRC_zero2])

		# This will be added into tdep_zpk at the end, as required by lal_adaptivefirfilt
		variable_invsens_gain = pipeparts.mkaudioamplify(pipeline, smooth_fs_squared, pow(fs_squared_default, -1.0))

	elif apply_fs:
		# The variable zeros depend on the computed value of fs and the model value of Q
		Q_factor1 = (pow(srcQ_default, -1.0) + pow(pow(srcQ_default, -2.0) + 4.0, 0.5)) / 2.0
		Q_factor2 = (pow(srcQ_default, -1.0) - pow(pow(srcQ_default, -2.0) + 4.0, 0.5)) / 2.0

		SRC_zero1 = calibration_parts.complex_audioamplify(pipeline, smooth_fs, numpy.real(Q_factor1), numpy.imag(Q_factor1))
		SRC_zero2 = calibration_parts.complex_audioamplify(pipeline, smooth_fs, numpy.real(Q_factor2), numpy.imag(Q_factor2))

		tdep_zpk.extend([SRC_zero1, SRC_zero2])

		# This will be added into tdep_zpk at the end, as required by lal_adaptivefirfilt
		variable_invsens_gain = pipeparts.mkaudioamplify(pipeline, smooth_fs_squared, pow(fs_squared_default, -1.0))

	elif apply_srcq:
		# The variable zeros depend on the model value of fs and the computed value of Q
		Q_inv_squared = calibration_parts.mkpow(pipeline, smooth_srcQ_inv, exponent = 2.0)
		sqrt_Q_inv_squared_plus4 = calibration_parts.mkpow(pipeline, pipeparts.mkgeneric(pipeline, Q_inv_squared, "lal_add_constant", value = 4.0), exponent = 0.5)
		sqrt_Q_inv_squared_plus4 = pipeparts.mktee(pipeline, sqrt_Q_inv_squared_plus4)

		SRC_zero1 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, sqrt_Q_inv_squared_plus4))
		SRC_zero1 = calibration_parts.complex_audioamplify(pipeline, SRC_zero1, 0.5 * numpy.real(fs_default), 0.5 * numpy.imag(fs_default))

		SRC_zero2 = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, smooth_srcQ_inv, calibration_parts.complex_audioamplify(pipeline, sqrt_Q_inv_squared_plus4, -1.0, 0.0)))
		SRC_zero2 = calibration_parts.complex_audioamplify(pipeline, SRC_zero2, 0.5 * numpy.real(fs_default), 0.5 * numpy.imag(fs_default))

		tdep_zpk.extend([SRC_zero1, SRC_zero2])

	if apply_kappac:
		# We divide the gain by kappa_c
		kappac_inv = calibration_parts.mkpow(pipeline, smooth_kctee, exponent = -1.0)
		if apply_fs:
			variable_invsens_gain = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, variable_invsens_gain, kappac_inv))
		else:
			variable_invsens_gain = kappac_inv

	if apply_kappac or apply_fs:
		# Now add the gain into the list of corrections
		variable_invsens_gain = pipeparts.mkmatrixmixer(pipeline, variable_invsens_gain, matrix = [[1.0, 0.0]])
		variable_invsens_gain = pipeparts.mktogglecomplex(pipeline, variable_invsens_gain)
		tdep_zpk.append(variable_invsens_gain)

	# Now interleave the correction channels in tdep_zpk and feed them into lal_adaptivefirfilt to update the inverse sensing filter
	tdep_zpk = calibration_parts.mkinterleave(pipeline, tdep_zpk, complex_data = True)
	if minimize_adaptive_sensfilt:
		adaptive_invsens_filter = calibration_parts.mkadaptivefirfilt(pipeline, tdep_zpk, update_samples = int(sensing_filter_update_time * compute_factors_sr), average_samples = int(sensing_filter_averaging_time * compute_factors_sr), num_zeros = variable_invsens_zeros, num_poles = 0, window_type = None, filter_sample_rate = hoft_sr, filter_timeshift = 1000000000 * sensing_filter_update_time, minimize_filter_length = True, name = "adaptive_invsens_filter")
	else:
		adaptive_invsens_filter = calibration_parts.mkadaptivefirfilt(pipeline, tdep_zpk, static_model = reschainfilt_model, static_filter = reschainfilt, static_poles = static_invsens_poles, update_samples = int(sensing_filter_update_time * compute_factors_sr), average_samples = int(sensing_filter_averaging_time * compute_factors_sr), num_zeros = variable_invsens_zeros, num_poles = 0, adaptive_filter_length = len(reschainfilt), frequency_resolution = invsens_freq_res, window_type = invsens_window_type, filter_sample_rate = hoft_sr, filter_timeshift = 1000000000 * sensing_filter_update_time, minimize_filter_length = False, name = "adaptive_invsens_filter")

#
# CONTROL BRANCH
#

# zero out filter settling samples
tst_filter_settle_time = 0.0
tst_filter_latency = 0.0
pum_filter_settle_time = 0.0
pum_filter_latency = 0.0
uim_filter_settle_time = 0.0
uim_filter_latency = 0.0
pumuim_filter_settle_time = 0.0
pumuim_filter_latency = 0.0

actsr = max(tstchainsr, pumchainsr, uimchainsr) if (apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim) else max (tstchainsr, pumuimchainsr)

pum_uim_separate = apply_kappapum or apply_kappauim or apply_complex_kappapum or apply_complex_kappauim or (CalibrationConfigs["calibrationmode"] == "Partial" and ("UIM_corr_filter" in filters or "PUM_corr_filter" in filters))

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank
if CalibrationConfigs["calibrationmode"] == "Partial":
	# enforce caps on actuation channels and set up progress report if verbose is on
	tst = calibration_parts.caps_and_progress(pipeline, head_dict["tst"], ctrl_caps, "tst")
	tsttee = pipeparts.mktee(pipeline, tst)
	pum = calibration_parts.caps_and_progress(pipeline, head_dict["pum"], ctrl_caps, "pum")
	pumtee = pipeparts.mktee(pipeline, pum)
	uim = calibration_parts.caps_and_progress(pipeline, head_dict["uim"], ctrl_caps, "uim")
	uimtee = pipeparts.mktee(pipeline, uim)

	# If processing the PUM and UIM actuation channels together, add them here
	if not pum_uim_separate:
		pumuim = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, pumtee, uimtee))

	# if you need to, dewhiten the TST and PUM/UIM chains
	if dewhitening:
		tst = calibration_parts.mkresample(pipeline, tsttee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % tstdewhitensr) 
		tst = pipeparts.mkfirbank(pipeline, tst, latency = int(tstdewhitendelay), fir_matrix = [tstdewhiten[::-1]], time_domain = td)
		tst_filter_settle_time += float(len(tstdewhiten)-tstdewhitendelay)/tstdewhitensr
		tst_filter_latency += float(tstdewhitendelay)/tstdewhitensr
		if pum_uim_separate:
			pum = calibration_parts.mkresample(pipeline, pum, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumdewhitensr)
			pum = pipeparts.mkfirbank(pipeline, pum, latency = int(pumdewhitendelay), fir_matrix = [pumdewhiten[::-1]], time_domain = td)
			pum_filter_settle_time += float(len(pumdewhiten)-pumdewhitendelay)/pumdewhitensr
			pum_filter_latency += float(pumdewhitendelay)/pumdewhitensr
			uim = calibration_parts.mkresample(pipeline, uim, 5, False, "audio/x-raw, format=F64LE, rate=%d" % uimdewhitensr)
			uim = pipeparts.mkfirbank(pipeline, uim, latency = int(uimdewhitendelay), fir_matrix = [uimdewhiten[::-1]], time_domain = td)
			uim_filter_settle_time += float(len(uimdewhiten)-uimdewhitendelay)/uimdewhitensr
			uim_filter_latency += float(uimdewhitendelay)/uimdewhitensr
		else:
			pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumuimdewhitensr)
			pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = int(pumuimdewhitendelay), fir_matrix = [pumuimdewhiten[::-1]], time_domain = td)
			pumuim_filter_settle_time += float(len(pumuimdewhiten)-pumuimdewhitendelay)/pumuimdewhitensr
			pumuim_filter_latency += float(pumuimdewhitendelay)/pumuimdewhitensr
	else:
		tst = tsttee

if CalibrationConfigs["calibrationmode"] == "Full":
	# enforce caps on actuation channels and set up progress report, if verbose is on
	ctrl = calibration_parts.caps_and_progress(pipeline, head_dict["ctrl"], hoft_caps, "ctrl")
	darmctrltee = pipeparts.mktee(pipeline, ctrl)
	
	if dewhitening:
		# dewhiten the DARM_CTRL channel
		ctrl = calibration_parts.mkresample(pipeline, darmctrltee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % ctrldewhitensr)
		ctrl = pipeparts.mkfirbank(pipeline, ctrl, latency = int(ctrldewhitendelay), fir_matrix = [ctrldewhiten[::-1]], time_domain = td)
		tst_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
		tst_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
		if pum_uim_separate:
			pum_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
			pum_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
			uim_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
			uim_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
		else:
			pumuim_filter_settle_time += float(len(ctrldewhiten)-ctrldewhitendelay)/ctrldewhitensr
			pumuim_filter_latency += float(ctrldewhitendelay)/ctrldewhitensr
		# tee DARM_CTRL, which will be filtered with PUM, UIM, and TST filters separately
		ctrltee = pipeparts.mktee(pipeline, ctrl)
	else:
		ctrltee = darmctrltee
	tst = ctrltee
	pumtee = ctrltee
	uimtee = ctrltee
	pumuim = ctrltee

elif test_filters:
	ctrl = calibration_parts.caps_and_progress(pipeline, head_dict["ctrl"], hoft_caps, "ctrl")
	if dewhitening:
		ctrl = calibration_parts.mkresample(pipeline, darmctrltee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % ctrldewhitensr)
		ctrl = pipeparts.mkfirbank(pipeline, ctrl, latency = int(ctrldewhitendelay), fir_matrix = [ctrldewhiten[::-1]], time_domain = td)
	ctrltee = pipeparts.mktee(pipeline, ctrl)	

# resample what will become the TST actuation chain to the TST FIR filter sample rate
tst = calibration_parts.mkresample(pipeline, tst, 5, False, "audio/x-raw, format=F64LE, rate=%d" %  tstchainsr)
# Remove any DC component
if remove_dc:
	tst = calibration_parts.removeDC(pipeline, tst, tstchainsr)
# High-pass filter the TST chain
if any(act_highpass):
	tst = pipeparts.mkfirbank(pipeline, tst, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td)
	tst_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/tstchainsr
	tst_filter_latency += float(act_highpass_delay)/tstchainsr

if apply_complex_kappatst and filter_latency_factor == 0:
	# Apply an adaptive filter to include the time-dependence in the gain and the time delay.  Apply updates as soon as possible with minimal latency.
	tst = pipeparts.mkgeneric(pipeline, tst, "lal_tdwhiten", kernel = tstfilt[::-1], latency = tstdelay, taper_length = actuation_filter_taper_length, name = "TST_filter")
	# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
	adaptive_tst_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, tst, "adaptive_filter", "kernel")
elif apply_complex_kappatst:
	# Apply an adaptive filter to include the time-dependence in the gain and the time delay.  Apply updates at fixed timestamps to ensure reproducibility.
	tst = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, tst), "lal_tdwhiten", kernel = tstfilt[::-1], latency = tstdelay, taper_length = actuation_filter_taper_length, kernel_endtime = 0, name = "TST_filter")
	# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
	adaptive_tst_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, tst, "adaptive_filter", "kernel")
	adaptive_tst_filter.connect("notify::filter-endtime", calibration_parts.update_property_simple, tst, "filter_endtime", "kernel_endtime", 1)

else:
	# Filter the TST chain with the static TST actuation filter
	tst = pipeparts.mkfirbank(pipeline, tst, latency = tstdelay, fir_matrix = [tstfilt[::-1]], time_domain = td)

tst_filter_settle_time += float(len(tstfilt)-tstdelay)/tstchainsr
tst_filter_latency += float(tstdelay)/tstchainsr

if apply_kappatst and not apply_complex_kappatst:
	# Apply only the real part of \kappa_tst as a correction to A_tst
	ktst_for_tst = calibration_parts.mkresample(pipeline, smooth_ktstRtee, 3, False, tstchainsr)
	tst = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, ktst_for_tst, tst))

# If we want, measure the transfer function applied by the TST filter(s)
if test_filters:
	tst = pipeparts.mktee(pipeline, tst)
	tst_tf = calibration_parts.mkinterleave(pipeline, [tst, calibration_parts.mkresample(pipeline, ctrltee, 5, False, tstchainsr)])
	tst_tf_delay = tst_filter_settle_time + ((1.0 - filter_latency_factor) * (demodulation_filter_time + (median_smoothing_samples + factors_average_samples) / compute_factors_sr) + actuation_filter_update_time if apply_complex_kappatst else 0)
	tst_tf_start = start + tst_tf_delay
	tst_tf_dur = gps_end_time - tst_tf_start - tst_filter_latency - 10 if InputConfigs["datasource"] == "frames" else 300
	tst_tf_dur = tst_tf_dur - (tst_tf_dur + 8) % 16
	num_tst_ffts = int(tst_tf_dur / 8)
	tst_tf = pipeparts.mkprogressreport(pipeline, tst_tf, "progress_tst_tf_%s" % instrument)
	calibration_parts.mktransferfunction(pipeline, tst_tf, fft_length = 16 * tstchainsr, fft_overlap = 8 * tstchainsr, num_ffts = num_tst_ffts, use_median = True, update_samples = 1e15, update_delay_samples = tst_tf_delay * tstchainsr, filename = "%s_tst_filters_transfer_function_%d-%d.txt" % (filters_name.split('/')[-1].replace('.', '_'), tst_tf_start, tst_tf_dur), name = "tst_filters_tf", use_fir_fft = True, fft_window_type = 3)

# resample the TST actuation chain if necessary
if tstchainsr < actsr:
	tst = calibration_parts.mkresample(pipeline, tst, 4, False, actsr)

# Check whether we need to filter the PUM and UIM stages separately or together
if pum_uim_separate:
	# resample what will become the PUM and UIM actuation paths to the PUM and UIM FIR filter sample rates
	pum = calibration_parts.mkresample(pipeline, pumtee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumchainsr)
	uim = calibration_parts.mkresample(pipeline, uimtee, 5, False, "audio/x-raw, format=F64LE, rate=%d" % uimchainsr)
	# Remove any DC component
	if remove_dc:
		pum = calibration_parts.removeDC(pipeline, pum, pumchainsr)
		uim = calibration_parts.removeDC(pipeline, uim, uimchainsr)
	# High-pass filter the PUM and UIM paths
	if any(act_highpass):
		pum = pipeparts.mkfirbank(pipeline, pum, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td)
		pum_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/pumchainsr
		pum_filter_latency += float(act_highpass_delay)/pumchainsr
		uim = pipeparts.mkfirbank(pipeline, uim, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td) 
		uim_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/uimchainsr
		uim_filter_latency += float(act_highpass_delay)/uimchainsr

	if apply_complex_kappapum and filter_latency_factor == 0:
		# Apply an adaptive filter to include the time-dependence in the gain and the time delay.  Apply updates as soon as possible with minimal latency.
		pum = pipeparts.mkgeneric(pipeline, pum, "lal_tdwhiten", kernel = pumfilt[::-1], latency = pumdelay, taper_length = actuation_filter_taper_length, name = "PUM_filter")
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_pum_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, pum, "adaptive_filter", "kernel")
	elif apply_complex_kappapum:
		# Apply an adaptive filter to include the time-dependence in the gain and the time delay.  Apply updates at fixed timestamps to ensure reproducibility.
		pum = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, pum), "lal_tdwhiten", kernel = pumfilt[::-1], latency = pumdelay, taper_length = actuation_filter_taper_length, kernel_endtime = 0, name = "PUM_filter")
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_pum_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, pum, "adaptive_filter", "kernel")
		adaptive_pum_filter.connect("notify::filter-endtime", calibration_parts.update_property_simple, pum, "filter_endtime", "kernel_endtime", 1)

	else:
		# Filter the PUM chain with the static PUM actuation filter
		pum = pipeparts.mkfirbank(pipeline, pum, latency = pumdelay, fir_matrix = [pumfilt[::-1]], time_domain = td)

	pum_filter_settle_time += float(len(pumfilt)-pumdelay)/pumchainsr
	pum_filter_latency += float(pumdelay)/pumchainsr

	if apply_kappapum and not apply_complex_kappapum:
		# Apply only the real part of kappa_pum as a correction to A_pum
		kpum_for_pum = calibration_parts.mkresample(pipeline, smooth_kpumRtee, 3, False, pumchainsr)
		pum = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, kpum_for_pum, pum))

	# If we want, measure the transfer function applied by the PUM filter(s)
	if test_filters:
		pum = pipeparts.mktee(pipeline, pum)
		pum_tf = calibration_parts.mkinterleave(pipeline, [pum, calibration_parts.mkresample(pipeline, ctrltee, 5, False, pumchainsr)])
		pum_tf_delay = pum_filter_settle_time + ((1.0 - filter_latency_factor) * (demodulation_filter_time + (median_smoothing_samples + factors_average_samples) / compute_factors_sr) + actuation_filter_update_time if apply_complex_kappapum else 0)
		pum_tf_start = start + pum_tf_delay
		pum_tf_dur = gps_end_time - pum_tf_start - pum_filter_latency - 10 if InputConfigs["datasource"] == "frames" else 300
		pum_tf_dur = pum_tf_dur - (pum_tf_dur + 8) % 16
		num_pum_ffts = int(pum_tf_dur / 8)
		pum_tf = pipeparts.mkprogressreport(pipeline, pum_tf, "progress_pum_tf_%s" % instrument)
		calibration_parts.mktransferfunction(pipeline, pum_tf, fft_length = 16 * pumchainsr, fft_overlap = 8 * pumchainsr, num_ffts = num_pum_ffts, use_median = True, update_samples = 1e15, update_delay_samples = pum_tf_delay * pumchainsr, filename = "%s_pum_filters_transfer_function_%d-%d.txt" % (filters_name.split('/')[-1].replace('.', '_'), pum_tf_start, pum_tf_dur), name = "pum_filters_tf", use_fir_fft = True, fft_window_type = 3)

	if apply_complex_kappauim and filter_latency_factor == 0:
		# Apply an adaptive filter to include the time-dependence in the gain and the time delay.  Apply updates as soon as possible with minimal latency.
		uim = pipeparts.mkgeneric(pipeline, uim, "lal_tdwhiten", kernel = uimfilt[::-1], latency = uimdelay, taper_length = actuation_filter_taper_length, name = "UIM_filter")
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_uim_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, uim, "adaptive_filter", "kernel")
	elif apply_complex_kappauim:
		# Apply an adaptive filter to include the time-dependence in the gain and the time delay.  Apply updates at fixed timestamps to ensure reproducibility.
		uim = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, uim), "lal_tdwhiten", kernel = uimfilt[::-1], latency = uimdelay, taper_length = actuation_filter_taper_length, kernel_endtime = 0, name = "UIM_filter")
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_uim_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, uim, "adaptive_filter", "kernel")
		adaptive_uim_filter.connect("notify::filter-endtime", calibration_parts.update_property_simple, uim, "filter_endtime", "kernel_endtime", 1)

	else:
		# Filter the UIM chain with the static UIM actuation filter
		uim = pipeparts.mkfirbank(pipeline, uim, latency = uimdelay, fir_matrix = [uimfilt[::-1]], time_domain = td)

	uim_filter_settle_time += float(len(uimfilt)-uimdelay)/uimchainsr
	uim_filter_latency += float(uimdelay)/uimchainsr

	if apply_kappauim and not apply_complex_kappauim:
		# Apply only the real part of kappa_uim as a correction to A_uim
		kuim_for_uim = calibration_parts.mkresample(pipeline, smooth_kuimRtee, 3, False, uimchainsr)
		uim = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, kuim_for_uim, uim))

	# If we want, measure the transfer function applied by the UIM filter(s)
	if test_filters:
		uim = pipeparts.mktee(pipeline, uim)
		uim_tf = calibration_parts.mkinterleave(pipeline, [uim, calibration_parts.mkresample(pipeline, ctrltee, 5, False, uimchainsr)])
		uim_tf_delay = uim_filter_settle_time + ((1.0 - filter_latency_factor) * (demodulation_filter_time + (median_smoothing_samples + factors_average_samples) / compute_factors_sr) + actuation_filter_update_time if apply_complex_kappauim else 0)
		uim_tf_start = start + uim_tf_delay
		uim_tf_dur = gps_end_time - uim_tf_start - uim_filter_latency - 10 if InputConfigs["datasource"] == "frames" else 300
		uim_tf_dur = uim_tf_dur - (uim_tf_dur + 8) % 16
		num_uim_ffts = int(uim_tf_dur / 8)
		uim_tf = pipeparts.mkprogressreport(pipeline, uim_tf, "progress_uim_tf_%s" % instrument)
		calibration_parts.mktransferfunction(pipeline, uim_tf, fft_length = 16 * uimchainsr, fft_overlap = 8 * uimchainsr, num_ffts = num_uim_ffts, use_median = True, update_samples = 1e15, update_delay_samples = uim_tf_delay * uimchainsr, filename = "%s_uim_filters_transfer_function_%d-%d.txt" % (filters_name.split('/')[-1].replace('.', '_'), uim_tf_start, uim_tf_dur), name = "uim_filters_tf", use_fir_fft = True, fft_window_type = 3)

	# resample the PUM actuation path if necessary
	if pumchainsr < actsr:
		pum = calibration_parts.mkresample(pipeline, pum, 4, False, actsr)

	# resample the UIM actuation path if necessary
	if uimchainsr < actsr:
		uim = calibration_parts.mkresample(pipeline, uim, 4, False, actsr)

	# Add the TST, PUM, and UIM paths together to form the full actuation path
	ctrl = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, tst, pum, uim))
else:
	# resample what will become the PUM/UIM actuation chain to the PUM/UIM FIR filter sample rate
	pumuim = calibration_parts.mkresample(pipeline, pumuim, 5, False, "audio/x-raw, format=F64LE, rate=%d" % pumuimchainsr)
	# Remove any DC component
	if remove_dc:
		pumuim = calibration_parts.removeDC(pipeline, pumuim, pumuimchainsr)
	# High-pass filter the PUM/UIM path
	if any(act_highpass):
		pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = act_highpass_delay, fir_matrix = [act_highpass[::-1]], time_domain = td)
		pumuim_filter_settle_time += float(len(act_highpass)-act_highpass_delay)/pumuimchainsr
		pumuim_filter_latency += float(act_highpass_delay)/pumuimchainsr

	if apply_complex_kappapu and filter_latency_factor == 0:
		# Apply an adaptive filter to include the time-dependence in the gain and the time delay.  Apply updates as soon as possible with minimal latency.
		pumuim = pipeparts.mkgeneric(pipeline, pumuim, "lal_tdwhiten", kernel = pumuimfilt[::-1], latency = pumuimdelay, taper_length = actuation_filter_taper_length, name = "PUMUIM_filter")
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_pumuim_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, pumuim, "adaptive_filter", "kernel")
	elif apply_complex_kappapu:
		# Apply an adaptive filter to include the time-dependence in the gain and the time delay.  Apply updates at fixed timestamps to ensure reproducibility.
		pumuim = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, pumuim), "lal_tdwhiten", kernel = pumuimfilt[::-1], latency = pumuimdelay, taper_length = actuation_filter_taper_length, kernel_endtime = 0, name = "PUMUIM_filter")
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_pumuim_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, pumuim, "adaptive_filter", "kernel")
		adaptive_pumuim_filter.connect("notify::filter-endtime", calibration_parts.update_property_simple, pumuim, "filter_endtime", "kernel_endtime", 1)

	else:
		# Filter the PUM/UIM chain with the static PUM/UIM actuation filter
		pumuim = pipeparts.mkfirbank(pipeline, pumuim, latency = pumuimdelay, fir_matrix = [pumuimfilt[::-1]], time_domain = td)

	pumuim_filter_settle_time += float(len(pumuimfilt)-pumuimdelay)/pumuimchainsr
	pumuim_filter_latency += float(pumuimdelay)/pumuimchainsr

	if apply_kappapu and not apply_complex_kappapu:
		# Apply only the real part of kappa_pu as a correction to A_pu
		kpu_for_pu = calibration_parts.mkresample(pipeline, smooth_kpuRtee, 3, False, pumuimchainsr)
		pumuim = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, kpu_for_pu, pumuim))

	# If we want, measure the transfer function applied by the PUM/UIM filter(s)
	if test_filters:
		pumuim = pipeparts.mktee(pipeline, pumuim)
		pumuim_tf = calibration_parts.mkinterleave(pipeline, [pumuim, calibration_parts.mkresample(pipeline, ctrltee, 5, False, pumuimchainsr)])
		pumuim_tf_delay = pumuim_filter_settle_time + ((1.0 - filter_latency_factor) * (demodulation_filter_time + (median_smoothing_samples + factors_average_samples) / compute_factors_sr) + actuation_filter_update_time if apply_complex_kappapu else 0)
		pumuim_tf_start = start + pumuim_tf_delay
		pumuim_tf_dur = gps_end_time - pumuim_tf_start - pumuim_filter_latency - 10 if InputConfigs["datasource"] == "frames" else 300
		pumuim_tf_dur = pumuim_tf_dur - (pumuim_tf_dur + 8) % 16
		num_pumuim_ffts = int(pumuim_tf_dur / 8)
		pumuim_tf = pipeparts.mkprogressreport(pipeline, pumuim_tf, "progress_pumuim_tf_%s" % instrument)
		calibration_parts.mktransferfunction(pipeline, pumuim_tf, fft_length = 16 * pumuimchainsr, fft_overlap = 8 * pumuimchainsr, num_ffts = num_pumuim_ffts, use_median = True, update_samples = 1e15, update_delay_samples = pumuim_tf_delay * pumuimchainsr, filename = "%s_pumuim_filters_transfer_function_%d-%d.txt" % (filters_name.split('/')[-1].replace('.', '_'), pumuim_tf_start, pumuim_tf_dur), name = "pumuim_filters_tf", use_fir_fft = True, fft_window_type = 3)

	# resample the PUM/UIM actuation chain if necessary
	if pumuimchainsr < actsr:
		pumuim = calibration_parts.mkresample(pipeline, pumuim, 4, False, actsr)

	# Add the TST and PUM/UIM chains together to form the full actuation chain
	ctrl = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, tst, pumuim))

# Resample \DeltaL_ctrl to the full h(t) sample rate
if actsr != hoft_sr:
	ctrl = calibration_parts.mkresample(pipeline, ctrl, 4, False, hoft_caps)

if (test_latency or InputConfigs["datasource"] == "lvshm"):
	ctrl = pipeparts.mktee(pipeline, ctrl)
	ctrl_latency = calibration_parts.mkresample(pipeline, ctrl, 0, False, latency_metrics_caps) 
	ctrl_latency = pipeparts.mklatency(pipeline, ctrl_latency, name = "%s_ctrl" % OutputConfigs["frametype"], silent = silent)
	if kafka_server is not None:
		ctrl_latency.connect("notify::current-latency", handler.latency_new_buffer)
	pipeparts.mkfakesink(pipeline, ctrl_latency)

#
# RESIDUAL BRANCH
#

# zero out res filter settle time
res_filter_settle_time = 0.0
res_filter_latency = 0.0

# The reverse of the filters will be used in all filtering below due to the definition of the filtering procedure employed by lal_firbank

# enforce caps on the residual branch and hook up progress report if verbose is on
if CalibrationConfigs["calibrationmode"] == "Full":
	res = restee = derrtee
elif CalibrationConfigs["calibrationmode"] == "Partial":
	res = calibration_parts.caps_and_progress(pipeline, head_dict["res"], hoft_caps, "res")
	res = restee = pipeparts.mktee(pipeline, res)

# Remove any DC component
if remove_dc:
	res = calibration_parts.removeDC(pipeline, res, hoft_sr)

# High-pass filter the residual chain
if any(invsens_highpass):
	if invsens_highpass_sr != hoft_sr:
		# Magic trick to apply a high-pass filter to the inverse sensing path at a lower sample rate without losing information above the Nyquist frequency.
		res = pipeparts.mktee(pipeline, res)
		res_lowfreq = calibration_parts.mkresample(pipeline, res, 4, False, invsens_highpass_sr)
		# Use spectral inversion to make a low-pass filter with a gain of -1.
		invsens_highpass[invsens_highpass_delay] = invsens_highpass[invsens_highpass_delay] - 1.0
		# Apply this filter to the inverse sensing path at a lower sample rate to get only the low frequency components
		res_lowfreq = pipeparts.mkfirbank(pipeline, res_lowfreq, latency = invsens_highpass_delay, fir_matrix = [invsens_highpass[::-1]], time_domain = td)
		# Upsample
		res_lowfreq = calibration_parts.mkresample(pipeline, res_lowfreq, 4, False, hoft_sr)
		# Add to the inverse sensing path to get rid of the low frequencies
		res = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, res, res_lowfreq))
	else:
		# Apply the high-pass filter at the h(t) sample rate
		res = pipeparts.mkfirbank(pipeline, res, latency = invsens_highpass_delay, fir_matrix = [invsens_highpass[::-1]], time_domain = td)
	res_filter_settle_time += float(len(invsens_highpass)-invsens_highpass_delay) / invsens_highpass_sr
	res_filter_latency += float(invsens_highpass_delay) / invsens_highpass_sr

if (apply_fcc or apply_fs or apply_srcq) and not minimize_adaptive_sensfilt:
	if filter_latency_factor == 0:
		# Apply an adaptive filter to include the time-dependence of any sensing function parameters
		res = pipeparts.mkgeneric(pipeline, res, "lal_tdwhiten", kernel = reschainfilt[::-1], latency = reschaindelay, taper_length = sensing_filter_taper_length, name = "RES_filter")
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_invsens_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, res, "adaptive_filter", "kernel")
	else:
		# Apply an adaptive filter to include the time-dependence of any sensing function parameters
		res = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, res), "lal_tdwhiten", kernel = reschainfilt[::-1], latency = reschaindelay, taper_length = sensing_filter_taper_length, kernel_endtime = 0, name = "RES_filter")
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_invsens_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, res, "adaptive_filter", "kernel")
		adaptive_invsens_filter.connect("notify::filter-endtime", calibration_parts.update_property_simple, res, "filter_endtime", "kernel_endtime", 1)

# # Correct for time-dependence of f_cc
#if apply_fcc:
#	
#	default_fir_matrix = numpy.zeros(int(numpy.floor(hoft_sr*float(TDCFConfigs["fccfilterduration"])/2.0+1)*2.0-2.0))
#	latency = int(hoft_sr*float(TDCFConfigs["fccfilterduration"])/(2.0)+1)
#	default_fir_matrix[latency] = 1.0
#	res = pipeparts.mkgeneric(pipeline, res, "lal_tdwhiten", kernel = default_fir_matrix[::-1], latency = latency, taper_length = int(TDCFConfigs["fccfiltertaperlength"]))
#	update_fcc.connect("notify::fir-matrix", fir_matrix_update, res)

else:
	# Apply the residual chain filter without time-dependence
	res = pipeparts.mkfirbank(pipeline, res, latency = int(reschaindelay), fir_matrix = [reschainfilt[::-1]], time_domain = td)

# Account for filter latency and settle time for the CALIB_STATE_VECTOR
res_filter_settle_time += float(len(reschainfilt)-reschaindelay)/hoft_sr
res_filter_latency += float(reschaindelay)/hoft_sr

# Apply a short adaptive filter to include the time-dependence of the sensing function
if minimize_adaptive_sensfilt and (apply_fcc or apply_fs or apply_srcq):
	# Compute the reference model filter
	static_invsens_zero_filt = numpy.zeros(2)
	static_invsens_zero_filt[0] = 0.5 + hoft_sr / (2.0 * numpy.pi * static_invsens_poles[0])
	static_invsens_zero_filt[1] = 0.5 - hoft_sr / (2.0 * numpy.pi * static_invsens_poles[0])
	for i in range(1, len(static_invsens_poles) // 2):
		temp_filt = numpy.zeros(2)
		temp_filt[0] = 0.5 + hoft_sr / (2.0 * numpy.pi * static_invsens_poles[2 * i])
		temp_filt[1] = 0.5 - hoft_sr / (2.0 * numpy.pi * static_invsens_poles[2 * i])
		static_invsens_zero_filt = numpy.convolve(static_invsens_zero_filt, temp_filt)

	if filter_latency_factor == 0:
		# Apply an adaptive filter and apply updates as soon as possible.
		res = pipeparts.mkgeneric(pipeline, res, "lal_tdwhiten", kernel = static_invsens_zero_filt[::-1], latency = 0, taper_length = sensing_filter_taper_length, name = "RES_adaptive_filter")
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_invsens_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, res, "adaptive_filter", "kernel")
	else:
		# Apply an adaptive filter and apply updates at predetermined times.
		res = pipeparts.mkgeneric(pipeline, calibration_parts.mkqueue(pipeline, res), "lal_tdwhiten", kernel = static_invsens_zero_filt[::-1], latency = 0, taper_length = sensing_filter_taper_length, kernel_endtime = 0, name = "RES_adaptive_filter")
		# Hook up the adaptive filter from lal_adaptivefirfilt to lal_tdwhiten so that the filter gets updated
		adaptive_invsens_filter.connect("notify::adaptive-filter", calibration_parts.update_filter, res, "adaptive_filter", "kernel")
		adaptive_invsens_filter.connect("notify::filter-endtime", calibration_parts.update_property_simple, res, "filter_endtime", "kernel_endtime", 1)

# Apply \kappa_c if we haven't already
if apply_kappac and not (apply_fcc or apply_fs or apply_srcq):
	kc_modify_res = calibration_parts.mkresample(pipeline, smooth_kctee, 3, False, hoft_caps)
	res = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, res, calibration_parts.mkpow(pipeline, kc_modify_res, exponent = -1.0)))

if test_filters:
	res = pipeparts.mktee(pipeline, res)
	res_tf = calibration_parts.mkinterleave(pipeline, [res, derrtee])
	res_tf_delay = res_filter_settle_time + ((1.0 - filter_latency_factor) * (demodulation_filter_time + (median_smoothing_samples + factors_average_samples) / compute_factors_sr) + actuation_filter_update_time if (apply_fcc or apply_fs or apply_srcq) else 0)
	res_tf_start = start + res_tf_delay
	res_tf_dur = gps_end_time - res_tf_start - res_filter_latency - 10 if InputConfigs["datasource"] == "frames" else 300
	res_tf_dur = res_tf_dur - (res_tf_dur + 8) % 16
	num_res_ffts = int(res_tf_dur / 8)
	res_tf = pipeparts.mkprogressreport(pipeline, res_tf, "progress_res_tf_%s" % instrument)
	calibration_parts.mktransferfunction(pipeline, res_tf, fft_length = 16 * hoft_sr, fft_overlap = 8 * hoft_sr, num_ffts = num_res_ffts, use_median = True, update_samples = 1e15, update_delay_samples = res_tf_delay * hoft_sr, filename = "%s_res_filters_transfer_function_%d-%d.txt" % (filters_name.split('/')[-1].replace('.', '_'), res_tf_start, res_tf_dur), name = "res_filters_tf", use_fir_fft = True, fft_window_type = 3)

if dewhitening:
	res = pipeparts.mkfirbank(pipeline, res, latency = int(resdewhitendelay), fir_matrix = [resdewhiten[::-1]], time_domain = td)
	res_filter_settle_time += float(len(resdewhiten)-resdewhitendelay)/hoft_sr
	res_filter_latency += float(resdewhitendelay)/hoft_sr

if test_latency or InputConfigs["datasource"] == "lvshm":
	res = pipeparts.mktee(pipeline, res)
	res_latency = calibration_parts.mkresample(pipeline, res, 0, False, latency_metrics_caps) 
	res_latency = pipeparts.mklatency(pipeline, res_latency, name = "%s_res" % OutputConfigs["frametype"], silent = silent)
	if kafka_server is not None:
		res_latency.connect("notify::current-latency", handler.latency_new_buffer)
	pipeparts.mkfakesink(pipeline, res_latency)

filter_settle_time = max(res_filter_settle_time, tst_filter_settle_time, pumuim_filter_settle_time)
filter_latency = max(res_filter_latency, tst_filter_latency, pumuim_filter_latency)

#
# CONTROL + RESIDUAL = H(T)
#

# Add control and residual chains and divide by L to make h(t)
strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, res, ctrl))
if test_filters:
	strain = pipeparts.mktee(pipeline, strain)
	response_function = calibration_parts.mkinterleave(pipeline, [strain, derrtee])
	response_delay = max(res_tf_delay, tst_tf_delay)
	response_start = start + response_delay
	response_dur = gps_end_time - response_start - max(res_filter_latency, tst_filter_latency) - 10 if InputConfigs["datasource"] == "frames" else 300
	response_dur = response_dur - (response_dur + 8) % 16
	num_response_ffts = int(response_dur / 8)
	response_function = pipeparts.mkprogressreport(pipeline, response_function, "progress_response_function_%s" % instrument)
	calibration_parts.mktransferfunction(pipeline, response_function, fft_length = 16 * hoft_sr, fft_overlap = 8 * hoft_sr, num_ffts = num_response_ffts, use_median = True, update_samples = 1e15, update_delay_samples = response_delay * hoft_sr, filename = "%s_response_filters_transfer_function_%d-%d.txt" % (filters_name.split('/')[-1].replace('.', '_'), response_start, response_dur), name = "response_function", use_fir_fft = True, fft_window_type = 3)
# Divide by L in a way that is compatitble with old and new filters files, since old filter files don't recored "arm length"
try:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/float(filters["arm_length"]))
except KeyError:
	strain = pipeparts.mkaudioamplify(pipeline, strain, 1.0/3994.5)

strain = pipeparts.mkprogressreport(pipeline, strain, "progress_hoft_%s" % instrument)

# Put the units back to strain before writing to frames
straintagstr = "units=strain,channel-name=%sCALIB_STRAIN%s,instrument=%s" % (chan_prefix, chan_suffix, instrument)
straintee = pipeparts.mktee(pipeline, strain)
if not pick_cleanest_strain_channel:
	strain = pipeparts.mktaginject(pipeline, straintee, straintagstr)
if test_latency or InputConfigs["datasource"] == "lvshm":
	strain = pipeparts.mktee(pipeline, strain)
	strain_latency = calibration_parts.mkresample(pipeline, strain, 0, False, latency_metrics_caps)
	strain_latency = pipeparts.mklatency(pipeline, strain_latency, name = "%s_hoft" % OutputConfigs["frametype"], silent = silent)
	if kafka_server is not None:
		strain_latency.connect("notify::current-latency", handler.latency_new_buffer)
	pipeparts.mkfakesink(pipeline, strain_latency)

#
# CALIB_STATE_VECTOR BRANCH
#

#FIXME: Add more comments!

# Bit definitions
hoft_ok_bitnum = 0
obs_intent_bitnum = 1
lownoise_bitnum = 2
filters_ok_bitnum = 3
no_gap_bitnum = 4
no_stoch_inj_bitnum = 5
no_cbc_inj_bitnum = 6
no_burst_inj_bitnum = 7
no_detchar_inj_bitnum = 8
ktst_smooth_bitnum = 9
kpum_smooth_bitnum = 10
kuim_smooth_bitnum = 11
kc_smooth_bitnum = 12
fcc_smooth_bitnum = 13
fs_smooth_bitnum = 14
Qinv_smooth_bitnum = 15
sus_line3_coh_bitnum = 16
sus_line2_coh_bitnum = 17
sus_line1_coh_bitnum = 18
pcal_line1_coh_bitnum = 19
pcal_line2_coh_bitnum = 20
pcal_line4_coh_bitnum = 21
D_epics_bitnum = 22
A_epics_bitnum = 23
C_epics_bitnum = 24
misc_epics_bitnum = 25
line_sub_bitnum = 26
noise_sub_bitnum = 27
noise_sub_gate_bitnum = 28

# We'll only want to check things when the OBSERVATION-INTENT and LOW-NOISE bits are set
check_state_bitmask = pow(2, obs_intent_bitnum) + pow(2, lownoise_bitnum)
TDCFs_valid_bitmask_list = []
if apply_kappatst:
	TDCFs_valid_bitmask_list.append(pow(2, ktst_smooth_bitnum))
if apply_kappapum:
	TDCFs_valid_bitmask_list.append(pow(2, kpum_smooth_bitnum))
if apply_kappauim:
	TDCFs_valid_bitmask_list.append(pow(2, kuim_smooth_bitnum))
if apply_kappac:
	TDCFs_valid_bitmask_list.append(pow(2, kc_smooth_bitnum))
if apply_fcc:
	TDCFs_valid_bitmask_list.append(pow(2, fcc_smooth_bitnum))
if apply_fs:
	TDCFs_valid_bitmask_list.append(pow(2, fs_smooth_bitnum))
if apply_srcq:
	TDCFs_valid_bitmask_list.append(pow(2, Qinv_smooth_bitnum))
TDCFs_valid_bitmask = sum(TDCFs_valid_bitmask_list)
monitor_bitmask_dict = {'monitor_on': check_state_bitmask, 'TDCFs_valid': TDCFs_valid_bitmask}

if compute_calib_statevector:

	# 
	# OBSERVATION-INTENT BIT BRANCH
	#

	obsintentchannel = calibration_parts.caps_and_progress(pipeline, head_dict["obsintent"], obsintent_caps, "obs_intent_%s" % instrument)
	obsintentchanneltee = pipeparts.mktee(pipeline, obsintentchannel)
	obsintent = pipeparts.mkgeneric(pipeline, obsintentchanneltee, "lal_logicalundersample", required_on = obsintent_bitmask, status_out = pow(2,obs_intent_bitnum))
	obsintent = pipeparts.mkcapsfilter(pipeline, obsintent, calibstate_caps)
	obsintenttee = pipeparts.mktee(pipeline, obsintent)
	
	#
	# NOMINAL LOW-NOISE BIT BRANCH
	#

	lownoisechanneltee = obsintentchanneltee if lownoise_channel_name == obsintent_channel_name else pipeparts.mktee(pipeline, calibration_parts.caps_and_progress(pipeline, head_dict["lownoise"], lownoise_caps, "low_noise_state_%s" % instrument))
	lownoise = pipeparts.mkgeneric(pipeline, lownoisechanneltee, "lal_logicalundersample", required_on = lownoise_bitmask, status_out = pow(2,lownoise_bitnum))
	lownoise = pipeparts.mkcapsfilter(pipeline, lownoise, calibstate_caps)
	lownoisetee = pipeparts.mktee(pipeline, lownoise)

	#
	# FILTERS-OK BIT BRANCH
	#
	
	# Set the FILTERS-OK bit based on step-before transition to GRD-IFO_OK.
	# Take in a channel list and a corresponding bitmask list to use as determinator for when to start the clock for filter settling time
	filterclock_channels = []
	for i in range(len(filterclock_channel_list)):
		for key in headkeys:
			for j in range(len(filterclock_channel_list[i])):
				if ((filterclock_channel_list[i][j] != obsintent_channel_name and filterclock_channel_list[i][j] != lownoise_channel_name) and key in filterclock_channel_list[i]):
					filterclock_channel = calibration_parts.caps_and_progress(pipeline, head_dict[key], filterclock_caps[i], key)
					if filterclock_channel_list[i][j] == noisesub_gate_channel:
						filterclock_channel = noisesub_gate_tee = pipeparts.mktee(pipeline, filterclock_channel)
					filterclock_channel = calibration_parts.mkqueue(pipeline, pipeparts.mkcapsfilter(pipeline, pipeparts.mkgeneric(pipeline, filterclock_channel, "lal_logicalundersample", required_on = filterclock_bitmask_list[i], status_out = 1), calibstate_caps))
					filterclock_channels.append(filterclock_channel)
				elif (filterclock_channel_list[i][j] == obsintent_channel_name and key == "obsintent"):
					filterclock_channels.append(calibration_parts.mkqueue(pipeline, pipeparts.mkcapsfilter(pipeline, pipeparts.mkgeneric(pipeline, obsintenttee, "lal_logicalundersample", required_on = pow(2,obs_intent_bitnum), status_out = 1), calibstate_caps)))
				elif (filterclock_channel_list[i][j] == lownoise_channel_name and key == "lownoise"):
					filterclock_channels.append(calibration_parts.mkqueue(pipeline, pipeparts.mkcapsfilter(pipeline, pipeparts.mkgeneric(pipeline, lownoisetee, "lal_logicalundersample", required_on = pow(2,lownoise_bitnum), status_out = 1), calibstate_caps)))
	if len(filterclock_channel_list) > 1:
		filtersok = pipeparts.mkadder(pipeline, tuple(filterclock_channels))
	else:
		filtersok = filterclock_channels[0]
	lownoise_gate = pipeparts.mkbitvectorgen(pipeline, lownoisetee, bit_vector = len(filterclock_channels), threshold = pow(2,lownoise_bitnum))
	lownoise_gate = pipeparts.mkcapsfilter(pipeline, lownoise_gate, calibstate_caps)
	filtersok = pipeparts.mkadder(pipeline, calibration_parts.list_srcs(lownoise_gate, filtersok))
	filtersok = pipeparts.mkbitvectorgen(pipeline, filtersok, bit_vector = 1, threshold=len(filterclock_channels))
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, calibstate_caps)
	filtersoktee = pipeparts.mktee(pipeline, filtersok)
	filtersok = calibration_parts.mkgate(pipeline, filtersoktee, filtersoktee, 1, attack_length = -int(filter_settle_time * calibstate_sr))
	# The "hold" on FILTERS_OK turning off is still determined by the low noise state
	filtersok = calibration_parts.mkgate(pipeline, filtersok, lownoisetee, pow(2,lownoise_bitnum), hold_length = -int(filter_latency * calibstate_sr))
	filtersok = pipeparts.mkbitvectorgen(pipeline, filtersok, bit_vector = pow(2,filters_ok_bitnum), nongap_is_control = True)
	filtersok = pipeparts.mkcapsfilter(pipeline, filtersok, calibstate_caps)

	#
	# NO-INVALID-INPUT BRANCH
	#

	# Check if the DQ state vector is present
	nogap = pipeparts.mkbitvectorgen(pipeline, obsintentchanneltee, threshold=1, bit_vector = 1)
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, obsintent_caps)
	nogap = pipeparts.mkgeneric(pipeline, nogap, "lal_logicalundersample", required_on = 1, status_out = 1)
	nogap = pipeparts.mkcapsfilter(pipeline, nogap, calibstate_caps)
	# Check if any of the input data channels had to be replaced by zeroes because they were < 1e-35
	resok = pipeparts.mkbitvectorgen(pipeline, restee, threshold=1e-35, bit_vector=1)
	resok = pipeparts.mkcapsfilter(pipeline, resok, "audio/x-raw, format=U32LE, rate=%d" % hoft_sr)
	resok = pipeparts.mkgeneric(pipeline, resok, "lal_logicalundersample", required_on = 1, status_out = 1)
	resok = pipeparts.mkcapsfilter(pipeline, resok, calibstate_caps)
	if CalibrationConfigs["calibrationmode"] == "Partial":
		tstok = pipeparts.mkbitvectorgen(pipeline, tsttee, threshold=1e-35, bit_vector=1)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		tstok = pipeparts.mkgeneric(pipeline, tstok, "lal_logicalundersample", required_on = 1, status_out = 1)
		tstok = pipeparts.mkcapsfilter(pipeline, tstok, calibstate_caps)
		pumok = pipeparts.mkbitvectorgen(pipeline, pumtee, threshold=1e-35, bit_vector=1)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		pumok = pipeparts.mkgeneric(pipeline, pumok, "lal_logicalundersample", required_on = 1, status_out = 1)
		pumok = pipeparts.mkcapsfilter(pipeline, pumok, calibstate_caps)
		uimok = pipeparts.mkbitvectorgen(pipeline, uimtee, threshold=1e-35, bit_vector=1)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		uimok = pipeparts.mkgeneric(pipeline, uimok, "lal_logicalundersample", required_on = 1, status_out = 1)
		uimok = pipeparts.mkcapsfilter(pipeline, uimok, calibstate_caps)
		noinvalidinput = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, nogap, resok, tstok, pumok, uimok))
		noinvalidinput = pipeparts.mkbitvectorgen(pipeline, noinvalidinput, threshold=5, bit_vector=pow(2,no_gap_bitnum))
	if CalibrationConfigs["calibrationmode"] == "Full":
		ctrlok = pipeparts.mkbitvectorgen(pipeline, darmctrltee, threshold=1e-35, bit_vector=1)
		ctrlok = pipeparts.mkcapsfilter(pipeline, ctrlok, "audio/x-raw, format=U32LE, rate=%d" % ctrl_sr)
		ctrlok = pipeparts.mkgeneric(pipeline, ctrlok, "lal_logicalundersample", required_on = 1, status_out = 1)
		ctrlok = pipeparts.mkcapsfilter(pipeline, ctrlok, calibstate_caps)
		noinvalidinput = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, nogap, resok, ctrlok))
		noinvalidinput = pipeparts.mkbitvectorgen(pipeline, noinvalidinput, threshold=3, bit_vector=pow(2,no_gap_bitnum))
	noinvalidinput = pipeparts.mkcapsfilter(pipeline, noinvalidinput, calibstate_caps)
	noinvalidinput = pipeparts.mktee(pipeline, noinvalidinput)
	# inputs that are replaced with zeros affect h(t) for a short time before and after the zeros, so we also must account for this corrupted time.
	noinvalidinput = calibration_parts.mkgate(pipeline, noinvalidinput, noinvalidinput, pow(2,no_gap_bitnum), attack_length = -int(filter_settle_time * calibstate_sr), hold_length = -int(filter_latency * calibstate_sr))

	#
	# KAPPATST BITS BRANCH
	#
	if compute_kappatst:
		ktstSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_ktsttee, expected_kappatst_real, expected_kappatst_imag, kappatst_real_var, kappatst_imag_var, median_smoothing_samples, factors_average_samples, status_out_smooth = pow(2,ktst_smooth_bitnum), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# KAPPAPUM/KAPPAPU BITS BRANCH
	#
	if compute_kappapum:
		kpumSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_kpumtee, expected_kappapum_real, expected_kappapum_imag, kappapum_real_var, kappapum_imag_var, median_smoothing_samples, factors_average_samples, status_out_smooth = pow(2,kpum_smooth_bitnum), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	elif compute_kappapu:
		kpumSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_kputee, expected_kappapu_real, expected_kappapu_imag, kappapu_real_var, kappapu_imag_var, median_smoothing_samples, factors_average_samples, status_out_smooth = pow(2,kpum_smooth_bitnum), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# KAPPAUIM BITS BRANCH
	#
	if compute_kappauim:
		kuimSmoothInRange = calibration_parts.compute_kappa_bits(pipeline, smooth_kuimtee, expected_kappauim_real, expected_kappauim_imag, kappauim_real_var, kappauim_imag_var, median_smoothing_samples, factors_average_samples, status_out_smooth = pow(2,kuim_smooth_bitnum), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# KAPPAC BITS BRANCH
	#
	if compute_kappac:
		kcSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_kctee, expected_kappac, kappac_var, median_smoothing_samples, factors_average_samples, status_out_smooth = pow(2,kc_smooth_bitnum), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# FCC BITS BRANCH
	#
	if compute_fcc:
		fccSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_fcctee, fcc_default, fcc_var, median_smoothing_samples + int((sensing_filter_update_time + sensing_filter_averaging_time) * compute_factors_sr), factors_average_samples, status_out_smooth = pow(2,fcc_smooth_bitnum), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# FS BITS BRANCH
	#
	if compute_fs:
		fsSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_fs_squared, fs_squared_default, [-pow(abs(fs_default) + fs_var, 2), pow(abs(fs_default) + fs_var, 2)], median_smoothing_samples + int((sensing_filter_update_time + sensing_filter_averaging_time) * compute_factors_sr), factors_average_samples, status_out_smooth = pow(2,fs_smooth_bitnum), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# SRCQ BITS BRANCH
	#
	if compute_srcq:
		srcQSmoothInRange = calibration_parts.compute_kappa_bits_only_real(pipeline, smooth_srcQ_inv_real, 1.0 / (numpy.real(srcQ_default) + numpy.imag(srcQ_default)), [srcQinv_min, srcQinv_max], median_smoothing_samples + int((sensing_filter_update_time + sensing_filter_averaging_time) * compute_factors_sr), factors_average_samples, status_out_smooth = pow(2,Qinv_smooth_bitnum), starting_rate = compute_factors_sr, ending_rate = calibstate_sr)

	#
	# COHERENCE BITS BRANCH
	#
	if use_coherence and (compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq):
		coherence_ok_list = []
		if compute_kappatst or compute_kappapum or compute_kappauim or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
			# PCALY_LINE1 is used for all time-dependence calculations
			pcaly_line1_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line1_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,pcal_line1_coh_bitnum), invert_control = True)
			pcaly_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line1_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			pcaly_line1_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line1_coh_ok, "lal_logicalundersample", required_on = pow(2,pcal_line1_coh_bitnum), status_out = pow(2,pcal_line1_coh_bitnum))
			pcaly_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line1_coh_ok, calibstate_caps)
			coherence_ok_list.append(pcaly_line1_coh_ok)
		if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
			# SUS_LINE3 is used to compute kappa_TST and everything that is computed from it
			sus_line3_coh_ok = pipeparts.mkbitvectorgen(pipeline, sus_line3_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,sus_line3_coh_bitnum), invert_control = True)		    
			sus_line3_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_line3_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr) 
			sus_line3_coh_ok = pipeparts.mkgeneric(pipeline, sus_line3_coh_ok, "lal_logicalundersample", required_on = pow(2,sus_line3_coh_bitnum), status_out = pow(2,sus_line3_coh_bitnum))
			sus_line3_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_line3_coh_ok, calibstate_caps)
			coherence_ok_list.append(sus_line3_coh_ok)
		if compute_kappapum or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
			# SUS_LINE2 is used to compute kappa_PUM and everything that is computed from it
			sus_line2_coh_ok = pipeparts.mkbitvectorgen(pipeline, sus_line2_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,sus_line2_coh_bitnum), invert_control = True)
			sus_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_line2_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			sus_line2_coh_ok = pipeparts.mkgeneric(pipeline, sus_line2_coh_ok, "lal_logicalundersample", required_on = pow(2,sus_line2_coh_bitnum), status_out = pow(2,sus_line2_coh_bitnum))
			sus_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_line2_coh_ok, calibstate_caps)
			coherence_ok_list.append(sus_line2_coh_ok)
		if compute_kappauim or (not compute_kappapu and (compute_kappac or compute_fcc or compute_fs or compute_srcq)):
			# SUS_LINE1 is used to compute kappa_UIM and everything that is computed from it
			sus_line1_coh_ok = pipeparts.mkbitvectorgen(pipeline, sus_line1_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,sus_line1_coh_bitnum), invert_control = True)
			sus_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_line1_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			sus_line1_coh_ok = pipeparts.mkgeneric(pipeline, sus_line1_coh_ok, "lal_logicalundersample", required_on = pow(2,sus_line1_coh_bitnum), status_out = pow(2,sus_line1_coh_bitnum))
			sus_line1_coh_ok = pipeparts.mkcapsfilter(pipeline, sus_line1_coh_ok, calibstate_caps)
			coherence_ok_list.append(sus_line1_coh_ok)
		if compute_kappapu:
			# The DARM line is used only for kappa_PU
			darm_coh_ok = pipeparts.mkbitvectorgen(pipeline, darm_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,sus_line1_coh_bitnum), invert_control = True)
			darm_coh_ok = pipeparts.mkcapsfilter(pipeline, darm_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			darm_coh_ok = pipeparts.mkgeneric(pipeline, darm_coh_ok, "lal_logicalundersample", required_on = pow(2,sus_line1_coh_bitnum), status_out = pow(2,sus_line1_coh_bitnum))
			darm_coh_ok = pipeparts.mkcapsfilter(pipeline, darm_coh_ok, calibstate_caps)
			coherence_ok_list.append(darm_coh_ok)
		if compute_kappac or compute_fcc or compute_srcq or compute_fs:
			# PCALY_LINE2 is only used for \kappa_c, f_cc, f_s, and Q
			pcaly_line2_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line2_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,pcal_line2_coh_bitnum), invert_control = True)
			pcaly_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line2_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			pcaly_line2_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line2_coh_ok, "lal_logicalundersample", required_on = pow(2,pcal_line2_coh_bitnum), status_out = pow(2,pcal_line2_coh_bitnum))
			pcaly_line2_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line2_coh_ok, calibstate_caps)
			coherence_ok_list.append(pcaly_line2_coh_ok)
		if compute_fs or compute_srcq:
			# PCALY_LINE4 is used to compute f_s and Q
			pcaly_line4_coh_ok = pipeparts.mkbitvectorgen(pipeline, pcaly_line4_coh, threshold = coherence_unc_threshold, bit_vector = pow(2,pcal_line4_coh_bitnum), invert_control = True)
			pcaly_line4_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line4_coh_ok, "audio/x-raw, format=U32LE, rate=%d" % coh_sr)
			pcaly_line4_coh_ok = pipeparts.mkgeneric(pipeline, pcaly_line4_coh_ok, "lal_logicalundersample", required_on = pow(2,pcal_line4_coh_bitnum), status_out = pow(2,pcal_line4_coh_bitnum))
			pcaly_line4_coh_ok = pipeparts.mkcapsfilter(pipeline, pcaly_line4_coh_ok, calibstate_caps)
			coherence_ok_list.append(pcaly_line4_coh_ok)

		coherence_bits = calibration_parts.mkadder(pipeline, tuple(coherence_ok_list))

	#
	# H(T)-OK BIT BRANCH
	#

	# First combine higher order bits to determine h(t)-OK
	higherbits_list = [filtersok, lownoisetee, noinvalidinput]
	htok_threshold = pow(2,lownoise_bitnum) + pow(2,filters_ok_bitnum) + pow(2,no_gap_bitnum)
	if apply_kappatst or apply_complex_kappatst:
		higherbits_list.append(ktstSmoothInRange)
		htok_threshold += pow(2,ktst_smooth_bitnum)
	if apply_kappapum or apply_complex_kappapum or apply_kappapu or apply_complex_kappapu:
		higherbits_list.append(kpumSmoothInRange)
		htok_threshold += pow(2,kpum_smooth_bitnum)
	if apply_kappauim or apply_complex_kappauim:
		higherbits_list.append(kuimSmoothInRange)
		htok_threshold += pow(2,kuim_smooth_bitnum)
	if apply_kappac:
		higherbits_list.append(kcSmoothInRange)
		htok_threshold += pow(2,kc_smooth_bitnum)
	if apply_fcc:
		higherbits_list.append(fccSmoothInRange)
		htok_threshold += pow(2,fcc_smooth_bitnum)
	if apply_fs:
		higherbits_list.append(fsSmoothInRange)
		htok_threshold += pow(2,fs_smooth_bitnum)
	if apply_srcq:
		higherbits_list.append(srcQSmoothInRange)
		htok_threshold += pow(2,Qinv_smooth_bitnum)
	higherbits = calibration_parts.mkadder(pipeline, tuple(higherbits_list))
	higherbitstee = pipeparts.mktee(pipeline, higherbits)

	# Now calculate h(t)-OK bit
	htok = pipeparts.mkbitvectorgen(pipeline, higherbitstee, bit_vector = 1, threshold = htok_threshold)
	htok = pipeparts.mkcapsfilter(pipeline, htok, calibstate_caps)

	#
	# HW INJECTION BITS
	#	

	hwinjchanneltee = obsintentchanneltee if hwinj_channel_name == obsintent_channel_name else lownoisechanneltee if hwinj_channel_name == lownoise_channel_name else pipeparts.mktee(pipeline, calibration_parts.caps_and_progress(pipeline, head_dict["hwinj"], hwinj_caps, "HW_injections_%s" % instrument))

	if cbchwinj_bitmask is not None:
		hwinjcbc = pipeparts.mkgeneric(pipeline, hwinjchanneltee, "lal_logicalundersample", required_on = cbchwinj_bitmask, status_out = pow(2,no_cbc_inj_bitnum))
	elif cbchwinj_offbitmask is not None:
		hwinjcbc = pipeparts.mkgeneric(pipeline, hwinjchanneltee, "lal_logicalundersample", required_on = cbchwinj_offbitmask, invert_result = True, status_out = pow(2,no_cbc_inj_bitnum))
	else:
		raise ValueError("Must set either CBCHWInjBitmask or CBCHWInjOffBitmask")
	hwinjcbc = pipeparts.mkcapsfilter(pipeline, hwinjcbc, calibstate_caps)
	if bursthwinj_bitmask is not None:
		hwinjburst = pipeparts.mkgeneric(pipeline, hwinjchanneltee, "lal_logicalundersample", required_on = bursthwinj_bitmask, status_out = pow(2,no_burst_inj_bitnum))
	elif bursthwinj_offbitmask is not None:
		hwinjburst = pipeparts.mkgeneric(pipeline, hwinjchanneltee, "lal_logicalundersample", required_on = bursthwinj_offbitmask, invert_result = True, status_out = pow(2,no_burst_inj_bitnum))
	else:
		raise ValueError("Must set either BurstHWInjBitmask or BurstHWInjOffBitmask")
	hwinjburst = pipeparts.mkcapsfilter(pipeline, hwinjburst, calibstate_caps)

	if detcharhwinj_bitmask is not None:
		hwinjdetchar = pipeparts.mkgeneric(pipeline, hwinjchanneltee, "lal_logicalundersample", required_on = detcharhwinj_bitmask, status_out = pow(2,no_detchar_inj_bitnum))
	elif detcharhwinj_offbitmask is not None:
		hwinjdetchar = pipeparts.mkgeneric(pipeline, hwinjchanneltee, "lal_logicalundersample",  required_on = detcharhwinj_offbitmask, invert_result = True, status_out = pow(2,no_detchar_inj_bitnum))
	else:
		raise ValueError("Must set either DetCharHWInjBitmask or DetcharHWInjOffBitmask")
	hwinjdetchar = pipeparts.mkcapsfilter(pipeline, hwinjdetchar, calibstate_caps)

	if stochhwinj_bitmask is not None:
		hwinjstoch = pipeparts.mkgeneric(pipeline, hwinjchanneltee, "lal_logicalundersample", required_on = stochhwinj_bitmask, status_out = pow(2,no_stoch_inj_bitnum))
	elif stochhwinj_offbitmask is not None:
		hwinjstoch = pipeparts.mkgeneric(pipeline, hwinjchanneltee, "lal_logicalundersample",  required_on = stochhwinj_offbitmask, invert_result = True, status_out = pow(2,no_stoch_inj_bitnum))
	else:
		raise ValueError("Must set either StochHWInjBitmask or StochHWInjOffBitmask")
	hwinjstoch = pipeparts.mkcapsfilter(pipeline, hwinjstoch, calibstate_caps)

	#
	# EPICS BITS
	#

	epics_tolerance = 0.0001
	D_epics_threshold = (1-epics_tolerance)*len(D_epics_dict)
	A_epics_threshold = (1-epics_tolerance)*len(A_epics_dict)
	C_epics_threshold = (1-epics_tolerance)*len(C_epics_dict)
	misc_epics_threshold = (1-epics_tolerance)*len(misc_epics_dict)
	epics_bits_list = []

	# First, check the EPICS that involve only the digital filter D, EP7 and EP12
	if(len(D_epics_dict)):
		D_epics_check_list = []
		for EP_key in D_epics_dict:
			D_epics_check = pipeparts.mkaudioamplify(pipeline, calibration_parts.mkpow(pipeline, D_epics_dict[EP_key][0], exponent = -1.0), D_epics_dict[EP_key][1])
			# The above values should be close to one (within 1 / 10^4)
			D_epics_check = pipeparts.mkgeneric(pipeline, D_epics_check, "lal_insertgap", bad_data_intervals = [1-epics_tolerance, 1+epics_tolerance], replace_value = 0.0, insert_gap = False)
			D_epics_check_list.append(D_epics_check)
		D_epics_check = calibration_parts.mkadder(pipeline, tuple(D_epics_check_list))
		D_epics_bit = pipeparts.mkbitvectorgen(pipeline, D_epics_check, bit_vector = pow(2,D_epics_bitnum), threshold = D_epics_threshold)
		D_epics_bit = pipeparts.mkgeneric(pipeline, D_epics_bit, "lal_logicalundersample", required_on = pow(2,D_epics_bitnum), status_out = pow(2,D_epics_bitnum))
		D_epics_bit = pipeparts.mkcapsfilter(pipeline, D_epics_bit, calibstate_caps)
		epics_bits_list.append(D_epics_bit)

	# Next, check the EPICS that involve only the actuation function A: EP3, EP4, EP8, EP9, EP10, EP13, EP14, EP16, EP17, EP18, EP19, EP20, EP21, EP23, and EP24
	if(len(A_epics_dict)):
		A_epics_check_list = []
		for EP_key in A_epics_dict:
			A_epics_check = pipeparts.mkaudioamplify(pipeline, calibration_parts.mkpow(pipeline, A_epics_dict[EP_key][0], exponent = -1.0), A_epics_dict[EP_key][1])
			# The above values should be close to one (within 1 / 10^4)
			A_epics_check = pipeparts.mkgeneric(pipeline, A_epics_check, "lal_insertgap", bad_data_intervals = [1-epics_tolerance, 1+epics_tolerance], replace_value = 0.0, insert_gap = False)
			A_epics_check_list.append(A_epics_check)
		A_epics_check = calibration_parts.mkadder(pipeline, tuple(A_epics_check_list))
		A_epics_bit = pipeparts.mkbitvectorgen(pipeline, A_epics_check, bit_vector = pow(2,A_epics_bitnum), threshold = A_epics_threshold)
		A_epics_bit = pipeparts.mkgeneric(pipeline, A_epics_bit, "lal_logicalundersample", required_on = pow(2,A_epics_bitnum), status_out = pow(2,A_epics_bitnum))
		A_epics_bit = pipeparts.mkcapsfilter(pipeline, A_epics_bit, calibstate_caps)
		epics_bits_list.append(A_epics_bit)

	# Next, check the EPICS that involve only the sensing function C, EP6 and EP11
	if(len(C_epics_dict)):
		C_epics_check_list = []
		for EP_key in C_epics_dict:
			C_epics_check = pipeparts.mkaudioamplify(pipeline, calibration_parts.mkpow(pipeline, C_epics_dict[EP_key][0], exponent = -1.0), C_epics_dict[EP_key][1])
			# The above values should be close to one (within 1 / 10^4)
			C_epics_check = pipeparts.mkgeneric(pipeline, C_epics_check, "lal_insertgap", bad_data_intervals = [1-epics_tolerance, 1+epics_tolerance], replace_value = 0.0, insert_gap = False)
			C_epics_check_list.append(C_epics_check)
		C_epics_check = calibration_parts.mkadder(pipeline, tuple(C_epics_check_list))
		C_epics_bit = pipeparts.mkbitvectorgen(pipeline, C_epics_check, bit_vector = pow(2,C_epics_bitnum), threshold = C_epics_threshold)
		C_epics_bit = pipeparts.mkgeneric(pipeline, C_epics_bit, "lal_logicalundersample", required_on = pow(2,C_epics_bitnum), status_out = pow(2,C_epics_bitnum))
		C_epics_bit = pipeparts.mkcapsfilter(pipeline, C_epics_bit, calibstate_caps)
		epics_bits_list.append(C_epics_bit)

	# Next, check the remaining EPICS that are combinations of D, A, and C: EP1, EP2, EP15, EP22
	if(len(misc_epics_dict)):
		misc_epics_check_list = []
		for EP_key in misc_epics_dict:
			misc_epics_check = pipeparts.mkaudioamplify(pipeline, calibration_parts.mkpow(pipeline, misc_epics_dict[EP_key][0], exponent = -1.0), misc_epics_dict[EP_key][1])
			# The above values should be close to one (within 1 / 10^4)
			misc_epics_check = pipeparts.mkgeneric(pipeline, misc_epics_check, "lal_insertgap", bad_data_intervals = [1-epics_tolerance, 1+epics_tolerance], replace_value = 0.0, insert_gap = False)
			misc_epics_check_list.append(misc_epics_check)
		misc_epics_check = calibration_parts.mkadder(pipeline, tuple(misc_epics_check_list))
		misc_epics_bit = pipeparts.mkbitvectorgen(pipeline, misc_epics_check, bit_vector = pow(2,misc_epics_bitnum), threshold = misc_epics_threshold)
		misc_epics_bit = pipeparts.mkgeneric(pipeline, misc_epics_bit, "lal_logicalundersample", required_on = pow(2,misc_epics_bitnum), status_out = pow(2,misc_epics_bitnum))
		misc_epics_bit = pipeparts.mkcapsfilter(pipeline, misc_epics_bit, calibstate_caps)
		epics_bits_list.append(misc_epics_bit)

	#
	# COMBINE ALL BITS TO MAKE GDS-CALIB_STATE_VECTOR
	#

	all_bits_list = [higherbitstee, obsintenttee, htok, hwinjcbc, hwinjburst, hwinjdetchar, hwinjstoch]
	if use_coherence and (compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq):
		all_bits_list.append(coherence_bits)
	if compute_kappatst and not apply_kappatst and not apply_complex_kappatst:
		all_bits_list.append(ktstSmoothInRange)
	if (compute_kappapum or compute_kappapu) and not (apply_kappapum or apply_complex_kappapum or apply_kappapu or apply_complex_kappapu):
		all_bits_list.append(kpumSmoothInRange)
	if compute_kappauim and not (apply_kappauim or apply_complex_kappauim):
		all_bits_list.append(kuimSmoothInRange)
	if compute_kappac and not apply_kappac:
		all_bits_list.append(kcSmoothInRange)
	if compute_fcc and not apply_fcc:
		all_bits_list.append(fccSmoothInRange)
	if compute_fs and not apply_fs:
		all_bits_list.append(fsSmoothInRange)
	if compute_srcq and not apply_srcq:
		all_bits_list.append(srcQSmoothInRange)
	all_bits_list.extend(epics_bits_list)

	calibstatevector = calibration_parts.mkadder(pipeline, tuple(all_bits_list))

#
# SUBTRACTION OF LINES AND NOISE
#

# First, remove calibration lines
if remove_cal_lines:
	callines_list = []
	# Start with the pcal lines. Loop through the dictionary, reconstruct each line, and add to the list.
	for pcal_line_name in pcal_line_removal_dict:
		if not pcal_line_removal_dict[pcal_line_name][4]:
			# This line still needs to be demodulated
			pcal_line_removal_dict[pcal_line_name][0] = calibration_parts.demodulate(pipeline, pcal_line_removal_dict[pcal_line_name][0], pcal_line_removal_dict[pcal_line_name][1], td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, prefactor_real = pcal_sign * pcal_line_removal_dict[pcal_line_name][2], prefactor_imag = pcal_sign * pcal_line_removal_dict[pcal_line_name][3], freq_update = [head_dict[pcal_line_name], head_dict[pcal_line_name.replace('freq', '_corr_real')], head_dict[pcal_line_name.replace('freq', '_corr_imag')]] if pcal_line_name in head_dict else None)
		# Reconstruct a pcal signal at only this pcal line
		pcal_line_removal_dict[pcal_line_name][0] = calibration_parts.mkresample(pipeline, pcal_line_removal_dict[pcal_line_name][0], 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoft_sr)
		pcal_line_removal_dict[pcal_line_name][0] = pipeparts.mkgeneric(pipeline, pcal_line_removal_dict[pcal_line_name][0], "lal_demodulate", line_frequency = -1.0 * pcal_line_removal_dict[pcal_line_name][1], prefactor_real = 2.0)
		pcal_line_removal_dict[pcal_line_name][0] = pipeparts.mkgeneric(pipeline, pcal_line_removal_dict[pcal_line_name][0], "creal")
		# Add this line to the list
		callines_list.append(pcal_line_removal_dict[pcal_line_name][0])

	# Now deal with the actuation lines. Loop through the dictionary, reconstruct each line, and add to the list.
	for act_line_name in act_line_removal_dict:
		if not act_line_removal_dict[act_line_name][4]:
			# This line still needs to be demodulated
			act_line_removal_dict[act_line_name][0] = calibration_parts.demodulate(pipeline, act_line_removal_dict[act_line_name][0], act_line_removal_dict[act_line_name][1], td, compute_factors_sr, demodulation_filter_time, filter_latency_factor, freq_update = head_dict[act_line_name] if act_line_name in head_dict else None)
		if factors_from_filters_file:
			# EPICS records were read from the filters file
			act_line_removal_dict[act_line_name][0] = calibration_parts.complex_audioamplify(pipeline, act_line_removal_dict[act_line_name][0], float(filters[act_line_removal_dict[act_line_name][2]]), float(filters[act_line_removal_dict[act_line_name][3]]))
		else:
			# EPICS records are read from the frames
			EPICS = calibration_parts.merge_into_complex(pipeline, A_epics_dict[act_line_removal_dict[act_line_name][2]][0], A_epics_dict[act_line_removal_dict[act_line_name][3]][0])
			act_line_removal_dict[act_line_name][0] = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, act_line_removal_dict[act_line_name][0], EPICS))
		if act_line_removal_dict[act_line_name][5]:
			# Apply a complex time-dependent correction factor
			act_line_removal_dict[act_line_name][0] = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, act_line_removal_dict[act_line_name][0], act_line_removal_dict[act_line_name][7]))
		elif act_line_removal_dict[act_line_name][6]:
			# Apply the real part of a time-dependent correction factor
			act_line_removal_dict[act_line_name][0] = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, act_line_removal_dict[act_line_name][0], pipeparts.mktogglecomplex(pipeline, pipeparts.mkmatrixmixer(pipeline, act_line_removal_dict[act_line_name][7], matrix = [[1.0, 0.0]]))))

		# Reconstruct a signal at only this actuation line
		act_line_removal_dict[act_line_name][0] = calibration_parts.mkresample(pipeline, act_line_removal_dict[act_line_name][0], 3, False, "audio/x-raw, format=Z128LE, rate=%d, channel-mask=(bitmask)0x0" % hoft_sr)
		act_line_removal_dict[act_line_name][0] = pipeparts.mkgeneric(pipeline, act_line_removal_dict[act_line_name][0], "lal_demodulate", line_frequency = -1.0 * act_line_removal_dict[act_line_name][1], prefactor_real = 2.0)
		act_line_removal_dict[act_line_name][0] = pipeparts.mkgeneric(pipeline, act_line_removal_dict[act_line_name][0], "creal")
		# Add this line to the list
		callines_list.append(act_line_removal_dict[act_line_name][0])

	# Add all the lines together
	calibration_lines = calibration_parts.mkadder(pipeline, tuple(callines_list))

	# Divide the calibration lines we are removing by the arm length
	try:
		calibration_lines = pipeparts.mkaudioamplify(pipeline, calibration_lines, -1.0/float(filters["arm_length"]))
	except KeyError:
		calibration_lines = pipeparts.mkaudioamplify(pipeline, calibration_lines, -1.0/3994.5)

	clean_strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, straintee, calibration_lines))

# Set up gating for the power mains and noise subtraction
if compute_calib_statevector and (any(line_witness_channel_list) or any(witness_channel_list)) and noisesub_gate_bitmask > 0 and noisesub_gate_channel != "None":
	noisesubgate = obsintentchanneltee if noisesub_gate_channel == obsintent_channel_name else lownoisechanneltee if noisesub_gate_channel == lownoise_channel_name else hwinjchanneltee if noisesub_gate_channel == hwinj_channel_name else noisesub_gate_tee if noisesub_gate_channel in numpy.concatenate(filterclock_channel_list) else calibration_parts.caps_and_progress(pipeline, head_dict["noisesubgatechannel"], "audio/x-raw, format=U32LE, channels=1, channel-mask=(bitmask)0x0", noisesub_gate_channel)
	noisesubgate = pipeparts.mkgeneric(pipeline, noisesubgate, "lal_logicalundersample", required_on = noisesub_gate_bitmask, status_out = pow(2,noise_sub_gate_bitnum))
	noisesubgate = pipeparts.mkcapsfilter(pipeline, noisesubgate, calibstate_caps)
	noisesubgatetee = pipeparts.mktee(pipeline, noisesubgate)
else:
	noisesubgatetee = None

# Next, remove lines using witness channels, such as 60 Hz power lines and harmonics
if any(line_witness_channel_list):
	if not remove_cal_lines:
		clean_strain = straintee
	for i in range(0, len(line_witness_channel_list)):
		for j in range(0, len(line_witness_channel_list[i])):
			if type(line_witness_channel_list[i][j]) == str:
				line_witness_channel_list[i][j] = calibration_parts.caps_and_progress(pipeline, head_dict[line_witness_channel_list[i][j]], "audio/x-raw, format=F64LE, channels=1, channel-mask=(bitmask)0x0", line_witness_channel_list[i][j])
			if remove_cal_lines and filter_latency_factor > 0:
				line_witness_channel_list[i][j] = pipeparts.mkgeneric(pipeline, line_witness_channel_list[i][j], "lal_insertgap", chop_length = int(1000000000 * filter_latency_factor * demodulation_filter_time))

	clean_strain = calibration_parts.remove_lines_with_witnesses(pipeline, clean_strain, line_witness_channel_list, line_witness_freqs, line_witness_freq_vars, line_witness_frequency_channel_list, filter_latency = filter_latency_factor, compute_rate = compute_factors_sr, rate_out = hoft_sr, num_median = line_witness_tf_median_time * compute_factors_sr, num_avg = line_witness_tf_averaging_time * compute_factors_sr, noisesub_gate_bit = noisesubgatetee)

# Remove excess noise using any provided witness channels
if any(witness_channel_list):
	# Remove initial data from computation of transfer functions and wait until the filters and kappas settle
	witness_delay_time = witness_tf_time_shift if witness_tf_parallel_mode else (filter_settle_time + (1.0 - filter_latency_factor) * (demodulation_filter_time + median_smoothing_samples / compute_factors_sr + factors_average_samples / compute_factors_sr))
	# How much does the "delay_time" need to increase per iteration of cleaning?
	witness_delay_increment = witness_filter_taper_time + witness_channel_fft_time / 2.0 * (num_witness_ffts + 1.0) if not filter_latency_factor else 0.0
	# If we haven't removed any lines, clean the regular h(t) data
	if not (remove_cal_lines or any(line_witness_channel_list)):
		clean_strain = straintee

	for i in range(0, len(witness_channel_list)):
		# Length of ffts used to compute FIR filters
		witness_fft_samples = int(witness_channel_fft_time * witness_rates[i])
		# Overlap of ffts is half of fft length. The data is Hann-windowed before taking ffts.
		witness_fft_overlap = int(witness_fft_samples / 2)
		# How many samples between filter updates (does not include the samples used to compute the FIR filters
		witness_tf_update_samples = int(witness_rates[i] * witness_tf_update_time)
		# Length of FIR filters
		witness_fir_samples = int(float(witness_fir_length[min(i, len(witness_fir_length) - 1)]) * witness_rates[i])
		# Over how many samples should new FIR filters be tapered in?
		witness_filter_taper_length = int(witness_rates[i] * witness_filter_taper_time)

		witnesses = []
		for key in headkeys:
			if key in witness_channel_list[i]:
				witnesses.append(calibration_parts.caps_and_progress(pipeline, head_dict[key], "audio/x-raw, format=F64LE, channels=1, channel-mask=(bitmask)0x0", key))
		if len(witnesses) != len(witness_channel_list[i]):
			print("WARNING: Not all requested witness channels are being used")
		clean_strain = calibration_parts.clean_data(pipeline, clean_strain, hoft_sr, witnesses, witness_rates[i], witness_fft_samples, witness_fft_overlap, num_witness_ffts, min_witness_ffts, witness_tf_update_samples, witness_fir_samples, witness_frequency_resolution, witness_filter_taper_length, use_median = witness_tf_use_median, parallel_mode = witness_tf_parallel_mode, notch_frequencies = witness_notch_frequencies[i], high_pass = witness_highpasses[i], noisesub_gate_bit = noisesubgatetee, delay_time = witness_delay_time, critical_lock_loss_time = critical_lock_loss_time, filename = None if witness_tf_filename is None else "%s_%d.txt" % (witness_tf_filename, i))
		witness_delay_time += witness_delay_increment

if remove_cal_lines or any(line_witness_channel_list) or any(witness_channel_list):
	clean_strain = pipeparts.mkprogressreport(pipeline, clean_strain, "progress_hoft_cleaned_%s" % instrument)
	if test_latency or InputConfigs["datasource"] == "lvshm":
		clean_strain = pipeparts.mktee(pipeline, clean_strain)
		clean_strain_latency = calibration_parts.mkresample(pipeline, clean_strain, 0, False, latency_metrics_caps)
		clean_strain_latency = pipeparts.mklatency(pipeline, clean_strain_latency, name = "%s_hoft_cleaned" % OutputConfigs["frametype"], silent = silent)
		if kafka_server is not None:
			clean_strain_latency.connect("notify::current-latency", handler.latency_new_buffer)
		pipeparts.mkfakesink(pipeline, clean_strain_latency)
	clean_straintagstr = "units=strain,channel-name=%sCALIB_STRAIN_CLEAN%s,instrument=%s" % (chan_prefix, chan_suffix, instrument)
	clean_straintee = pipeparts.mktee(pipeline, clean_strain)
	if not pick_cleanest_strain_channel:
		clean_strain = pipeparts.mktaginject(pipeline, clean_straintee, clean_straintagstr)

#
# CALIB_STATE_VECTOR: CALIB_STRAIN_CLEAN
#

if (compute_calib_statevector or pick_cleanest_strain_channel) and (remove_cal_lines or any(line_witness_channel_list) or any(witness_channel_list)):
	low_rms_rate = pow(2, int(numpy.log(2 * cleaning_check_range_low_max) / numpy.log(2) + 1.01))
	mid_rms_rate = pow(2, int(numpy.log(2 * cleaning_check_range_mid_max) / numpy.log(2) + 1.01))

	# Compute the RMS of the uncleaned strain in a low-frequency range to test subtraction of actuation lines
	strain_rms_lowfreq = calibration_parts.compute_rms(pipeline, straintee, low_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_low_min, f_max = cleaning_check_range_low_max, filter_latency = min(filter_latency_factor, 0.5), rate_out = calibstate_sr, td = td)
	
	# Compute the RMS of the cleaned strain in a low-frequency range
	clean_strain_rms_lowfreq = calibration_parts.compute_rms(pipeline, clean_straintee, low_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_low_min, f_max = cleaning_check_range_low_max, filter_latency = min(filter_latency_factor, 0.5), rate_out = calibstate_sr, td = td)
	# Require that ratio RMS(strain) / RMS(clean_strain) > 1.0
	clean_hoft_ok_lowfreq = calibration_parts.complex_division(pipeline, strain_rms_lowfreq, clean_strain_rms_lowfreq)
	clean_hoft_ok_lowfreq = pipeparts.mkbitvectorgen(pipeline, clean_hoft_ok_lowfreq, bit_vector = pow(2,line_sub_bitnum), threshold=1.0)
	clean_hoft_ok_lowfreq = pipeparts.mkcapsfilter(pipeline, clean_hoft_ok_lowfreq, calibstate_caps)
	clean_hoft_ok_lowfreq = pipeparts.mktee(pipeline, clean_hoft_ok_lowfreq)

	# Compute the RMS of the uncleaned strain in a mid-frequency range to test subtraction of noise and/or the ~300 Hz pcal line
	strain_rms_midfreq = calibration_parts.compute_rms(pipeline, straintee, mid_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_mid_min, f_max = cleaning_check_range_mid_max, filter_latency = min(filter_latency_factor, 0.5), rate_out = calibstate_sr, td = td)
	# Compute the RMS of the cleaned strain in a mid-frequency range
	clean_strain_rms_midfreq = calibration_parts.compute_rms(pipeline, clean_straintee, mid_rms_rate, cleaning_check_rms_time, f_min = cleaning_check_range_mid_min, f_max = cleaning_check_range_mid_max, filter_latency = min(filter_latency_factor, 0.5), rate_out = calibstate_sr, td = td)
	# Require that ratio RMS(strain) / RMS(clean_strain) > 1.0
	clean_hoft_ok_midfreq = calibration_parts.complex_division(pipeline, strain_rms_midfreq, clean_strain_rms_midfreq)
	clean_hoft_ok_midfreq = pipeparts.mkbitvectorgen(pipeline, clean_hoft_ok_midfreq, bit_vector = pow(2,noise_sub_bitnum), threshold=1.0)
	clean_hoft_ok_midfreq = pipeparts.mkcapsfilter(pipeline, clean_hoft_ok_midfreq, calibstate_caps)
	clean_hoft_ok_midfreq = pipeparts.mktee(pipeline, clean_hoft_ok_midfreq)

	if compute_calib_statevector:
		# Add these into the CALIB_STATE_VECTOR
		calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, clean_hoft_ok_lowfreq, clean_hoft_ok_midfreq))
	if pick_cleanest_strain_channel:
		noise_sub_ok_bitmask = pow(2,line_sub_bitnum) + pow(2,noise_sub_bitnum)
		noise_sub_state_vector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, clean_hoft_ok_lowfreq, clean_hoft_ok_midfreq))
		if InputConfigs["datasource"] == "lvshm":
			# We don't want to add extra latency
			noise_sub_state_vector = pipeparts.mkgeneric(pipeline, noise_sub_state_vector, "lal_shift", shift = int(1000000000 * strain_channel_transition_time))
		noise_sub_state_vector = pipeparts.mktee(pipeline, noise_sub_state_vector)
		strain_coefficient = pipeparts.mkgeneric(pipeline, noise_sub_state_vector, "lal_dqtukey", required_on = noise_sub_ok_bitmask, transition_samples = hoft_sr * strain_channel_transition_time, invert_window = True)
		clean_strain_coefficient = pipeparts.mkgeneric(pipeline, noise_sub_state_vector, "lal_dqtukey", required_on = noise_sub_ok_bitmask, transition_samples = hoft_sr * strain_channel_transition_time)
		strain = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, straintee, strain_coefficient))
		clean_strain = calibration_parts.mkmultiplier(pipeline, calibration_parts.list_srcs(pipeline, clean_straintee, clean_strain_coefficient))
		strain = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, strain, clean_strain))
		strain = pipeparts.mktaginject(pipeline, strain, straintagstr) 

# Check if we gated the cleaning with any ODC bits, and if so, add that to the CALIB_STATE_VECTOR
if noisesubgatetee is not None:
	calibstatevector = calibration_parts.mkadder(pipeline, calibration_parts.list_srcs(pipeline, calibstatevector, noisesubgatetee))

if compute_calib_statevector:
	calibstatevector = pipeparts.mkprogressreport(pipeline, calibstatevector, "progress_calibstatevec_%s" % instrument)
	if test_latency or InputConfigs["datasource"] == "lvshm":
		calibstatevector = pipeparts.mktee(pipeline, calibstatevector)
		calibstatevector_latency = pipeparts.mklatency(pipeline, calibstatevector, name = "%s_calibstatevec" % OutputConfigs["frametype"], silent = silent)
		if kafka_server is not None:
			# Dump latency info to kafka
			calibstatevector_latency.connect("notify::current-latency", handler.latency_new_buffer)
			if monitor_statevector:
				# Dump statevector metric info to kafka
				statevector_monitor = pipeparts.mkgeneric(pipeline, calibstatevector, "lal_nxydump")
				statevector_monitor = pipeparts.mkappsink(pipeline, statevector_monitor, max_buffers = 1)	
				statevector_monitor.connect("new-sample", handler.appsink_statevector_new_buffer, instrument, monitor_bitmask_dict)
		pipeparts.mkfakesink(pipeline, calibstatevector_latency)
	dqtagstr = "channel-name=%s:GDS-CALIB_STATE_VECTOR, instrument=%s" % (instrument, instrument)
	calibstatevector = pipeparts.mktaginject(pipeline, calibstatevector, dqtagstr)

#
# Produce time-dependent correction factors to be recorded in the frames
#

record_kappa_caps = "audio/x-raw, format=F32LE, rate=%d" % record_factors_sr

# Resample the \kappa_tst channels at the specified recording sample rate and change them to single precision channels
if compute_kappatst:

	ktstRout = pipeparts.mkgeneric(pipeline, smooth_ktstRtee, "lal_typecast")
	ktstRout = calibration_parts.mkresample(pipeline, ktstRout, 1, False, record_kappa_caps)
	ktstRout = pipeparts.mkprogressreport(pipeline, ktstRout, "progress_kappa_tst_real_%s" % instrument)
	if test_latency:
		ktstRout = pipeparts.mklatency(pipeline, ktstRout, name = "%s_kappa_tst_real" % OutputConfigs["frametype"])

	ktstIout = pipeparts.mkgeneric(pipeline, smooth_ktstItee, "lal_typecast")
	ktstIout = calibration_parts.mkresample(pipeline, ktstIout, 1, False, record_kappa_caps)
	ktstIout = pipeparts.mkprogressreport(pipeline, ktstIout, "progress_kappa_tst_imag_%s" % instrument)
	if test_latency:
		ktstIout = pipeparts.mklatency(pipeline, ktstIout, name = "%s_kappa_tst_imag" % OutputConfigs["frametype"])

	smooth_ktstR_nogate = pipeparts.mkgeneric(pipeline, smooth_ktstR_nogate, "lal_typecast")
	smooth_ktstR_nogate = calibration_parts.mkresample(pipeline, smooth_ktstR_nogate, 1, False, record_kappa_caps)
	smooth_ktstR_nogate = pipeparts.mkprogressreport(pipeline, smooth_ktstR_nogate, "progress_kappa_tst_real_nogate_%s" % instrument)
	if test_latency:
		smooth_ktstR_nogate = pipeparts.mklatency(pipeline, smooth_ktstR_nogate, name = "%s_kappa_tst_real_nogate" % OutputConfigs["frametype"])

	smooth_ktstI_nogate = pipeparts.mkgeneric(pipeline, smooth_ktstI_nogate, "lal_typecast")
	smooth_ktstI_nogate = calibration_parts.mkresample(pipeline, smooth_ktstI_nogate, 1, False, record_kappa_caps)
	smooth_ktstI_nogate = pipeparts.mkprogressreport(pipeline, smooth_ktstI_nogate, "progress_kappa_tst_imag_nogate_%s" % instrument)
	if test_latency:
		smooth_ktstI_nogate = pipeparts.mklatency(pipeline, smooth_ktstI_nogate, name = "%s_kappa_tst_imag_nogate" % OutputConfigs["frametype"])

# Resample the \kappa_pum channels at the specified recording sample rate and change them to single precision channels
if compute_kappapum:

	kpumRout = pipeparts.mkgeneric(pipeline, smooth_kpumRtee, "lal_typecast")
	kpumRout = calibration_parts.mkresample(pipeline, kpumRout, 1, False, record_kappa_caps)
	kpumRout = pipeparts.mkprogressreport(pipeline, kpumRout, "progress_kappa_pum_real_%s" % instrument)
	if test_latency:
		kpumRout = pipeparts.mklatency(pipeline, kpumRout, name = "%s_kappa_pum_real" % OutputConfigs["frametype"])

	kpumIout = pipeparts.mkgeneric(pipeline, smooth_kpumItee, "lal_typecast")
	kpumIout = calibration_parts.mkresample(pipeline, kpumIout, 1, False, record_kappa_caps)
	kpumIout = pipeparts.mkprogressreport(pipeline, kpumIout, "progress_kappa_pum_imag_%s" % instrument)
	if test_latency:
		kpumIout = pipeparts.mklatency(pipeline, kpumIout, name = "%s_kappa_pum_imag" % (OutputConfigs["frametype"]))

	smooth_kpumR_nogate = pipeparts.mkgeneric(pipeline, smooth_kpumR_nogate, "lal_typecast")
	smooth_kpumR_nogate = calibration_parts.mkresample(pipeline, smooth_kpumR_nogate, 1, False, record_kappa_caps)
	smooth_kpumR_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpumR_nogate, "progress_kappa_pum_real_nogate_%s" % instrument)
	if test_latency:
		smooth_kpumR_nogate = pipeparts.mklatency(pipeline, smooth_kpumR_nogate, name = "%s_kappa_pum_real_nogate" % (OutputConfigs["frametype"]))

	smooth_kpumI_nogate = pipeparts.mkgeneric(pipeline, smooth_kpumI_nogate, "lal_typecast")
	smooth_kpumI_nogate = calibration_parts.mkresample(pipeline, smooth_kpumI_nogate, 1, False, record_kappa_caps)
	smooth_kpumI_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpumI_nogate, "progress_kappa_pum_imag_nogate_%s" % instrument)
	if test_latency:
		smooth_kpumI_nogate = pipeparts.mklatency(pipeline, smooth_kpumI_nogate, name = "%s_kappa_pum_imag_nogate" % (OutputConfigs["frametype"]))

# Resample the \kappa_uim channels at the specified recording sample rate and change them to single precision channels
if compute_kappauim:

	kuimRout = pipeparts.mkgeneric(pipeline, smooth_kuimRtee, "lal_typecast")
	kuimRout = calibration_parts.mkresample(pipeline, kuimRout, 1, False, record_kappa_caps)
	kuimRout = pipeparts.mkprogressreport(pipeline, kuimRout, "progress_kappa_uim_real_%s" % instrument)
	if test_latency:
		kuimRout = pipeparts.mklatency(pipeline, kuimRout, name = "%s_kappa_uim_real" % (OutputConfigs["frametype"]))

	kuimIout = pipeparts.mkgeneric(pipeline, smooth_kuimItee, "lal_typecast")
	kuimIout = calibration_parts.mkresample(pipeline, kuimIout, 1, False, record_kappa_caps)
	kuimIout = pipeparts.mkprogressreport(pipeline, kuimIout, "progress_kappa_uim_imag_%s" % instrument)
	if test_latency:
		kuimIout = pipeparts.mklatency(pipeline, kuimIout, name = "%s_kappa_uim_imag" % (OutputConfigs["frametype"]))

	smooth_kuimR_nogate = pipeparts.mkgeneric(pipeline, smooth_kuimR_nogate, "lal_typecast")
	smooth_kuimR_nogate = calibration_parts.mkresample(pipeline, smooth_kuimR_nogate, 1, False, record_kappa_caps)
	smooth_kuimR_nogate = pipeparts.mkprogressreport(pipeline, smooth_kuimR_nogate, "progress_kappa_uim_real_nogate_%s" % instrument)
	if test_latency:
		smooth_kuimR_nogate = pipeparts.mklatency(pipeline, smooth_kuimR_nogate, name = "%s_kappa_uim_real_nogate" % (OutputConfigs["frametype"]))

	smooth_kuimI_nogate = pipeparts.mkgeneric(pipeline, smooth_kuimI_nogate, "lal_typecast")
	smooth_kuimI_nogate = calibration_parts.mkresample(pipeline, smooth_kuimI_nogate, 1, False, record_kappa_caps)
	smooth_kuimI_nogate = pipeparts.mkprogressreport(pipeline, smooth_kuimI_nogate, "progress_kappa_uim_imag_nogate_%s" % instrument)
	if test_latency:
		smooth_kuimI_nogate = pipeparts.mklatency(pipeline, smooth_kuimI_nogate, name = "%s_kappa_uim_imag_nogate" % (OutputConfigs["frametype"]))

# Resample the \kappa_pu channels at the specified recording sample rate and change them to single precision channels
if compute_kappapu:

	kpuRout = pipeparts.mkgeneric(pipeline, smooth_kpuRtee, "lal_typecast")
	kpuRout = calibration_parts.mkresample(pipeline, kpuRout, 1, False, record_kappa_caps)
	kpuRout = pipeparts.mkprogressreport(pipeline, kpuRout, "progress_kappa_pu_real_%s" % instrument)
	if test_latency:
		kpuRout = pipeparts.mklatency(pipeline, kpuRout, name = "%s_kappa_pu_real" % (OutputConfigs["frametype"]))

	kpuIout = pipeparts.mkgeneric(pipeline, smooth_kpuItee, "lal_typecast")
	kpuIout = calibration_parts.mkresample(pipeline, kpuIout, 1, False, record_kappa_caps)
	kpuIout = pipeparts.mkprogressreport(pipeline, kpuIout, "progress_kappa_pu_imag_%s" % instrument)
	if test_latency:
		kpuIout = pipeparts.mklatency(pipeline, kpuIout, name = "%s_kappa_pu_imag" % (OutputConfigs["frametype"]))

	smooth_kpuR_nogate = pipeparts.mkgeneric(pipeline, smooth_kpuR_nogate, "lal_typecast")
	smooth_kpuR_nogate = calibration_parts.mkresample(pipeline, smooth_kpuR_nogate, 1, False, record_kappa_caps)
	smooth_kpuR_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpuR_nogate, "progress_kappa_pu_real_nogate_%s" % instrument)
	if test_latency:
		smooth_kpuR_nogate = pipeparts.mklatency(pipeline, smooth_kpuR_nogate, name = "%s_kappa_pu_real_nogate" % (OutputConfigs["frametype"]))

	smooth_kpuI_nogate = pipeparts.mkgeneric(pipeline, smooth_kpuI_nogate, "lal_typecast")
	smooth_kpuI_nogate = calibration_parts.mkresample(pipeline, smooth_kpuI_nogate, 1, False, record_kappa_caps)
	smooth_kpuI_nogate = pipeparts.mkprogressreport(pipeline, smooth_kpuI_nogate, "progress_kappa_pu_imag_nogate_%s" % instrument)
	if test_latency:
		smooth_kpuI_nogate = pipeparts.mklatency(pipeline, smooth_kpuI_nogate, name = "%s_kappa_pu_imag_nogate" % (OutputConfigs["frametype"]))

# Resample the \kappa_c channels at the specified recording sample rate and change it to a single precision channel
if compute_kappac:
	kcout = pipeparts.mkgeneric(pipeline, smooth_kctee, "lal_typecast")
	kcout = calibration_parts.mkresample(pipeline, kcout, 1, False, record_kappa_caps)
	kcout = pipeparts.mkprogressreport(pipeline, kcout, "progress_kappa_c_%s" % instrument)
	if test_latency:
		kcout = pipeparts.mklatency(pipeline, kcout, name = "%s_kappa_c_imag" % (OutputConfigs["frametype"]))

	smooth_kc_nogate = pipeparts.mkgeneric(pipeline, smooth_kc_nogate, "lal_typecast")
	smooth_kc_nogate = calibration_parts.mkresample(pipeline, smooth_kc_nogate, 1, False, record_kappa_caps)
	smooth_kc_nogate = pipeparts.mkprogressreport(pipeline, smooth_kc_nogate, "progress_kappa_c_nogate_%s" % instrument)
	if test_latency:
		smooth_kc_nogate = pipeparts.mklatency(pipeline, smooth_kc_nogate, name = "%s_kappa_c_nogate" % (OutputConfigs["frametype"]))

# Resample the f_cc channels at the specified recording sample rate and change it to a single precision channel
if compute_fcc:
	fccout = pipeparts.mkgeneric(pipeline, smooth_fcctee, "lal_typecast")
	fccout = calibration_parts.mkresample(pipeline, fccout, 1, False, record_kappa_caps)
	fccout = pipeparts.mkprogressreport(pipeline, fccout, "progress_f_cc_%s" % instrument)
	if test_latency:
		fccout = pipeparts.mklatency(pipeline, fccout, name = "%s_f_cc_imag" % (OutputConfigs["frametype"]))

	smooth_fcc_nogate = pipeparts.mkgeneric(pipeline, smooth_fcc_nogate, "lal_typecast")
	smooth_fcc_nogate = calibration_parts.mkresample(pipeline, smooth_fcc_nogate, 1, False, record_kappa_caps)
	smooth_fcc_nogate = pipeparts.mkprogressreport(pipeline, smooth_fcc_nogate, "progress_f_cc_nogate_%s" % instrument)
	if test_latency:
		smooth_fcc_nogate = pipeparts.mklatency(pipeline, smooth_fcc_nogate, name = "%s_f_cc_nogate" % (OutputConfigs["frametype"]))

# Resample the f_s channels at the specified recording sample rate and change it to a single precision channel
if compute_fs:
	fs_squared_out = pipeparts.mkgeneric(pipeline, smooth_fs_squared, "lal_typecast")
	fs_squared_out = calibration_parts.mkresample(pipeline, fs_squared_out, 1, False, record_kappa_caps)
	fs_squared_out = pipeparts.mkprogressreport(pipeline, fs_squared_out, "progress_f_s_squared_%s" % instrument)
	if test_latency:
		fs_squared_out = pipeparts.mklatency(pipeline, fs_squared_out, name = "%s_f_s_squared" % (OutputConfigs["frametype"]))

	smooth_fs_squared_nogate = pipeparts.mkgeneric(pipeline, smooth_fs_squared_nogate, "lal_typecast")
	smooth_fs_squared_nogate = calibration_parts.mkresample(pipeline, smooth_fs_squared_nogate, 1, False, record_kappa_caps)
	smooth_fs_squared_nogate = pipeparts.mkprogressreport(pipeline, smooth_fs_squared_nogate, "progress_f_s_squared_nogate_%s" % instrument)
	if test_latency:
		smooth_fs_squared_nogate = pipeparts.mklatency(pipeline, smooth_fs_squared_nogate, name = "%s_f_s_squared_nogate" % (OutputConfigs["frametype"]))

# Resample the SRC Q channels at the specified recording sample rate and change it to a single precision channel
if compute_srcq:
	srcQ_inv_out = pipeparts.mkgeneric(pipeline, smooth_srcQ_inv_real, "lal_typecast")
	srcQ_inv_out = calibration_parts.mkresample(pipeline, srcQ_inv_out, 1, False, record_kappa_caps)
	srcQ_inv_out = pipeparts.mkprogressreport(pipeline, srcQ_inv_out, "progress_SRC_Q_%s" % instrument)
	if test_latency:
		srcQ_inv_out = pipeparts.mklatency(pipeline, srcQ_inv_out, name = "%s_SRC_Q" % (OutputConfigs["frametype"]))

	smooth_srcQ_inv_nogate = pipeparts.mkgeneric(pipeline, smooth_srcQ_inv_nogate, "lal_typecast")
	smooth_srcQ_inv_nogate = calibration_parts.mkresample(pipeline, smooth_srcQ_inv_nogate, 1, False, record_kappa_caps)
	smooth_srcQ_inv_nogate = pipeparts.mkprogressreport(pipeline, smooth_srcQ_inv_nogate, "progress_SRC_Q_nogate_%s" % instrument)
	if test_latency:
		smooth_srcQ_inv_nogate = pipeparts.mklatency(pipeline, smooth_srcQ_inv_nogate, name = "%s_SRC_Q_nogate" % (OutputConfigs["frametype"]))

#
# CREATE MUXER AND HOOK EVERYTHING UP TO IT
#

channelmux_input_dict = {}
# Link the output DQ vectors up to the muxer, if applicable
if compute_calib_statevector: 
	channelmux_input_dict["%s:%sCALIB_STATE_VECTOR%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, calibstatevector) 
# Link the strain branch to the muxer
channelmux_input_dict["%s:%sCALIB_STRAIN%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, strain)
# Link the cleaned strain branch to the muxer if h(t) was cleaned in any way
if (remove_cal_lines or any(line_witness_channel_list) or any(witness_channel_list)) and not pick_cleanest_strain_channel:
	channelmux_input_dict["%s:%sCALIB_STRAIN_CLEAN%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, clean_strain)
# Link the real and imaginary parts of kappa_tst to the muxer
if compute_kappatst:
	channelmux_input_dict["%s:%sCALIB_KAPPA_TST_REAL%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, ktstRout)
	channelmux_input_dict["%s:%sCALIB_KAPPA_TST_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, ktstIout)
	channelmux_input_dict["%s:%sCALIB_KAPPA_TST_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_ktstR_nogate)
	channelmux_input_dict["%s:%sCALIB_KAPPA_TST_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_ktstI_nogate)
# Link the real and imaginary parts of kappa_pum to the muxer
if compute_kappapum:
	channelmux_input_dict["%s:%sCALIB_KAPPA_PUM_REAL%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, kpumRout)
	channelmux_input_dict["%s:%sCALIB_KAPPA_PUM_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, kpumIout)
	channelmux_input_dict["%s:%sCALIB_KAPPA_PUM_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_kpumR_nogate)
	channelmux_input_dict["%s:%sCALIB_KAPPA_PUM_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_kpumI_nogate)
# Link the real and imaginary parts of kappa_uim to the muxer
if compute_kappauim:
	channelmux_input_dict["%s:%sCALIB_KAPPA_UIM_REAL%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, kuimRout)
	channelmux_input_dict["%s:%sCALIB_KAPPA_UIM_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, kuimIout)
	channelmux_input_dict["%s:%sCALIB_KAPPA_UIM_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_kuimR_nogate)
	channelmux_input_dict["%s:%sCALIB_KAPPA_UIM_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_kuimI_nogate)
# Link the real and imaginary parts of kappa_pu to the muxer
if compute_kappapu:
	channelmux_input_dict["%s:%sCALIB_KAPPA_PU_REAL%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, kpuRout)
	channelmux_input_dict["%s:%sCALIB_KAPPA_PU_IMAGINARY%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, kpuIout)
	channelmux_input_dict["%s:%sCALIB_KAPPA_PU_REAL_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_kpuR_nogate)
	channelmux_input_dict["%s:%sCALIB_KAPPA_PU_IMAGINARY_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_kpuI_nogate)
# Link the \kappa_c to the muxer
if compute_kappac:
	channelmux_input_dict["%s:%sCALIB_KAPPA_C%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, kcout)
	channelmux_input_dict["%s:%sCALIB_KAPPA_C_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_kc_nogate)
# Link the f_cc to the muxer
if compute_fcc:
	channelmux_input_dict["%s:%sCALIB_F_CC%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, fccout)
	channelmux_input_dict["%s:%sCALIB_F_CC_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_fcc_nogate)
# Link the f_s to the muxer
if compute_fs:
	channelmux_input_dict["%s:%sCALIB_F_S_SQUARED%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, fs_squared_out)
	channelmux_input_dict["%s:%sCALIB_F_S_SQUARED_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_fs_squared_nogate)
# Link the src_Q to the muxer
if compute_srcq:
	channelmux_input_dict["%s:%sCALIB_SRC_Q_INVERSE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, srcQ_inv_out)
	channelmux_input_dict["%s:%sCALIB_SRC_Q_INVERSE_NOGATE%s" % (instrument, chan_prefix, chan_suffix)] = calibration_parts.mkqueue(pipeline, smooth_srcQ_inv_nogate)

mux = pipeparts.mkframecppchannelmux(pipeline, channelmux_input_dict, frame_duration = options.frame_duration, frames_per_file = options.frames_per_file, compression_scheme = int(OutputConfigs["compressionscheme"]), compression_level = int(OutputConfigs["compressionlevel"]))

# Check that all frames are long enough, that they have all of the channels by requiring a certain amount of time from start-up, and that frames aren't written for times requested by the wings option
def check_complete_frames(pad, info, (output_start, frame_duration, wings_start, wings_end)):
	if verbose:
		print("Checking if frames are complete")
	buf = info.get_buffer()
	startts = lal.LIGOTimeGPS(0, buf.pts)
	duration = lal.LIGOTimeGPS(0, buf.duration)
	if not (startts % frame_duration == 0):
		if verbose:
			print("Dropping frame because it is not an integer multiple of frame duration")
		return Gst.PadProbeReturn.DROP
	if startts < output_start:
		if verbose:
			print("Dropping frame because start time %f is less than desired output start time %f" % (startts, output_start))
		return Gst.PadProbeReturn.DROP
	if duration != frame_duration:
		if verbose:
			print("Dropping frame because the duration %d is not equal to the required frame duration %d" % (duration, frame_duration))
		return Gst.PadProbeReturn.DROP
	if wings_start is not None and wings_end is not None:
		if startts < wings_start or (startts+duration) > wings_end:
			if verbose:
				print("Dropping frame because it lies outside of the wings time")
			return Gst.PadProbeReturn.DROP
	return Gst.PadProbeReturn.OK

# start time of first frame file is the desired start time + either filter latency or kappa settling (if computing kappas), whichever is bigger
if compute_kappatst or compute_kappapu or compute_kappac or compute_fcc or compute_fs or compute_srcq:
	output_start = start + max(int(filter_settle_time), int((1.0 - filter_latency_factor) * (demodulation_filter_time + int(TDCFConfigs["mediansmoothingtime"]) + int(TDCFConfigs["tdcfaveragingtime"]))))
else:
	output_start = start + int(filter_settle_time)

# If the wings option is set, need to also check that frames aren't written during the requested wing time
wings = int(options.wings)
if wings != 0:
	wings_start = gps_start_time + wings
	wings_end = gps_end_time - wings
	mux.get_static_pad("src").add_probe(Gst.PadProbeType.BUFFER, check_complete_frames, (lal.LIGOTimeGPS(output_start,0), lal.LIGOTimeGPS(options.frame_duration*options.frames_per_file,0), lal.LIGOTimeGPS(wings_start, 0), lal.LIGOTimeGPS(wings_end, 0)))
else:
	mux.get_static_pad("src").add_probe(Gst.PadProbeType.BUFFER, check_complete_frames, (lal.LIGOTimeGPS(output_start,0), lal.LIGOTimeGPS(options.frame_duration*options.frames_per_file,0), None, None))

mux = pipeparts.mkprogressreport(pipeline, mux, "progress_sink_%s" % instrument)

# FIXME: I don't think I need to resample here either since the frames are already collected into 1 second chunks
if test_latency or InputConfigs["datasource"] == "lvshm":
	mux = pipeparts.mktee(pipeline, mux)
	mux_latency = pipeparts.mklatency(pipeline, mux, name = "%s_sink" % OutputConfigs["frametype"], silent = silent)
	if kafka_server is not None:
		mux_latency.connect("notify::current-latency", handler.latency_new_buffer)
	pipeparts.mkfakesink(pipeline, mux_latency)

if OutputConfigs["datasink"] == "lvshm":
	pipeparts.mkgeneric(pipeline, mux, "gds_lvshmsink", sync=False, async=False, shm_name = OutputConfigs["outputshmpartition"], num_buffers = int(OutputConfigs["numbuffers"]), blocksize = int(OutputConfigs["framesize"])*options.frame_duration*options.frames_per_file, buffer_mode = int(OutputConfigs["buffermode"]))
elif OutputConfigs["datasink"] == "frames":
	pipeparts.mkframecppfilesink(pipeline, mux, frame_type = OutputConfigs["frametype"], path = options.output_path, instrument = instrument) 

# Run pipeline

if DebuggingConfigs["pipelinegraphfilename"] != "None":
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(DebuggingConfigs["pipelinegraphfilename"], "NULL"), verbose = verbose)

# Seek the pipeline when necessary
if InputConfigs["datasource"] == "frames":
	if verbose:
		print("seeking GPS start and stop times ...", file=sys.stderr)
	if pipeline.set_state(Gst.State.READY) != Gst.StateChangeReturn.SUCCESS:
		raise RuntimeError("pipeline failed to enter READY state")
	datasource.pipeline_seek_for_gps(pipeline, gps_start_time, gps_end_time)

if verbose:
	print("setting pipeline state to playing ...", file=sys.stderr)
if pipeline.set_state(Gst.State.PLAYING) != Gst.StateChangeReturn.SUCCESS:
	raise RuntimeError("pipeline failed to enter PLAYING state")
else:
	if verbose:
		print("set to playing successfully")
if DebuggingConfigs["pipelinegraphfilename"] != "None":
	pipeparts.write_dump_dot(pipeline, "%s.%s" %(DebuggingConfigs["pipelinegraphfilename"], "PLAYING"), verbose = verbose)
	
if verbose:
	print("running pipeline ...", file=sys.stderr)

mainloop.run()

if pipeline.set_state(Gst.State.NULL) != Gst.StateChangeReturn.SUCCESS:
	raise RuntimeError("pipeline could not be set to NULL")
