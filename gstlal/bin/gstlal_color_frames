#!/usr/bin/python
#
# Copyright (C) 2012  Kipp Cannon, Chad Hanna, Drew Keppel
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot
import scipy
import numpy
from gstlal import pipeparts
from gstlal import reference_psd
from gstlal import lloidparts
from optparse import OptionParser, Option
from glue import segments
from pylal.datatypes import LIGOTimeGPS
import pygtk
pygtk.require("2.0")
import gobject
gobject.threads_init()
import pygst
pygst.require("0.10")
import gst
import sys
import os

parser = OptionParser(description = __doc__)
parser.add_option("--gps-start-time", metavar = "seconds", help = "Set the start time of the segment to analyze in GPS seconds (required).  Can be specified to nanosecond precision.")
parser.add_option("--gps-end-time", metavar = "seconds", help = "Set the end time of the segment to analyze in GPS seconds (required).  Can be specified to nanosecond precision.")
parser.add_option("--instrument", metavar = "name", help = "Set the name of the instrument to analyze, e.g. \"H1\" (required).")
parser.add_option("--channel-name", metavar = "name", default = "LSC-STRAIN", help = "Set the name of the channel to process (optional).  The default is \"LSC-STRAIN\".")
parser.add_option("--duration", metavar = "s", default = 64, type = "int", help = "Set the duration of the output frame files")
parser.add_option("--color-psd", metavar = "name", help = "Set the name of psd xml file to recolor the data with")
parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")
parser.add_option("--sample-rate", metavar = "Hz", default = 4096, type = "int", help = "Sample rate at which to generate the data, should be less than or equal to the sample rate of the measured psds provided, default = 4096 Hz")

#
# Parse options
#

options, filenames = parser.parse_args()

sr = options.sample_rate

#
# read psd file
#

rpsd = reference_psd.read_psd(options.color_psd, verbose = options.verbose)[options.instrument]

#
# create input segment for the seek
#

seg = segments.segment(LIGOTimeGPS(options.gps_start_time), LIGOTimeGPS(options.gps_end_time))

#
# Setup the pipeline
#

pipeline = gst.Pipeline(sys.argv[0])
mainloop = gobject.MainLoop()
handler = lloidparts.LLOIDHandler(mainloop, pipeline)
seekevent = gst.event_new_seek(1.0, gst.Format(gst.FORMAT_TIME), gst.SEEK_FLAG_FLUSH | gst.SEEK_FLAG_KEY_UNIT, gst.SEEK_TYPE_SET, seg[0].ns(), gst.SEEK_TYPE_SET, seg[1].ns())

#
# Construct a white noise source
#

head = pipeparts.mkfakesrcseeked(pipeline, options.instrument, options.channel_name, seekevent, blocksize = 16384 * 8 * 16, volume = 1, is_live = False, wave = 9, rate = sr)
head = pipeparts.mkprogressreport(pipeline, head, "frames")

#
# Color kernel
#

max_sample = int(round(1.0 / rpsd.deltaF * sr / 2.0)) + 1 

# truncate to requested output sample rate, if it is higher than the psd provides an assert will fail later
rpsd.data = 1. / rpsd.data[:max_sample]
fir_matrix, latency, measured_sample_rate = reference_psd.psd_to_fir_kernel(rpsd)

# add latency to fix the time stamps
latency -= 1
head = pipeparts.mkfirbank(pipeline, head, latency = latency, fir_matrix = [fir_matrix], block_stride = sr * 32)


#
# Output stage
#

# put the units to strain before writing to frames
head = pipeparts.mktaginject(pipeline, head, "units=strain")

try:
	outpath = options.instrument+"-"+options.channel_name
	os.mkdir(outpath)
except:
	pass
pipeparts.mkframesink(pipeline, head, path=outpath, sync=False, async=True, frame_type=options.instrument, duration = options.duration)

#
# Run it
#

pipeline.set_state(gst.STATE_PAUSED)
pipeline.set_state(gst.STATE_PLAYING)

mainloop.run()

