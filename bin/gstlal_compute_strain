#!/usr/bin/env python
#
# Copyright (C) 2010, 2011  Jordi Burguet-Castell
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""\
Generate h(t).

It tries to mimic the behavior of lalapps_ComputeStrainDriver (which
uses LAL's ComputeStrain.c). It does not compute the gamma factors for
the moment.

It reads DARM_ERR and DARM_CTRL from the gwf files specified in the
cache file. The filters file has to be in numpy's npz format, and can
be generated from an old one with calfilters2npz.py (in
examples/utilities).
"""

import sys
from optparse import OptionParser

from numpy import load


#
# Read command-line options
#

parser = OptionParser(
    version='%prog 0.95',
    usage='%prog [options]',
    description=__doc__)

add = parser.add_option  # for short notation
add('--gps-start-time', type='int', help='GPS start time')
add('--gps-end-time',   type='int', help='GPS end time')
add('--filters-file', help='Name of file containing filters (in npz format)')
add('--frame-cache',  help='Name of frame cache file')
add('--ifo',          help='Name of the interferometer (H1, H2, L1)')
add('--wings', type='int', default=16, help='Size of wings in seconds')
add('--frame-type', default='GSTLAL_CAL', help='Frame type to be written')
add('--silent', action='store_true', help='Be less verbose')

opts, rest = parser.parse_args()

# Check options (help if any of the required ones is None)
if None in [opts.gps_start_time, opts.gps_end_time,
            opts.filters_file, opts.frame_cache, opts.ifo]:
    print 'Missing required option (sorry for the oxymoron).\n'
    parser.print_help()
    print """\nExample:
  %s --gps-start-time 943009024  --gps-end-time $((943009024+64)) \\
     --filters-file filters.npz  --frame-cache data.cache  --ifo H1 \\
     --frame-type H1_GSTLAL_C02""" % sys.argv[0]
    sys.exit()


#
# Initialization
#

import pygtk
pygtk.require('2.0')
import pygst
pygst.require('0.10')
import gobject, gst
from gstlal.pipeutil import mkelem

if not opts.silent:
    print 'Processing data from time %d to %d (%d seconds)' % \
        (opts.gps_start_time, opts.gps_end_time,
         opts.gps_end_time - opts.gps_start_time)
    print 'Opening filters file %s' % opts.filters_file

filters = load(opts.filters_file)

if not opts.silent:
    print 'Entering main loop'

mainloop = gobject.MainLoop()
pipeline = gst.Pipeline('calibration')


#
# Creation of the pipeline. We create the elements and connect them
# appropriately.
#
# It looks like:
#
#   derr  -> 1/C              [1]  \
#                                   |->  [3] save
#   dctrl -> HPx2 -> AW -> A  [2]  /
#

# [1] Elements in the first path (from DARM_ERR channel)

derr_src = mkelem('lal_framesrc',
                  {'location': opts.frame_cache,
                   'channel-name': 'LSC-DARM_ERR',
                   'instrument': opts.ifo,
                   'blocksize': 524288})

audioconvert0 = mkelem('audioconvert')  # lal_firbank only supports doubles

inv_sensing = mkelem('audiofirfilter',
                     {'kernel': filters['inv_sensing'],
                      'latency': int(-filters['inv_sens_delay'])})
# the *delay* is negative (an advance), and so latency=-delay ... funny legacy

path1 = [derr_src, audioconvert0, inv_sensing]  # so we write less later


# [2] Elements in the second path (from DARM_CTRL channel)

dctrl_src = mkelem('lal_framesrc',
                   {'location': opts.frame_cache,
                    'channel-name': 'LSC-DARM_CTRL',
                    'instrument': opts.ifo,
                    'blocksize': 524288})

audioconvert1 = mkelem('audioconvert')  # lal_firbank only supports doubles

hpf0 = mkelem('audiowsinclimit',
              {'mode': 1,  # high pass filter
               'cutoff': 20,  # cf. ComputeStrain.c (0.00244140625 * 16384/2)
               'window': 2,  # gaussian
               'length': 2*2000+1})  # 2 * N_FIR_HP + 1, cf. ComputeStrain.c

hpf1 = mkelem('audiowsinclimit',   # again! wish I could just copy it!
              {'mode': 1,
               'cutoff': 20,
               'window': 2,
               'length': 2*2000+1})

awhiten = mkelem('audiofirfilter',
                 {'kernel': filters['awhitening']})

actuation = mkelem('audiofirfilter',
                   {'kernel': filters['actuation']})

path2 = [dctrl_src, audioconvert1, hpf0, hpf1, awhiten, actuation]


# [3] Elements from adder to saving the result

Fs = 16384  # sampling rate
T = opts.gps_end_time - opts.gps_start_time  # original duration

path3 = [mkelem(*x) for x in [ \
    ('lal_adder', {'sync': True}),
    ('taginject', {'tags': 'channel-name=LDAS-STRAIN'}),  # or GSTLAL-STRAIN
    ('lal_trim', {'initial-offset': Fs * opts.wings,
                  'final-offset':  Fs * (T - opts.wings)}),
    ('lal_framesink', {'frame-type': opts.frame_type,
                       'async': False,  # though now should be by default!
                       'duration': T - 2 * opts.wings})]]


# Add to pipeline and link

pipeline.add(* path1 + path2 + path3)  # means ...add(derr_src, audioc...)

gst.element_link_many(*path1)  # [1]
gst.element_link_many(*path2)  # [2]

path1[-1].link(path3[0])  # [1] \
                          #      |-> [3]
path2[-1].link(path3[0])  # [2] /

gst.element_link_many(*path3)  # [3]


#
# Make it start playing at the appropiate reference gpstime
#

for src in pipeline.iterate_sources():
    src.seek(1.0, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
             gst.SEEK_TYPE_SET, opts.gps_start_time * 1e9,
             gst.SEEK_TYPE_SET, opts.gps_end_time * 1e9)


#
# Boilerplate
#

class Handler(object):
    def __init__(self, mainloop, pipeline):
        self.mainloop = mainloop
        self.pipeline = pipeline

        bus = pipeline.get_bus()
        bus.add_signal_watch()
        bus.connect("message", self.on_message)

    def on_message(self, bus, message):
        if message.type == gst.MESSAGE_EOS:
            self.pipeline.set_state(gst.STATE_NULL)
            self.mainloop.quit()
        elif message.type == gst.MESSAGE_ERROR:
            gerr, dbgmsg = message.parse_error()
            self.pipeline.set_state(gst.STATE_NULL)
            self.mainloop.quit()
            sys.exit("error (%s:%d '%s'): %s" % (gerr.domain, gerr.code,
                                                 gerr.message, dbgmsg))

handler = Handler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
