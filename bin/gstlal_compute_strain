#!/usr/bin/env python
#
# Copyright (C) 2010  Jordi Burguet-Castell
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Generate h(t).

It tries to mimic the behavior of LAL's ComputeStrain.c . It does not
compute the gamma factors for the moment.

It reads DARM_ERR and DARM_CTRL from H-H1_RDS_R_L1-943009024-64.gwf as
specified in data.cache. The filters file it uses is a npz version of
S6H1Filters_942436815.txt
"""

# To generate filters.npz you can use the program at
# gstlal/examples/utilities/calfilters2npz.py

import sys
from optparse import OptionParser

from numpy import load, atleast_2d


#
# Read command-line options
#

parser = OptionParser(
    version='%prog 0.9',
    usage='%prog [options]',
    description=__doc__)

add = parser.add_option  # for short notation
add('--gps-start-time', type='int', help='GPS start time')
add('--gps-end-time',   type='int', help='GPS end time')
add('--filters-file', help='Name of file containing filters (in npz format)')
add('--frame-cache',  help='Name of frame cache file')
add('--ifo',          help='Name of the interferometer (H1, H2, L1)')
add('--frame-type',   help='Frame type to be written (eg, H1_GSTLAL_C02)')
add('--debug',  action='store_true', help='Dump intermediate steps to files')
add('--silent', action='store_true', help='Be less verbose')

opts, rest = parser.parse_args()

# Use default arguments for testing. Temporary!
if opts.gps_start_time is None:
    opts.gps_start_time = 943009024

if opts.gps_end_time is None:
    opts.gps_end_time = 943009024 + 64

if opts.filters_file is None:
    opts.filters_file = 'filters.npz'

if opts.frame_cache is None:
    opts.frame_cache = 'data.cache'

if opts.ifo is None:
    opts.ifo = 'H1'

if opts.frame_type is None:
    opts.frame_type = opts.ifo + '_GSTLAL_C02'


#
# Initialization
#

import pygtk
pygtk.require('2.0')
import pygst
pygst.require('0.10')
import gobject, gst
from gstlal.pipeutil import mkelem

if not opts.silent:
    print 'Processing data from time %d to %d (%d seconds)' % \
        (opts.gps_start_time, opts.gps_end_time,
         opts.gps_end_time - opts.gps_start_time)
    print 'Opening filters file %s' % opts.filters_file

filters = load(opts.filters_file)

if not opts.silent:
    print 'Entering main loop'

mainloop = gobject.MainLoop()
pipeline = gst.Pipeline('calibration')


#
# Creation of the pipeline. We create the elements and connect them
# appropriately.
#
# It looks like:
#
#   derr  -> 1/C              [1]  \
#                                   |->  [3] save
#   dctrl -> HPx2 -> AW -> A  [2]  /
#

# [1] Elements in the first path (from DARM_ERR channel)

derr_src = mkelem('lal_framesrc',
                  {'location': opts.frame_cache,
                   'channel-name': 'LSC-DARM_ERR',
                   'instrument': opts.ifo,
                   'blocksize': 524288})

pr1 = mkelem('progressreport',
             {'name': 'DARM_ERR progress',
              'silent': opts.silent})

audioconvert1 = mkelem('audioconvert')  # lal_firbank only supports doubles

inv_sensing = mkelem('lal_firbank',
                     {'fir-matrix': atleast_2d(filters['inv_sensing'][::-1]),
                      'latency': -filters['inv_sens_delay']})  # +/-? careful!

path1 = [derr_src, pr1, audioconvert1, inv_sensing]  # so we write less later


# [2] Elements in the second path (from DARM_CTRL channel)

dctrl_src = mkelem('lal_framesrc',
                   {'location': opts.frame_cache,
                    'channel-name': 'LSC-DARM_CTRL',
                    'instrument': opts.ifo,
                    'blocksize': 524288})

pr2 = mkelem('progressreport',
             {'name': 'DARM_CTRL progress',
              'silent': opts.silent})

audioconvert2 = mkelem('audioconvert')  # lal_firbank only supports doubles

hpf = mkelem('audiowsinclimit',
             {'mode': 1,  # high pass filter
              'cutoff': 0.00244140625 * 16384/2,  # cf. ComputeStrain.c
              'window': 2,  # gaussian
              'length': 2*2000+1})  # 2 * N_FIR_HP + 1, cf. ComputeStrain.c

hpf2 = mkelem('audiowsinclimit',   # again! wish I could just copy it!
              {'mode': 1,
               'cutoff': 0.00244140625 * 16384/2,
               'window': 2,  # gaussian
               'length': 2*2000+1})

awhiten = mkelem('lal_firbank',
                 {'fir-matrix': atleast_2d(filters['awhitening'][::-1]),
                  'time-domain': False})

actuation = mkelem('lal_firbank',
                   {'fir-matrix': atleast_2d(filters['actuation'][::-1]),
                    'time-domain': False})

path2 = [dctrl_src, pr2, audioconvert2, hpf, hpf2, awhiten, actuation]


# [3] Elements from adder to saving the result

path3 = [mkelem(*x) for x in [ \
    ('lal_adder', {'sync': True}),
    ('taginject', {'tags': 'channel-name=LDAS-STRAIN'}),  # or GSTLAL-STRAIN
    ('lal_framesink', {'frame-type': opts.frame_type,
                       'async': False,  # though now should be by default!
                       'duration': 16,
                       'clean-timestamps': False}),  # should work with True
    ]]


# Add to pipeline and link

pipeline.add(* path1 + path2 + path3)

gst.element_link_many(*path1)  # [1]
gst.element_link_many(*path2)  # [2]

path1[-1].link(path3[0])  # [1] \
                          #      |-> [3]
path2[-1].link(path3[0])  # [2] /

gst.element_link_many(*path3)  # [3]


#
# Debugging
#

def extract(pipeline, elem1, elem2, filename):
    """Take a couple of linked elements elem1->elem2 in a pipeline and
    extract the data flowing betweem them to a file."""
    tee = mkelem('tee')
    pipeline.add(tee)
    elem1.unlink(elem2)
    elem1.link(tee)
    tee.link(elem2)

    save_path = [mkelem(*x) for x in [ \
        ('queue',        {}),
        ('audioconvert', {}),
        ('lal_nxydump',  {}),
        ('filesink',    {'location': 'gstlal_' + filename,
                         'sync': False,
                         'async': False})]]
    pipeline.add(*save_path)
    tee.link(save_path[0])
    gst.element_link_many(*save_path)

if opts.debug is not None:
    extract(pipeline, derr_src, pr1, 'DARM_ERR.txt')
    extract(pipeline, inv_sensing, path3[0], 'C_inv_adv_DARM_ERR.txt')
    extract(pipeline, dctrl_src, pr2, 'DARM_CTRL.txt')
    extract(pipeline, hpf2, awhiten, 'HPFx2_adv_DARM_CTRL.txt')
    extract(pipeline, awhiten, actuation, 'AW_HPFx2_adv_DARM_CTRL.txt')
    extract(pipeline, actuation, path3[0], 'A_AW_HPFx2_adv_DARM_CTRL.txt')
    extract(pipeline, path3[1], path3[2], 'STRAIN.txt')


#
# Make it start playing at the appropiate reference gpstime
#

path1[0].seek(1.0, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
              gst.SEEK_TYPE_SET, opts.gps_start_time * 1e9,
              gst.SEEK_TYPE_SET, opts.gps_end_time * 1e9)
path2[0].seek(1.0, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
              gst.SEEK_TYPE_SET, opts.gps_start_time * 1e9,
              gst.SEEK_TYPE_SET, opts.gps_end_time * 1e9)


#
# Boilerplate
#

class Handler(object):
    def __init__(self, mainloop, pipeline):
        self.mainloop = mainloop
        self.pipeline = pipeline

        bus = pipeline.get_bus()
        bus.add_signal_watch()
        bus.connect("message", self.on_message)

    def on_message(self, bus, message):
        if message.type == gst.MESSAGE_EOS:
            self.pipeline.set_state(gst.STATE_NULL)
            self.mainloop.quit()
        elif message.type == gst.MESSAGE_ERROR:
            gerr, dbgmsg = message.parse_error()
            self.pipeline.set_state(gst.STATE_NULL)
            self.mainloop.quit()
            sys.exit("error (%s:%d '%s'): %s" % (gerr.domain, gerr.code,
                                                 gerr.message, dbgmsg))

handler = Handler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
