#!/usr/bin/python

"""
Generate h(t).

It tries to mimic the behavior of LAL's ComputeStrain.c . It does not
compute the gamma factors for the moment.

It reads DARM_ERR and DARM_CTRL from H-H1_RDS_R_L1-943009024-64.gwf as
specified in data.cache. The filters file it uses is a npz version of
S6H1Filters_942436815.txt
"""

# TODO:
#   change name of filter "sensing" -> "isensing"
#   change name of vars derr,dctrl to smtg sensible
#   make it work! (compared to dumped frame)

import sys
from numpy import load, atleast_2d

import pygtk
pygtk.require('2.0')
import pygst
pygst.require('0.10')
import gobject, gst
from gstlal import pipeutil

mainloop = gobject.MainLoop()
pipeline = gst.Pipeline('calibration')

# Read filters file
filters = load('filters.npz')

# Time we use to start calibrating
ref_gpstime = 943009024
duration = 48

# Description of elements in the first path (from DARM_ERR channel)
desc_derr = [
    ('lal_framesrc',   {'location': 'data.cache',
                        'channel-name': 'LSC-DARM_ERR',
                        'instrument': 'H1',
                        'blocksize': 524288}),
    ('progressreport', {'name': 'DARM_ERR progress'}),
    ('audioconvert',   {}),  # because lal_firbank only supports doubles
    ('lal_firbank',    {'fir-matrix': atleast_2d(filters['sensing']),
                        'latency': filters['sens_delay']}),
    ]

# Description of elements in the second path (from DARM_CTRL channel)
desc_dctrl = [
    ('lal_framesrc',    {'location': 'data.cache',
                         'channel-name': 'LSC-DARM_CTRL',
                         'instrument': 'H1',
                         'blocksize': 524288}),
    ('progressreport',  {'name': 'DARM_CTRL progress'}),
    ('audioconvert',    {}),  # because lal_firbank only supports doubles
    ('audiowsinclimit', {'mode': 1,  # high-pass filter
                         'cutoff': 0.00244140625 * 16384/2,  # cf ComputeStrain.c
                         'length': 2*2000+1}),
    ('audiowsinclimit', {'mode': 1,  # again!
                         'cutoff': 0.00244140625 * 16384/2,
                         'length': 2*2000+1}),
    ('lal_firbank',     {'fir-matrix': atleast_2d(filters['awhitening'])}),
    ('lal_firbank',     {'fir-matrix': atleast_2d(filters['actuation'])}),
    ]

# Description of elements from adder to saving the result
desc_addnsave = [
    ('lal_adder',   {}),
    ('lal_nxydump', {}),
    ('filesink',    {'location': 'output.txt'}),
    ]

# Create the elements and link appropiately
derr  = [pipeutil.mkelem(*x) for x in desc_derr]
dctrl = [pipeutil.mkelem(*x) for x in desc_dctrl]
addnsave = [pipeutil.mkelem(*x) for x in desc_addnsave]

pipeline.add(*derr+dctrl+addnsave)  # add all

gst.element_link_many(*derr)     # derr  -> 1/C  [1]
gst.element_link_many(*dctrl)    # dctrl -> AW -> A  [2]
derr[-1].link(addnsave[0])       # [1] \
                                 #       + [3]
dctrl[-1].link(addnsave[0])      # [2] /
gst.element_link_many(*addnsave) # [3] -> save

# Make it start playing at the appropiate reference gpstime
derr[0].seek(1.0, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
             gst.SEEK_TYPE_SET, ref_gpstime * 1e9,
             gst.SEEK_TYPE_SET, (ref_gpstime + duration) * 1e9)
dctrl[0].seek(1.0, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
              gst.SEEK_TYPE_SET, ref_gpstime * 1e9,
              gst.SEEK_TYPE_SET, (ref_gpstime + duration) * 1e9)

# Boilerplate
class Handler(object):
    def __init__(self, mainloop, pipeline):
        self.mainloop = mainloop
        self.pipeline = pipeline

        bus = pipeline.get_bus()
        bus.add_signal_watch()
        bus.connect("message", self.on_message)

    def on_message(self, bus, message):
        if message.type == gst.MESSAGE_EOS:
            self.pipeline.set_state(gst.STATE_NULL)
            self.mainloop.quit()
        elif message.type == gst.MESSAGE_ERROR:
            gerr, dbgmsg = message.parse_error()
            self.pipeline.set_state(gst.STATE_NULL)
            self.mainloop.quit()
            sys.exit("error (%s:%d '%s'): %s" % (gerr.domain, gerr.code, gerr.message, dbgmsg))

handler = Handler(mainloop, pipeline)

pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
