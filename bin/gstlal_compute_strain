#!/usr/bin/env python
#
# Copyright (C) 2010, 2011  Jordi Burguet-Castell
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""\
Generate h(t).

It tries to mimic the behavior of lalapps_ComputeStrainDriver (which
uses LAL's ComputeStrain.c). It does not compute the gamma factors for
the moment.

It reads DARM_ERR and DARM_CTRL from the gwf files specified in the
cache file. The filters file has to be in numpy's npz format, and can
be generated from an old one with calfilters2npz.py (in examples/utilities).
"""

import sys
from optparse import OptionParser


#
# Initialization
#

# Read command-line options, check and help if a required one is missing

parser = OptionParser(
    version='%prog 0.95',
    usage='%prog [options]',
    description=__doc__)

add = parser.add_option  # for short notation
add('--gps-start-time', type='int', help='GPS start time')
add('--gps-end-time',   type='int', help='GPS end time')
add('--filters-file', help='Name of file containing filters (in npz format)')
add('--frame-cache',  help='Name of frame cache file')
add('--ifo',          help='Name of the interferometer (H1, H2, L1)')
add('--wings', type='int', default=16, help='Size of wings in seconds')
add('--frame-type', default='GSTLAL_CAL', help='Frame type to be written')
add('--doubles', action='store_true', help='Use doubles instead of floats')

opts, rest = parser.parse_args()

if None in [opts.gps_start_time, opts.gps_end_time,
            opts.filters_file, opts.frame_cache, opts.ifo]:
    print 'Missing required option (sorry for the oxymoron).\n'
    parser.print_help()
    print """\nExample:
  %s --gps-start-time 943009024  --gps-end-time $((943009024+64)) \\
     --filters-file filters.npz  --frame-cache data.cache  --ifo H1 \\
     --frame-type H1_GSTLAL_C02""" % sys.argv[0]
    sys.exit()


# Finish importing (not before, so --help works), read filters, set data width

from numpy import load  # only used once to read the filters file
from gstlal.pipeutil import mkelem
import gobject, gst

filters = load(opts.filters_file)

if opts.doubles is None:
    caps = gst.Caps('audio/x-raw-float,width=32')  # = 4 bytes, a float
else:
    caps = gst.Caps('audio/x-raw-float,width=64')  # = 8 bytes, a double


#
# Creation of the pipeline. We create the elements and connect them
# appropriately.
#
# It looks like:
#
#   derr  -> 1/C              [1]  \
#                                   |->  [3] save
#   dctrl -> HPx2 -> AW -> A  [2]  /
#

# [1] Elements in the first path (from DARM_ERR channel)

derr_src = mkelem('lal_framesrc',
                  {'location': opts.frame_cache,
                   'channel-name': 'LSC-DARM_ERR',
                   'instrument': opts.ifo,
                   'blocksize': 5000000})

inv_sensing = mkelem('audiofirfilter',
                     {'kernel': filters['inv_sensing'],
                      'latency': int(-filters['inv_sens_delay'])})
# the *delay* is negative (an advance), and so latency=-delay ... funny legacy

path1 = [derr_src,
         mkelem('audioconvert'),  # a NOP if we don't convert to doubles
         mkelem('capsfilter', {'caps': caps}),
         inv_sensing]


# [2] Elements in the second path (from DARM_CTRL channel)

dctrl_src = mkelem('lal_framesrc',
                   {'location': opts.frame_cache,
                    'channel-name': 'LSC-DARM_CTRL',
                    'instrument': opts.ifo,
                    'blocksize': 5000000})

hpf0 = mkelem('audiowsinclimit',
              {'mode': 1,  # high pass filter
               'cutoff': 20,  # cf. ComputeStrain.c (0.00244140625 * 16384/2)
               'window': 2,  # gaussian
               'length': 2*2000+1})  # 2 * N_FIR_HP + 1, cf. ComputeStrain.c

hpf1 = mkelem('audiowsinclimit',   # again! wish I could just copy it!
              {'mode': 1,
               'cutoff': 20,
               'window': 2,
               'length': 2*2000+1})

awhiten = mkelem('audiofirfilter',
                 {'kernel': filters['awhitening']})

actuation = mkelem('audiofirfilter',
                   {'kernel': filters['actuation']})

path2 = [dctrl_src,
         mkelem('audioconvert'),
         mkelem('capsfilter', {'caps': caps}),
         hpf0, hpf1, awhiten, actuation]


# [3] Elements from adder to saving the result

Fs = 16384  # sampling rate
T = opts.gps_end_time - opts.gps_start_time  # original duration

path3 = [mkelem(*x) for x in [ \
    ('lal_adder', {'sync': True}),
    ('taginject', {'tags': 'channel-name=LDAS-STRAIN'}),  # or GSTLAL-STRAIN
    ('lal_trim', {'initial-offset': Fs * opts.wings,
                  'final-offset':  Fs * (T - opts.wings)}),
    ('lal_framesink', {'frame-type': opts.frame_type,
                       'duration': T - 2 * opts.wings})]]


# Add to pipeline and link

pipeline = gst.Pipeline('calibration')

pipeline.add(* path1 + path2 + path3)  # means ...add(derr_src, inv_sens...)

gst.element_link_many(*path1)  # [1]
gst.element_link_many(*path2)  # [2]

path1[-1].link(path3[0])  # [1] \
                          #      |-> [3]
path2[-1].link(path3[0])  # [2] /

gst.element_link_many(*path3)  # [3]


#
# Boilerplate
#

# Start playing at the appropriate reference gpstime

for src in pipeline.iterate_sources():
    src.seek(1.0, gst.FORMAT_TIME, gst.SEEK_FLAG_FLUSH,
             gst.SEEK_TYPE_SET, opts.gps_start_time * 1e9,
             gst.SEEK_TYPE_SET, opts.gps_end_time * 1e9)


# Create main loop, catch finish and error signals

mainloop = gobject.MainLoop()

bus = pipeline.get_bus()
bus.add_signal_watch()  # emit message signal for messages posted on the bus

def on_message(bus, message):  # message handler
    if message.type in [gst.MESSAGE_EOS, gst.MESSAGE_ERROR]:
        pipeline.set_state(gst.STATE_NULL)
        mainloop.quit()
        if message.type == gst.MESSAGE_ERROR:
            gerr, dbgmsg = message.parse_error()
            sys.exit('Error: %s\n%s' % (gerr.message, dbgmsg))

bus.connect('message', on_message)

pipeline.set_state(gst.STATE_PLAYING)
mainloop.run()
