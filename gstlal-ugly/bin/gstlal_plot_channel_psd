#!/usr/bin/env python
#
# Copyright (C) 2012-2015  Chad Hanna
# Copyright (C) 2015  Kipp Cannon
# Copyright (C) 2017  Patrick Godwin
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


from optparse import OptionParser
import os
import sys
import logging
import math
import numpy
import matplotlib
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas

from lal import series
from glue.ligolw import utils as ligolw_utils
from glue.ligolw import lsctables
from gstlal import plotutil

matplotlib.rcParams.update({
	"font.size": 10.0,
	"axes.titlesize": 10.0,
	"axes.labelsize": 10.0,
	"xtick.labelsize": 8.0,
	"ytick.labelsize": 8.0,
	"legend.fontsize": 8.0,
	"figure.dpi": 300,
	"savefig.dpi": 300,
	"text.usetex": True,
	"path.simplify": True
})



## @file
# A program to plot reference psds; see gstlal_plot_channel_psd for more info
#
# A program to plot a psd such as one generated by gstlal_reference_psd
#
# ### Usage:
#
#		gstlal_plot_channel_psd -o OUTPUT-NAME PSD-FILE-1 PSD-FILE-2
#
# e.g.,
#
#		gstlal_plot_channel_psd -o psd.png psd.xml.gz
#

color_scheme = ['#332288', '#88CCEE', '#44AA99', '#117733', '#999933', '#DDCC77', '#CC6677', '#882255', '#AA4499']

def parse_command_line():
	parser = OptionParser()
	parser.add_option("-o", "--output", help = "Set plot filename (default = replace input file's extension with .png).")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if not filenames:
		raise ValueError("must supply at least one input filename")
	if options.output and len(filenames) > 1:
		raise ValueError("must supply only one input file when setting --output")

	return options, filenames

def plot_psds(psds, plot_width = 640):
	"""!
	Produces a matplotlib figure of PSDs. 

	@param psds A dictionary of PSDs as REAL8FrequencySeries keyed by
	channel

	@param plot_width How wide to make the plot in pixels
	"""
	on_channels = set(psds)
	fig = figure.Figure()
	FigureCanvas(fig)
	fig.set_size_inches(plot_width / float(fig.get_dpi()), int(round(plot_width / plotutil.golden_ratio)) / float(fig.get_dpi()))
	axes = fig.gca()
	axes.grid(which = "both", linestyle = "-", linewidth = 0.2)

	min_psds, max_psds = [], []
	min_fs, max_fs = [], []
	color_index = 0
	for channel, psd in sorted(psds.items()):
		if psd is None:
			continue
		psd_data = psd.data.data
		f = psd.f0 + numpy.arange(len(psd_data)) * psd.deltaF
		logging.info("found PSD for %s spanning [%g Hz, %g Hz]" % (channel, f[0], f[-1]))
		min_fs.append(f[0])
		max_fs.append(f[-1])
		if channel in on_channels:
			alpha = 0.8
			linestyle = "-"
		else:
			alpha = 0.6
			linestyle = ":"
		label = r"%s" % channel.replace('_', '\_')
		axes.loglog(f, psd_data, alpha = alpha, color = color_scheme[color_index], linestyle = linestyle, label = label)
		# record the minimum from within the rage 10 Hz -- 1 kHz
		min_psds.append(min([x for x in psd_data[int((10.0 - psd.f0) / psd.deltaF) : int((1000 - psd.f0) / psd.deltaF)] if x > 0]))
		# record the maximum from within the rage 1 Hz -- 1 kHz
		max_psds.append(psd_data[int((1.0 - psd.f0) / psd.deltaF) : int((1000 - psd.f0) / psd.deltaF)].max())
		color_index += 1
	if min_fs:
		axes.set_xlim((6.0, max(max_fs)))
	else:
		axes.set_xlim((6.0, 3000.0))
	if min_psds:
		axes.set_ylim((10**math.floor(math.log10(min(min_psds))), 10**math.ceil(math.log10(max(max_psds)))))
	title = r"Noise Spectral Density"
	axes.set_title(title)
	axes.set_xlabel(r"Frequency (Hz)")
	axes.set_ylabel(r"Spectral Density ($\mathrm{1} / \mathrm{Hz}$)")
	axes.legend(loc = "upper right")
	fig.tight_layout(pad = .8)

	return fig


options, filenames = parse_command_line()
for fname in filenames:
	if options.output:
		outname = options.output
	else:
		outname = os.path.splitext(fname)[0] + ".png"
	
	fig = plot_psds(
		series.read_psd_xmldoc(
			ligolw_utils.load_filename(
				fname,
				verbose = options.verbose,
				contenthandler = series.PSDContentHandler
			)
		),
		plot_width = 2400
	)

	fig.savefig(outname)

