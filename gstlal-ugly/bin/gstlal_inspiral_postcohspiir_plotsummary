#!/usr/bin/env python
#
# Copyright (C) 2017  Qi Chu adapted from gstlal_inspiral_plotsummary
# Copyright (C) 2009-2013  Kipp Cannon, Chad Hanna, Drew Keppel
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

## @file
# A program to produce a variety of plots from a gstlal inspiral analysis, e.g. IFAR plots, missed found, etc.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import math
import matplotlib
matplotlib.rcParams.update({
	"font.size": 16.0,
	"axes.titlesize": 14.0,
	"axes.labelsize": 14.0,
	"xtick.labelsize": 13.0,
	"ytick.labelsize": 13.0,
	"legend.fontsize": 10.0,
	"figure.dpi": 300,
	"savefig.dpi": 300,
	"text.usetex": True,
	"path.simplify": True
})
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
import scipy
import numpy
from optparse import OptionParser
import sqlite3
import sys
import os
import re

from glue import segments
from glue.ligolw import dbtables
from glue.ligolw import lsctables
from glue.ligolw.utils import segments as ligolw_segments
from glue import lal
from pylal import db_thinca_rings
from pylal import git_version
from pylal import SimBurstUtils
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS
from gstlal import cohfar
from gstlal import far
from gstlal import inspiral_pipe

from gstlal import postcoh_table_def
from gstlal import gviz_api
import pdb

def to_google_json(fname, description, data):
	json = open(fname,"w")
	data_table = gviz_api.DataTable(description)
	data_table.LoadData(data)
	print >> json, data_table.ToJSon()
	json.close()


class SimInspiral(lsctables.SimInspiral):
	@property
	def mtotal(self):
		return self.mass1 + self.mass2

	@property
	def chi(self):
		return (self.mass1 * self.spin1z + self.mass2 * self.spin2z) / self.mtotal


	def get_exp_snr(self, instrument):
		if instrument == "H1":
			return self.alpha1
		if instrument == "L1":
			return self.alpha2
		return 0.0


class PostcohInspiral(postcoh_table_def.PostcohInspiral):
	@property
	def chi(self):
		return (self.mass1 * self.spin1z + self.mass2 * self.spin2z) / self.mtotal


	def get_effective_snr(self, fac):
		return self.snr / (self.chisq / self.chisq_dof)**.5

        def get_ifo_endtime(self, instrument):
                end_time = getattr(self, "end_time_%s" % instrument[0])
                end_time_ns = getattr(self, "end_time_ns_%s" % instrument[0])
                return LIGOTimeGPS(end_time, end_time_ns)

        def get_eff_distance(self, instrument):
                return getattr(self, "deff_%s" % instrument[0])

        def get_snglsnr(self, instrument):
                return getattr(self, "snglsnr_%s" % instrument[0])


lsctables.LIGOTimeGPS = LIGOTimeGPS
lsctables.SimInspiralTable.RowType = SimInspiral
postcoh_table_def.PostcohInspiralDBTable.RowType = PostcohInspiral


__author__ = "Kipp Cannon <kipp.cannon@ligo.org>, Chad Hanna <channa@ligo.caltech.edu>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "Name: %%prog\n%s" % git_version.verbose_msg
	)
	parser.add_option("--noninj-database", metavar = "noninj-database", default = None, help = "noninj database.")
	parser.add_option("--shift-database", metavar = "shift-database", default = None, help = "shifted database.")
	parser.add_option("--inj-database", metavar = "inj-database", default = None, help = "one or multiple inj database.")
	parser.add_option("--noninj-user-tag", metavar = "user-tag", default = "ALL", help = "Set the prefix for output filenames (default = \"ALL\").")
	parser.add_option("--shift-user-tag", metavar = "user-tag", default = "ALL", help = "Set the prefix for output filenames (default = \"ALL\").")
	parser.add_option("--inj-user-tag", metavar = "user-tag", default = "ALL", help = "Set the prefix for output filenames (default = \"ALL\").")
	parser.add_option("--output-dir", metavar = "output-dir", default = ".", help = "Provide an output directory")
	parser.add_option("-f", "--format", metavar = "{\"png\",\"pdf\",\"svg\",\"eps\",...}", action = "append", default = [], help = "Set the output image format.  Can be given multiple times (default = \"png\").")
	parser.add_option("--segments-name", metavar = "name", default = "statevectorsegments", help = "Set the name of the segments that were analyzed (default = \"statevectorsegments\").")
	parser.add_option("--vetoes-name", metavar = "name", default = "vetoes", help = "Set the name of the veto segments (default = \"vetoes\").")
	parser.add_option("--plot-group", metavar = "number", action = "append", default = None, help = """Generate the given plot group.  Can be given multiple times (default = make all plot groups)
 0. Segments Table (Analytical time)
 1. Summary Table (top 10 loudest events globally across all zero lag triggers read in)
 2. Missed Found (Scatter plots of missed and found injections on several axes)
 3. Injection Parameter Accuracy Plots
 4. Background Vs Injection Plots (sngl detector triggers from coincs of snr, chisq, bank chisq,...)
 5. Background Vs Injection Plots pairwise (effective snr DET1 Vs. DET2...),
 6. Rate Vs Threshold (SNR histograms, IFAR histograms, ...)
 7. Injection Parameter Distribution Plots (The input parameters that went into inspinj, like mass1 vs mass2...)
""")
	parser.add_option("--far-threshold", metavar = "Hz", default = 1. / (30 * 86400), type = "float", help = "Set the FAR threshold for found injections (default = 1 / 30 days).")
	parser.add_option("-t", "--tmp-space", metavar = "path", help = "Path to a directory suitable for use as a work area while manipulating the database file.  The database file will be worked on in this directory, and then moved to the final location when complete.  This option is intended to improve performance when running in a networked environment, where there might be a local disk with higher bandwidth than is available to the filesystem on which the final output will reside.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if options.plot_group is not None:
		options.plot_group = sorted(map(int, options.plot_group))
	if not options.format:
		options.format = ["png"]

        if options.noninj_database is not None and options.noninj_user_tag is None:
            raise ValueError("Need to set the noninj-user-tag since noninj-database is set") 

        if options.inj_database is not None and options.inj_user_tag is None:
            raise ValueError("Need to set the inj-user-tag since inj-database is set") 

        if options.shift_database is not None and options.shift_user_tag is None:
            raise ValueError("Need to set the shift-user-tag since shift-database is set") 

	if not filenames:
		filenames = []

	return options, filenames


#
# =============================================================================
#
#                                   Database
#
# =============================================================================
#

class SegmentsTable(object):
	def __init__(self, base):
		self.all_segs_dict = {}
		self.data = []
		self.table = []
		self.base = base

	def add_contents(self, contents):

		# only process non-injection documents
		if contents.sim_inspiral_table is None:
                    for ifo, one_seg_list in contents.seglists.items():
                    	for seg in one_seg_list:
                    		self.data.append(["%s: %s" % (str(ifo), str("datasegments")), "", "%.2f-%.2f" % (float(seg[0]), float(seg[1])), float(seg[0])*1000 + 315964800000 - 17000, float(seg[1])*1000 + 315964800000 - 17000])
                    

	def finish(self):
                # FIXME: add segments_table.json
		f = open("%s_segments.json" % self.base, "w")
		f.write(repr(self.data))
		f.close()
                yield None, None, None



class CoincDatabase(object):
	def __init__(self, connection, data_segments_name, veto_segments_name = None, verbose = False, plotsummary_json = None, wiki = None, base = None, program_name = "gstlal_inspiral"):
		"""
		Compute and record some summary information about the
		database.
		"""

		self.base = base
		self.connection = connection
		xmldoc = postcoh_table_def.get_xml(connection)

		cursor = connection.cursor()

		# find the tables
		try:
			self.sim_inspiral_table = lsctables.SimInspiralTable.get_table(xmldoc)
		except ValueError:
			self.sim_inspiral_table = None

		try:
			self.postcoh_inspiral_table = postcoh_table_def.PostcohInspiralTable.get_table(xmldoc)
		except ValueError:
			self.postcoh_inspiral_table = None

		#pdb.set_trace()
		# retrieve the distinct on and participating instruments
		self.on_instruments_combos = [frozenset(lsctables.instrument_set_from_ifos(x)) for x, in cursor.execute("SELECT DISTINCT(ifos) FROM postcoh")]
		self.participating_instruments_combos = [frozenset(lsctables.instrument_set_from_ifos(x)) for x, in cursor.execute("SELECT DISTINCT(ifos) FROM postcoh")]

		# get the segment lists
		self.seglists = ligolw_segments.segmenttable_get_by_name(xmldoc, data_segments_name).coalesce()
		self.instruments = set(self.seglists)
		if veto_segments_name is not None:
			self.veto_segments = ligolw_segments.segmenttable_get_by_name(xmldoc, veto_segments_name).coalesce()
		else:
			self.veto_segments = segments.segmentlistdict()
		self.seglists -= self.veto_segments

		# FIXME: no search table Get the live time used for the far calculation.  By convention this is simply the entire interval of the analysis with no regard for segments
		# self.farsegs = far.get_live_time_segs_from_search_summary_table(connection)

		# get the live time
		if verbose:
			print >>sys.stderr, "calculating background livetimes: ",
		#self.offset_vectors = db_thinca_rings.get_background_offset_vectors(connection)

		if verbose:
			print >>sys.stderr
		self.zerolag_livetime = {}
		self.background_livetime = {}
		self.segs_livetime = 0
		for on_instruments in self.on_instruments_combos:
			self.zerolag_livetime[on_instruments] = float(abs(self.seglists.intersection(on_instruments) - self.seglists.union(self.instruments - on_instruments)))
			if len(on_instruments) >= 2:
				self.segs_livetime += self.zerolag_livetime[on_instruments] 
		# FIXME:  background livetime hard-coded to be same
		# as zero-lag livetime.  figure out what to do
		self.background_livetime.update(self.zerolag_livetime)

		# verbosity
		if verbose:
			print >>sys.stderr, "database overview:"
			for on_instruments in self.on_instruments_combos:
				print >>sys.stderr, "\tzero-lag livetime for %s: %f s" % ("+".join(sorted(on_instruments)), self.zerolag_livetime[on_instruments])
				print >>sys.stderr, "\tbackground livetime for %s: %f s" % ("+".join(sorted(on_instruments)), self.background_livetime[on_instruments])
			if self.sim_inspiral_table is not None:
				print >>sys.stderr, "\tinjections: %d" % len(self.sim_inspiral_table)

		if wiki:
			wiki.write("database overview:\n\n")
			for on_instruments in self.on_instruments_combos:
				wiki.write("||zero-lag livetime for %s||%f s||\n" % ("+".join(sorted(on_instruments)), self.zerolag_livetime[on_instruments]))
				wiki.write("||background livetime for %s ||%f s||\n" % ("+".join(sorted(on_instruments)), self.background_livetime[on_instruments]))
			if self.sim_inspiral_table is not None:
				wiki.write("||injections|| %d||\n" % len(self.sim_inspiral_table))

		if plotsummary_json:
			data = []
			for on_instruments in self.on_instruments_combos:
				data.append(["zero-lag livetime for %s" % ("+".join(sorted(on_instruments))), str(self.zerolag_livetime[on_instruments])])
				data.append(["background livetime for %s" % ("+".join(sorted(on_instruments))), str(self.background_livetime[on_instruments])])
			if self.postcoh_inspiral_table is not None:
				data.append(["inspiral events", str(len(self.postcoh_inspiral_table))])
			if self.sim_inspiral_table is not None:
				data.append(["injections", str(len(self.sim_inspiral_table))])
			if self.sim_inspiral_table is None:
				to_google_json("%s_%s" % (self.base, "plotsummary.json"), [('Summary of database:', 'string'), (plotsummary_json, 'string')], data)


#
# =============================================================================
#
#                                  Utilities
#
# =============================================================================
#


def roman(i, arabics = (1000,900,500,400,100,90,50,40,10,9,5,4,1), romans = ("m","cm","d","cd","c","xc","l","xl","x","ix","v","iv","i")):
	if not arabics:
		return ""
	if i < arabics[0]:
		return roman(i, arabics[1:], romans[1:])
	return romans[0] + roman(i - arabics[0], arabics, romans)


#
# width is in mm, default aspect ratio is the golden ratio
#


def create_plot(x_label = None, y_label = None, width = 165.0, aspect = None):
	if aspect is None:
		aspect = (1 + math.sqrt(5)) / 2
	fig = figure.Figure()
	FigureCanvas(fig)
	fig.set_size_inches(width / 25.4, width / 25.4 / aspect)
	axes = fig.gca()
	axes.grid(True)
	if x_label is not None:
		axes.set_xlabel(x_label)
	if y_label is not None:
		axes.set_ylabel(y_label)
	return fig, axes


def create_sim_coinc_view(connection):
	"""
	Construct a sim_inspiral --> best matching coinc_event mapping.
	Only injections that match at least one coinc get an entry in this
	table. if there are more than entries, select the smallest far one
        the format is like:
            simulation_id, event_id, far
            sim_inspiral:simulation_id:32135,postcoh:event_id:241023,1.3e-7
            sim_inspiral:simulation_id:32155,postcoh:event_id:250000,4.5e-3
        note the simulation_id and event_id may not be continous
        """
	#
	# the log likelihood ratio stored in the likelihood column of the
	# coinc_event table is the ranking statistic.  the "best match" is
	# the coinc with the highest value in this column.  although it has
	# not been true in the past, there is now a one-to-one relationship
	# between the value of this ranking statistic and false-alarm rate,
	# therefore it is OK to order by log likelihood ratio and then,
	# later, impose a "detection" threshold based on false-alarm rate.
	#

	connection.cursor().execute("""
CREATE TEMPORARY TABLE
	sim_coinc_map
AS
	SELECT
		sim_inspiral.simulation_id AS simulation_id,
		(
			SELECT
				a.coinc_event_id
			FROM
				coinc_event_map AS a
				JOIN postcoh ON (
					postcoh.event_id == a.coinc_event_id
				)
			WHERE
				a.table_name == 'sim_inspiral'
				AND a.event_id == sim_inspiral.simulation_id
			ORDER BY
				postcoh.far ASC
			LIMIT 1
		) as coinc_event_id,
		(
			SELECT
				postcoh.far
			FROM
				coinc_event_map AS a
				JOIN postcoh ON (
					postcoh.event_id == a.coinc_event_id
				)
			WHERE
				a.table_name == 'sim_inspiral'
				AND a.event_id == sim_inspiral.simulation_id
			ORDER BY
				postcoh.far ASC
			LIMIT 1
		) as far
        FROM
		sim_inspiral
	WHERE
		coinc_event_id IS NOT NULL
	""")


#
# =============================================================================
#
#                      Summary Table
#
# =============================================================================
#

"""
split the Summary Table for 2 purposes:
    1. display 10 most significant events for noninj database
    2. display 10 most significant events for shift database
"""
class SummaryTable(object):
	def __init__(self, tag):
		self.candidates = []
		self.bgcandidates = []
		self.livetime = {}
		self.num_trigs = {}
                self.tag = tag

	def add_contents(self, contents):
		self.base = contents.base
		if contents.sim_inspiral_table:
			#For now we only return summary information on non injections
			return
                # FIXME: third should be ranking_statistic
		select_candidates = contents.connection.cursor().execute("""
SELECT
	postcoh.far,
	postcoh.fap,
	postcoh.fap, 
	postcoh.cohsnr,
	postcoh.end_time + postcoh.end_time_ns * 1e-9,
	postcoh.mtotal,
	postcoh.mchirp,
	postcoh.ifos,
        postcoh.mass1,
        postcoh.mass2,
        postcoh.spin1z,
        postcoh.spin2z,
        postcoh.snglsnr_H,
        postcoh.chisq_H,
        postcoh.snglsnr_L,
        postcoh.chisq_L
FROM
	postcoh
ORDER BY
	far
LIMIT 10
		""").fetchall()

                if self.tag == "noninj":
			self.candidates = select_candidates
                elif self.tag == "shift":
			self.bgcandidates = select_candidates
		else:
			raise ValueError

	def write_candidate_json(self, candidates, fname):
		data = []
		# FIXME generalize for virgo
		description = [
			("Rank", "number"),
			("FAR (Hz)", "string"),
			("FAP", "string"),
			("ranking_statistic", "string"),
			("&rho;", "number"),
			("<i>t</i>", "number"),
			("<i>M</i><sub>total</sub> / M<sub>&#x2299;</sub>", "number"),
			("<i>M</i><sub>chirp</sub> / M<sub>&#x2299;</sub>", "number"),
			("Participating<br>Instruments", "string"),
			("m<sub>1</sub>", "number"),
			("m<sub>2</sub>", "number"),
			("s<sub>1z</sub>", "number"),
			("s<sub>2z</sub>", "number"),
			("H1 &rho;", "string"),
			("H1 &chi;<sup>2</sup>", "string"),
			("L1 &rho;", "string"),
			("L1 &chi;<sup>2</sup>", "string"),
		]
		for rank, values in enumerate(candidates, 1):
			row = [rank] + [float(v) for v in values[:7]] + [values[7]] +[float(v) for v in values[8:12]]
			# values[9] is a string that is e.g., H1:4.8993754:1.0139208:2.061641:1.145543 L1:8.2582664:1.1890973:2.061641:1.145543
			ifodict = {"H1": [float(values[12]),float(values[13])], "L1": [float(values[14]),float(values[15])]}
			row.extend(ifodict["H1"])
			row.extend(ifodict["L1"])
			data.append(row)
		to_google_json(fname, description, data)

	def finish(self):
                if self.tag == "noninj":
		    self.candidates.sort()
		    self.write_candidate_json(self.candidates[:101], self.base+'_summary_table.json')
		    yield None, None, None
	    	elif self.tag == "shift":
		    self.bgcandidates.sort()
		    self.write_candidate_json(self.bgcandidates[:101], self.base+'_bgsummary_table.json')
		    yield None, None, None



#
# =============================================================================
#
#                      Injection Parameter Distributions
#
# =============================================================================
#


class InjectionParameterDistributionPlots(object):
	def __init__(self):
		self.injections = {}

	def add_contents(self, contents):
		if contents.sim_inspiral_table is None:
			# no injections
			return
		for values in contents.connection.cursor().execute("""
SELECT
	*
FROM
	sim_inspiral
			"""):
			sim = contents.sim_inspiral_table.row_from_cols(values)
			del sim.process_id, sim.source, sim.simulation_id
			instruments = frozenset(instrument for instrument, segments in contents.seglists.items() if sim.get_time_geocent() in segments)
			self.injections.setdefault(sim.waveform, []).append(sim)

	def finish(self):
		for waveform, sims in self.injections.items():
			for col1,col2,ax1,ax2,name,aspect in [
							([sim.mass1 for sim in sims], [sim.mass2 for sim in sims], r"$M_{1}$ ($\mathrm{M}_{\odot}$)", r"$M_{2}$ ($\mathrm{M}_{\odot}$)", "sim_dist_m1_m2_%s", 1),
							([sim.geocent_end_time for sim in sims], [math.log10(sim.distance) for sim in sims], r"Time (s)", r"$\log_{10} (\mathrm{distance} / 1\,\mathrm{Mpc})$", "sim_dist_time_distance_%s",None),
							([sim.longitude * 12 / math.pi for sim in sims], [math.sin(sim.latitude) for sim in sims], r"RA (h)", r"$\sin \mathrm{dec}$", "sim_dist_ra_dec_%s",None),
							([math.cos(sim.inclination) for sim in sims], [sim.polarization for sim in sims], r"$\cos $Inclination (rad)", r"Polarization (rad)", "sim_dist_inc_pol_%s",None),
							([sim.spin1z for sim in sims], [sim.spin2z for sim in sims], r"Spin 1 z", r"Spin 2 z", "sim_dist_spin1z_spin2z_%s",None)]:
				fig, axes = create_plot(ax1,ax2, aspect = aspect)
				axes.set_title(r"Injection Parameter Distribution (%s Injections)" % waveform)
				if len(col1) > 16383:
					axes.plot(col1,col2, "k,")
				else:
					axes.plot(col1,col2, "k.")
				minx, maxx = axes.get_xlim()
				miny, maxy = axes.get_ylim()
				if aspect == 1:
					axes.set_xlim((min(minx, miny), max(maxx, maxy)))
					axes.set_ylim((min(minx, miny), max(maxx, maxy)))
				yield fig, name % (waveform), False


#
# =============================================================================
#
#                              Missed/Found Plot
#
# =============================================================================
#


class MissedFoundPlots(object):
	class MissedFound(object):
		def __init__(self, on_instruments, far_thresh, missed_found_plots):
			self.on_instruments = on_instruments
			self.far_thresh = far_thresh
			self.found_in = {}
                        self.missed_found_plots = missed_found_plots

		def add_contents(self, contents):
			self.base = contents.base
			zerolag_segments = contents.seglists.intersection(self.on_instruments) - contents.seglists.union(contents.instruments - self.on_instruments)
			for values in contents.connection.cursor().execute("""
SELECT
	sim_inspiral.*,
	(
		SELECT
			postcoh.ifos
		FROM
			sim_coinc_map
			JOIN postcoh ON (
				postcoh.event_id == sim_coinc_map.coinc_event_id
			)
		WHERE
			sim_coinc_map.simulation_id == sim_inspiral.simulation_id
			AND postcoh.far < ?
	)
FROM
	sim_inspiral
			""", (self.far_thresh if self.far_thresh is not None else float("+inf"),)):
				sim = contents.sim_inspiral_table.row_from_cols(values)
				del sim.process_id, sim.source, sim.simulation_id
				if sim.get_time_geocent() in zerolag_segments:
					participating_instruments = lsctables.instrument_set_from_ifos(values[-1])
					if participating_instruments is not None:
						participating_instruments = frozenset(participating_instruments)
					try:
						self.found_in[participating_instruments].append(sim)
					except KeyError:
						self.found_in[participating_instruments] = [sim]


		def finish(self):

			f = open(self.base + "_injection_summary.txt", "a")
			missed = self.found_in.pop(None, [])
			# Define decisive distance even if there is one instrument
			def decisive_distance(sim, instruments):
				if len(instruments) > 1:
					return sorted(sim.get_eff_dist(instrument) for instrument in instruments)[1]
				else:
					return sim.get_eff_dist(list(instruments)[0])
			def decisive_chirp_distance(sim, instruments):
				if len(instruments) > 1:
					return sorted(sim.get_chirp_eff_dist(instrument) for instrument in instruments)[1]
				else:
					return sim.get_chirp_eff_dist(list(instruments)[0])

			def found_decisive_charsnr(sim, oninstruments, partinstruments):
				if len(oninstruments) == 2:
					if len(partinstruments) == 2:
						return sorted([sim.alpha1, sim.alpha2])[0]
					if len(partinstruments) == 1:
						ifo, = partinstruments
						if ifo == 'H1':
							return sim.alpha1
						if ifo == 'L1':
							return sim.alpha2
				elif len(oninstruments) == 1:
					ifo, = oninstruments
					if ifo == 'H1':
						return sim.alpha1
					if ifo == 'L1':
						return sim.alpha2
				else:
					raise ValueError("More than 2 instruments not supported for injection snr calculation at this time.")

			def missed_decisive_charsnr(sim, oninstruments):
				if len(oninstruments) == 2:
					return sorted([sim.alpha1, sim.alpha2])[0]
				elif len(oninstruments) == 1:
					ifo, = oninstruments
					if ifo == 'H1':
						return sim.alpha1
					if ifo == 'L1':
						return sim.alpha2
				else:
					raise ValueError("More than 2 instruments not supported for injection snr calculation at this time.")

			for cnt, (title, x_label, x_func, y_label, y_func, filename_fragment) in enumerate((
				(r"$\textrm{Distance vs.\ Chirp Mass (With %s Operating)}$" % ", ".join(sorted(self.on_instruments)), r"$M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)", lambda sim: sim.mchirp, r"$D$ ($\mathrm{Mpc}$)", lambda sim, instruments: sim.distance, "d_vs_mchirp"),
				(r"$\textrm{Decisive Distance vs.\ Chirp Mass (With %s Operating)}$" % ", ".join(sorted(self.on_instruments)), r"$M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)", lambda sim: sim.mchirp, r"$\mathrm{Decisive} D_{\mathrm{eff}}$ ($\mathrm{Mpc}$)", decisive_distance, "deff_vs_mchirp"),
				(r"$\textrm{Chirp Decisive Distance vs.\ Chirp Mass (With %s Operating)}$" % ", ".join(sorted(self.on_instruments)), r"$M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)", lambda sim: sim.mchirp, r"$\mathrm{Decisive} D_{\mathrm{chirp, eff}}$ ($\mathrm{Mpc}$)", decisive_chirp_distance, "chirpdist_vs_mchirp"),
				(r"$\textrm{Chirp Decisive Distance vs.\ Eta (With %s Operating)}$" % ", ".join(sorted(self.on_instruments)), r"$\eta$", lambda sim: sim.eta, r"$\mathrm{Decisive} D_{\mathrm{chirp, eff}}$ ($\mathrm{Mpc}$)", decisive_chirp_distance, "chirpdist_vs_eta"),
				(r"$\textrm{Decisive Distance vs.\ Total Mass (With %s Operating)}$" % ", ".join(sorted(self.on_instruments)), r"$M_{\mathrm{total}}$ ($\mathrm{M}_{\odot}$)", lambda sim: sim.mass1 + sim.mass2, r"$\mathrm{Decisive} D_{\mathrm{eff}}$ ($\mathrm{Mpc}$)", decisive_distance, "deff_vs_mtotal"),
				(r"$\textrm{Decisive Distance vs.\ Effective Spin (With %s Operating)}$" % ", ".join(sorted(self.on_instruments)), r"$\chi$", lambda sim: (sim.spin1z*sim.mass1 + sim.spin2z*sim.mass2)/(sim.mass1 + sim.mass2), r"$\mathrm{Decisive} D_{\mathrm{eff}}$ ($\mathrm{Mpc}$)", decisive_distance, "deff_vs_chi"),
				(r"$\textrm{Decisive Distance vs.\ Time (With %s Operating)}$" % ", ".join(sorted(self.on_instruments)), r"GPS Time (s)", lambda sim: sim.get_time_geocent(), r"$\mathrm{Decisive} D_{\mathrm{eff}}$ ($\mathrm{Mpc}$)", decisive_distance, "deff_vs_t")
				)):

				fig, axes = create_plot(x_label, y_label)
				legend = []
                                #pdb.set_trace()
				for participating_instruments, sims in sorted(self.found_in.items(), key = (lambda x: lsctables.ifos_from_instrument_set(x[0]))):
					if cnt == 0:
						self.missed_found_plots.injection_summary_data.append(["Found", "".join(sorted(self.on_instruments)), "".join(sorted(participating_instruments)), len(sims)])
					legend.append("Found in %s" % ", ".join(sorted(participating_instruments)))
					axes.semilogy([x_func(sim) for sim in sims], [y_func(sim, participating_instruments) for sim in sims], ".")
				if missed:
					if cnt == 0:
						self.missed_found_plots.injection_summary_data.append(["Missed", "".join(sorted(self.on_instruments)), "---", len(missed)])
						for rank, sim in enumerate(missed):
							self.missed_found_plots.missed_summary_data.append(["".join(sorted(self.on_instruments)), sim.waveform, float(sim.time_at_instrument("H1", {"H1": 0.0})), float(sim.time_at_instrument("L1", {"L1": 0.0})), sim.mass1, sim.mass2, sim.spin1x, sim.spin1y, sim.spin1z, sim.spin2x, sim.spin2y, sim.spin2z, sim.distance, decisive_chirp_distance(sim, self.on_instruments), sim.inclination, sim.alpha1, sim.alpha2, missed_decisive_charsnr(sim, self.on_instruments)])
					legend.append("Missed")
					axes.semilogy([x_func(sim) for sim in missed], [y_func(sim, self.on_instruments) for sim in missed], "k.")


				if legend:
					axes.legend(legend)
				axes.set_title(title)
				yield fig, filename_fragment, False

			for cnt, (title, x_label, x_func, y_label, filename_fragment) in enumerate((
				(r"Decisive Characteristic SNR vs.\ Chirp Mass (With %s Operating)" % ", ".join(sorted(self.on_instruments)), r"$M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)", lambda sim: sim.mchirp, r"Decisive Characteristic SNR", "dec_expsnr_vs_mchirp"),
				(r"Decisive Characteristic SNR vs.\ Total Mass (With %s Operating)" % ", ".join(sorted(self.on_instruments)), r"$M_{\mathrm{total}}$ ($\mathrm{M}_{\odot}$)", lambda sim: sim.mass1 + sim.mass2, r"Decisive Characteristic SNR", "dec_expsnr_vs_mtotal"),
				(r"Decisive Characteristic SNR vs.\ Eta (With %s Operating)" % ", ".join(sorted(self.on_instruments)), r"$\eta$", lambda sim: sim.eta, r"Decisive Characteristic SNR", "dec_expsnr_vs_eta"),
				(r"Decisive Characteristic SNR vs.\ Effective Spin (With %s Operating)" % ", ".join(sorted(self.on_instruments)), r"$\chi$", lambda sim: (sim.spin1z*sim.mass1 + sim.spin2z*sim.mass2)/(sim.mass1 + sim.mass2), r"Decisive Characteristic SNR", "dec_expsnr_vs_chi"),
				(r"Decisive Characteristic SNR vs.\ Time (With %s Operating)" % ", ".join(sorted(self.on_instruments)), r"GPS Time (s)", lambda sim: sim.get_time_geocent(), r"Decisivive Characteristic SNR", "dec_expsnr_vs_t")
			)):
				fig, axes = create_plot(x_label, y_label)
				legend = []
				try:
					for participating_instruments, sims in sorted(self.found_in.items(), key = (lambda x: lsctables.ifos_from_instrument_set(x[0]))):
						legend.append("Found in %s" % ", ".join(sorted(participating_instruments)))
						axes.semilogy([x_func(sim) for sim in sims], [found_decisive_charsnr(sim, self.on_instruments, participating_instruments) for sim in sims], ".")
					if missed:
						legend.append("Missed")
						axes.semilogy([x_func(sim) for sim in missed], [missed_decisive_charsnr(sim, self.on_instruments) for sim in missed], "k.")
					if legend:
						axes.legend(legend)
					axes.set_title(title)
					yield fig, filename_fragment, False
				except ValueError:
					print >> sys.stderr, "Cannot create expected SNR plots, no positive values, probably the SNRs are not set"


	def __init__(self, far_thresh):
		self.far_thresh = far_thresh
		self.plots = {}
                self.injection_summary_data = []
                self.missed_summary_data = []

	def add_contents(self, contents):
		self.base = contents.base
		if contents.sim_inspiral_table is None:
			# no injections
			return
		for on_instruments in contents.on_instruments_combos:
			if on_instruments not in self.plots:
				self.plots[on_instruments] = MissedFoundPlots.MissedFound(on_instruments, self.far_thresh, self)
			self.plots[on_instruments].add_contents(contents)

	def finish(self):
		f = open(self.base + "_injection_summary.txt", "w")
		f.write("||<b>ON INSTRUMENTS</b>||<b> PARTICIPATING INSTRUMENTS</b>||<b>MISSED/FOUND</b||\n")
		f.close()
		for on_instruments, plot in self.plots.items():
			for fig, filename_fragment, is_open_box in plot.finish():
				yield fig, "%s_%s" % (filename_fragment, "".join(sorted(on_instruments))), is_open_box

		to_google_json(self.base + "_injection_summary.json", [("Found||Missed", "string"), ("On Instruments", "string"), ("Participating Instruments", "string"), ("count", "number")], self.injection_summary_data)
		to_google_json(self.base + "_missed_summary.json", [("On Instruments", "string"), ("Waveform", "string"), ("H1 <i>t</i>", "number"), ("L1 <i>t</i>", "number"), ("<i>m</i><sub>1</sub>", "number"), ("<i>m</i><sub>2</sub>", "number"), ("<i>s</i><sub>1x</sub>", "number"), ("<i>s</i><sub>1y</sub>", "number"), ("<i>s</i><sub>1z</sub>", "number"), ("<i>s</i><sub>2x</sub>", "number"), ("<i>s</i><sub>2y</sub>", "number"), ("<i>s</i><sub>2z</sub>", "number"), ("D (Mpc)", "number"), ("Decisive D<sub>chirp,eff</sub> (Mpc)" , "number"), ("Inclination", "number"), ("H1 &rho;", "number"), ("L1 &rho;", "number"), ("Decisive &rho;", "number")], self.missed_summary_data)


#



#
# =============================================================================
#
#                              Parameter Accuracy
#
# =============================================================================
#


class ParameterAccuracyPlots(object):
	def __init__(self, far_thresh = 1e-4):
		self.sim_postcoh_pairs = {}
                self.far_thresh = far_thresh

	def add_contents(self, contents):
		if contents.sim_inspiral_table is None:
			# not an injections file
			return
		n_simcolumns = len(contents.sim_inspiral_table.columnnames)
		for values in contents.connection.cursor().execute("""
SELECT
	sim_inspiral.*,
	postcoh.*,postcoh.far
FROM
	sim_inspiral
	JOIN sim_coinc_map ON (
		sim_coinc_map.simulation_id == sim_inspiral.simulation_id
	)
	JOIN postcoh ON (
		postcoh.event_id == sim_coinc_map.coinc_event_id
	)
	WHERE postcoh.cohsnr > 8.0
		"""):
			sim = contents.sim_inspiral_table.row_from_cols(values)
			postcoh = contents.postcoh_inspiral_table.row_from_cols(values[n_simcolumns:-1])
                        far = values[-1]
			del sim.process_id, sim.source, sim.simulation_id
			del postcoh.event_id
                        if far <= self.far_thresh:
			    self.sim_postcoh_pairs.setdefault((sim.waveform, postcoh.ifos), []).append((sim, postcoh, far))

	def finish(self):

		def hist(arr, axes):
			start = scipy.stats.mstats.mquantiles(arr, 0.01)
			end = scipy.stats.mstats.mquantiles(arr, 0.99)
			axes.hist(arr, numpy.linspace(start, end, 100))

		for (waveform, ifos), pairs in self.sim_postcoh_pairs.items():
			on_instruments = set(re.findall(r'[A-Z][0-9]', ifos))
			for instrument in on_instruments:
				fig, axes = create_plot(r"Inj. $M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)", r"Rec. $M_{\mathrm{chirp}}$ - Inj. $M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)")
				axes.set_title(r"Absolute $M_{\mathrm{chirp}}$ Accuracy in %s (%s Injections)" % (instrument, waveform))
				cb = axes.scatter([sim.mchirp for sim, postcoh, far in pairs], [postcoh.mchirp - sim.mchirp for sim, postcoh, far in pairs], c=[far for sim, postcoh, far in pairs], norm=matplotlib.colors.LogNorm(), vmin=1e-13, vmax=1e-3, linewidth=0.2, alpha=0.8)
				fig.colorbar(cb, ax=axes).set_label("FAR (Hz)")
				yield fig, "mchirp_acc_abs_scatter_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"Rec. $M_{\mathrm{chirp}}$ - Inj. $M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)", "Number")
				axes.set_title(r"Absolute $M_{\mathrm{chirp}}$ Accuracy in %s (%s Injections)" % (instrument, waveform))
				hist(numpy.array([postcoh.mchirp - sim.mchirp for sim, postcoh, far in pairs]), axes)
				yield fig, "mchirp_acc_abs_hist_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"Inj. $M_{\mathrm{chirp}}$ ($\mathrm{M}_{\odot}$)", r"(Rec. $M_{\mathrm{chirp}}$ - Inj. $M_{\mathrm{chirp}}$) / Inj. $M_{\mathrm{chirp}}$")
				axes.set_title(r"Fractional $M_{\mathrm{chirp}}$ Accuracy in %s (%s Injections)" % (instrument, waveform))
				cb = axes.scatter([sim.mchirp for sim, postcoh, far in pairs], [(postcoh.mchirp - sim.mchirp) / sim.mchirp for sim, postcoh, far in pairs], c=[far for sim, postcoh, far in pairs], norm=matplotlib.colors.LogNorm(), vmin=1e-13, vmax=1e-3, linewidth=0.2, alpha=0.8)
				fig.colorbar(cb, ax=axes).set_label("FAR (Hz)")
				yield fig, "mchirp_acc_frac_scatter_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"(Rec. $M_{\mathrm{chirp}}$ - Inj. $M_{\mathrm{chirp}}$)/ Inj. $M_{\mathrm{chirp}}$", "Number")
				axes.set_title(r"Fractional $M_{\mathrm{chirp}}$ Accuracy in %s (%s Injections)" % (instrument, waveform))
				hist(numpy.array([(postcoh.mchirp - sim.mchirp) / sim.mchirp for sim, postcoh, far in pairs]), axes)
				yield fig, "mchirp_acc_frac_hist_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"Inj. $M_{\mathrm{total}}$ ($\mathrm{M}_{\odot}$)", r"(Rec. $M_{\mathrm{total}}$ - Inj. $M_{\mathrm{total}}$) / Inj. $M_{\mathrm{total}}$")
				axes.set_title(r"Fractional $M_{\mathrm{total}}$ Accuracy in %s (%s Injections)" % (instrument, waveform))
				cb = axes.scatter([sim.mtotal for sim, postcoh, far in pairs], [(postcoh.mtotal - sim.mtotal) / sim.mtotal for sim, postcoh, far in pairs], c=[far for sim, postcoh, far in pairs], norm=matplotlib.colors.LogNorm(), vmin=1e-13, vmax=1e-3, linewidth=0.2, alpha=0.8)
				fig.colorbar(cb, ax=axes).set_label("FAR (Hz)")
				yield fig, "mtotal_acc_frac_scatter_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"(Rec. $M_{\mathrm{total}}$ - Inj. $M_{\mathrm{total}}$) / Inj. $M_{\mathrm{total}}$", "Number")
				axes.set_title(r"Fractional $M_{\mathrm{total}}$ Accuracy in %s (%s Injections)" % (instrument, waveform))
				hist(numpy.array([(postcoh.mtotal - sim.mtotal) / sim.mtotal for sim, postcoh, far in pairs]), axes)
				yield fig, "mtotal_acc_frac_hist_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"Inj. $\eta$", r"Rec. $\eta$ - Inj. $\eta$")
				axes.set_title(r"Absolute $\eta$ Accuracy in %s (%s Injections)" % (instrument, waveform))
				cb = axes.scatter([sim.eta for sim, postcoh, far in pairs], [postcoh.eta - sim.eta for sim, postcoh, far in pairs], c=[far for sim, postcoh, far in pairs], norm=matplotlib.colors.LogNorm(), vmin=1e-13, vmax=1e-3, linewidth=0.2, alpha=0.8)
				fig.colorbar(cb, ax=axes).set_label("FAR (Hz)")
				yield fig, "eta_acc_abs_scatter_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"Rec. $\eta$ - Inj. $\eta$", "Number")
				axes.set_title(r"Absolute $\eta$ Accuracy in %s (%s Injections)" % (instrument, waveform))
				hist(numpy.array([postcoh.eta - sim.eta for sim, postcoh, far in pairs]), axes)
				yield fig, "eta_acc_abs_hist_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"Inj. $\eta$", r"(Rec. $\eta$ - Inj. $\eta$) / Inj. $\eta$")
				axes.set_title(r"Fractional $\eta$ Accuracy in %s (%s Injections)" % (instrument, waveform))
				cb = axes.scatter([sim.eta for sim, postcoh, far in pairs], [(postcoh.eta - sim.eta) / sim.eta for sim, postcoh, far in pairs], c=[far for sim, postcoh, far in pairs], norm=matplotlib.colors.LogNorm(), vmin=1e-13, vmax=1e-3, linewidth=0.2, alpha=0.8)
				fig.colorbar(cb, ax=axes).set_label("FAR (Hz)")
				yield fig, "eta_acc_frac_scatter_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"(Rec. $\eta$ - Inj. $\eta$) / Inj. $\eta$", "Number")
				axes.set_title(r"Fractional $\eta$ Accuracy in %s (%s Injections)" % (instrument, waveform))
				hist(numpy.array([(postcoh.eta - sim.eta) / sim.eta for sim, postcoh, far in pairs]), axes)
				yield fig, "eta_acc_frac_hist_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"Injection End Time (GPS s)", r"Rec. End Time - Injection End Time (ms)")
				axes.set_title(r"End Time Accuracy in %s (%s Injections)" % (instrument, waveform))
				axes.plot([sim.time_at_instrument(instrument, {instrument: 0.0}) for sim, postcoh, far in pairs], [(postcoh.get_ifo_endtime(instrument) - sim.time_at_instrument(instrument, {instrument: 0.0}))*1000. for sim, postcoh, far in pairs], "kx")
				yield fig, "t_acc_scatter_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"Rec. End Time - Injection End Time (ms)", "Number")
				axes.set_title(r"End Time Accuracy in %s (%s Injections)" % (instrument, waveform))
				hist(numpy.array([float(postcoh.get_ifo_endtime(instrument) - sim.time_at_instrument(instrument, {instrument: 0.0}))*1000. for sim, postcoh, far in pairs]), axes)
				yield fig, "t_acc_hist_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"Injection $D_{\mathrm{eff}}$ ($\mathrm{Mpc}$)", r"(Rec. $D_{\mathrm{eff}}$ - Injection $D_{\mathrm{eff}}$) / Injection $D_{\mathrm{eff}}$")
				axes.set_title(r"Fractional Effective Distance Accuracy in %s (%s Injections)" % (instrument, waveform))
				axes.semilogx([sim.get_eff_dist(instrument) for sim, postcoh, far in pairs], [(postcoh.get_eff_distance(instrument) - sim.get_eff_dist(instrument)) / sim.get_eff_dist(instrument) for sim, postcoh, far in pairs], "kx")
				yield fig, "deff_acc_frac_scatter_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"(Rec. $D_{\mathrm{eff}}$ - Injection $D_{\mathrm{eff}}$) / Injection $D_{\mathrm{eff}}$", "Number")
				axes.set_title(r"Fractional Effective Distance Accuracy in %s (%s Injections)" % (instrument, waveform))
				hist(numpy.array([(postcoh.get_eff_distance(instrument) - sim.get_eff_dist(instrument)) / sim.get_eff_dist(instrument) for sim, postcoh, far in pairs]), axes)
				yield fig, "deff_acc_frac_hist_%s_%s" % (waveform, instrument), False
	
	                        if postcoh.get_eff_distance(instrument) > 0.0:
	    			    fig, axes = create_plot(r"(Rec. $1/D_{\mathrm{eff}}$ - Injection $1/D_{\mathrm{eff}}$) / Injection $1/D_{\mathrm{eff}}$", "Number")
	           		    axes.set_title(r"Fractional Effective Amplitude Accuracy in %s (%s Injections)" % (instrument, waveform))
	        		    hist(numpy.array([(1. / postcoh.get_eff_distance(instrument) - 1. / sim.get_eff_dist(instrument)) / (1. / sim.get_eff_dist(instrument)) for sim, postcoh, far in pairs]), axes)
	        		    yield fig, "deff_acc_frac_inv_hist_%s_%s" % (waveform, instrument), False
	        
				fig, axes = create_plot(r"Inj. $\chi$", r"Rec. $\chi$")
				axes.set_title(r"Effective Spin Accuracy in %s (%s Injections)" % (instrument, waveform))
				axes.plot([sim.chi for sim, postcoh, far in pairs], [postcoh.chi for sim, postcoh, far in pairs], "kx")
				yield fig, "chi_acc_scatter_%s_%s" % (waveform, instrument), False
	
				fig, axes = create_plot(r"Inj. SNR", r"Rec. SNR")
				axes.set_title(r"SNR Recovery in %s (%s Injections)" % (instrument, waveform))
				if max([sim.alpha1 for sim, postcoh, far in pairs]) > 20:
					axes.loglog([sim.get_exp_snr(instrument) for sim, postcoh, far in pairs], [postcoh.get_snglsnr(instrument) for sim, postcoh, far in pairs], "kx")
				else:
					axes.plot([sim.get_exp_snr(instrument) for sim, postcoh, far in pairs], [postcoh.get_snglsnr(instrument) for sim, postcoh, far in pairs], "kx")
				yield fig, "snr_rec_scatter_%s_%s" % (waveform, instrument), False
	
	
#
# =============================================================================
#
#               Background vs. Injections --- Single Instrument
#
# =============================================================================
#


class BackgroundVsInjectionPlots(object):
	class Points(object):
		def __init__(self):
			self.snr = []
			self.chi2 = []
			self.bankveto = []
			self.spin = []

	def __init__(self):
		self.injections = {}
		self.background = {}
		self.zerolag = {}

	def add_contents(self, contents):
		if contents.sim_inspiral_table is None:
			# non-injections file
			for instrument, snr, chi2, bankveto, is_background in contents.connection.cursor().execute("""
SELECT
	sngl_inspiral.ifo,
	sngl_inspiral.snr,
	sngl_inspiral.chisq,
	sngl_inspiral.bank_chisq / bank_chisq_dof,
	EXISTS (
		SELECT
			*
		FROM
			time_slide
		WHERE
			time_slide.time_slide_id == coinc_event.time_slide_id
			AND time_slide.offset != 0
	)
FROM
	coinc_event
	JOIN coinc_event_map ON (
		coinc_event_map.coinc_event_id == coinc_event.coinc_event_id
	)
	JOIN sngl_inspiral ON (
		coinc_event_map.table_name == 'sngl_inspiral'
		AND coinc_event_map.event_id == sngl_inspiral.event_id
	)
WHERE
	coinc_event.coinc_def_id == ?
			""", (contents.ii_definer_id,)):
				if is_background:
					if instrument not in self.background:
						self.background[instrument] = BackgroundVsInjectionPlots.Points()
					self.background[instrument].snr.append(snr)
					self.background[instrument].chi2.append(chi2)
					self.background[instrument].bankveto.append(bankveto)
				else:
					if instrument not in self.zerolag:
						self.zerolag[instrument] = BackgroundVsInjectionPlots.Points()
					self.zerolag[instrument].snr.append(snr)
					self.zerolag[instrument].chi2.append(chi2)
					self.zerolag[instrument].bankveto.append(bankveto)
		else:
			# injections file
			for instrument, snr, chi2, bankveto, end_time, spin in contents.connection.cursor().execute("""
SELECT
	sngl_inspiral.ifo,
	sngl_inspiral.snr,
	sngl_inspiral.chisq,
	sngl_inspiral.bank_chisq / bank_chisq_dof,
	sngl_inspiral.end_time + sngl_inspiral.end_time_ns * 1e-9,
	sim.spin1x * sim.spin1x + sim.spin1y * sim.spin1y + sim.spin1z * sim.spin1z + sim.spin2x * sim.spin2x + sim.spin2y * sim.spin2y + sim.spin2z * sim.spin2z
FROM
	sim_coinc_map
	JOIN coinc_event_map ON (
		coinc_event_map.coinc_event_id == sim_coinc_map.coinc_event_id
	)
	JOIN sngl_inspiral ON (
		coinc_event_map.table_name == 'sngl_inspiral'
		AND coinc_event_map.event_id == sngl_inspiral.event_id
	)
	JOIN sim_inspiral AS sim ON sim.simulation_id == sim_coinc_map.simulation_id
			"""):
				if end_time in contents.seglists[instrument]:
					if instrument not in self.injections:
						self.injections[instrument] = BackgroundVsInjectionPlots.Points()
					self.injections[instrument].snr.append(snr)
					self.injections[instrument].chi2.append(chi2)
					self.injections[instrument].bankveto.append(bankveto)
					self.injections[instrument].spin.append((spin / 2.)**.5)

	def finish(self):
		for instrument in set(self.injections) | set(self.background) | set(self.zerolag):
			self.injections.setdefault(instrument, BackgroundVsInjectionPlots.Points())
			self.background.setdefault(instrument, BackgroundVsInjectionPlots.Points())
			self.zerolag.setdefault(instrument, BackgroundVsInjectionPlots.Points())
		for instrument in self.background:
			fig, axes = create_plot(r"$\rho$", r"$\chi^{2}$")
			axes.set_title(r"$\chi^{2}$ vs.\ $\rho$ in %s (Closed Box)" % instrument)

			for (spinstart, spinstop) in [(0,0.1), (0.1,0.2), (0.2,0.3), (0.3,0.4), (0.4,0.5), (0.5, 0.6), (0.6, 1.0)][::-1]:
				injsnr = numpy.array([self.injections[instrument].snr[n] for n in range(len(self.injections[instrument].snr)) if self.injections[instrument].spin[n] >= spinstart and self.injections[instrument].spin[n] < spinstop])
				injchi2 = numpy.array([self.injections[instrument].chi2[n] for n in range(len(self.injections[instrument].snr)) if self.injections[instrument].spin[n] >= spinstart and self.injections[instrument].spin[n] < spinstop])
				axes.loglog(injsnr, injchi2, '.', label = "Inj $|s|$=%.1f" % spinstart)

			axes.loglog(self.background[instrument].snr, self.background[instrument].chi2, "kx", label = "Background")
			axes.legend(loc = "upper left")
			yield fig, "chi2_vs_rho_%s" % instrument, False

			fig, axes = create_plot(r"$\rho$", r"$\chi^{2}$")
			axes.set_title(r"$\chi^{2}$ vs.\ $\rho$ in %s" % instrument)
			for (spinstart, spinstop) in [(0,0.1), (0.1,0.2), (0.2,0.3), (0.3,0.4), (0.4,0.5), (0.5, 0.6), (0.6, 1.0)][::-1]:
				injsnr = numpy.array([self.injections[instrument].snr[n] for n in range(len(self.injections[instrument].snr)) if self.injections[instrument].spin[n] >= spinstart and self.injections[instrument].spin[n] < spinstop])
				injchi2 = numpy.array([self.injections[instrument].chi2[n] for n in range(len(self.injections[instrument].snr)) if self.injections[instrument].spin[n] >= spinstart and self.injections[instrument].spin[n] < spinstop])
				axes.loglog(injsnr, injchi2, '.', label = "Inj $|s|$=%.1f" % spinstart)
			axes.loglog(self.background[instrument].snr, self.background[instrument].chi2, "kx", label = "Background")
			axes.loglog(self.zerolag[instrument].snr, self.zerolag[instrument].chi2, "bx", label = "Zero-lag")
			axes.legend(loc = "upper left")
			yield fig, "chi2_vs_rho_%s" % instrument, True


#
# =============================================================================
#
#               Background vs. Injections --- Multi Instrument
#
# =============================================================================
#


class BackgroundVsInjectionPlotsMulti(object):
	class Points(object):
		def __init__(self):
			self.background_snreff = []
			self.injections_snreff = []
			self.zerolag_snreff = []
			self.background_deff = []
			self.injections_deff = []
			self.zerolag_deff = []

	def __init__(self, snrfactor):
		self.snrfactor = snrfactor
		self.points = {}

	def add_contents(self, contents):
		if contents.sim_inspiral_table is None:
			# non-injections file
			for values in contents.connection.cursor().execute("""
SELECT
	sngl_inspiral_x.*,
	sngl_inspiral_y.*,
	EXISTS (
		SELECT
			*
		FROM
			time_slide
		WHERE
			time_slide.time_slide_id == coinc_event.time_slide_id
			AND time_slide.offset != 0
	)
FROM
	coinc_event
	JOIN coinc_event_map AS coinc_event_map_x ON (
		coinc_event_map_x.coinc_event_id == coinc_event.coinc_event_id
	)
	JOIN sngl_inspiral AS sngl_inspiral_x ON (
		coinc_event_map_x.table_name == 'sngl_inspiral'
		AND coinc_event_map_x.event_id == sngl_inspiral_x.event_id
	)
	JOIN coinc_event_map AS coinc_event_map_y ON (
		coinc_event_map_y.coinc_event_id == coinc_event.coinc_event_id
	)
	JOIN sngl_inspiral AS sngl_inspiral_y ON (
		coinc_event_map_y.table_name == 'sngl_inspiral'
		AND coinc_event_map_y.event_id == sngl_inspiral_y.event_id
	)
	JOIN postcoh ON (
		postcoh.coinc_event_id == coinc_event.coinc_event_id
	)
WHERE
	coinc_event.coinc_def_id == ?
	AND sngl_inspiral_x.ifo > sngl_inspiral_y.ifo
			""", (contents.ii_definer_id,)):
				x = contents.sngl_inspiral_table.row_from_cols(values)
				y = contents.sngl_inspiral_table.row_from_cols(values[len(contents.sngl_inspiral_table.columnnames):])
				is_background, = values[-1:]
				instrument_pair = (x.ifo, y.ifo)
				if instrument_pair not in self.points:
					self.points[instrument_pair] = BackgroundVsInjectionPlotsMulti.Points()
				if is_background:
					self.points[instrument_pair].background_snreff.append((x.get_effective_snr(fac = self.snrfactor), y.get_effective_snr(fac = self.snrfactor)))
					self.points[instrument_pair].background_deff.append((x.eff_distance, y.eff_distance))
				else:
					self.points[instrument_pair].zerolag_snreff.append((x.get_effective_snr(fac = self.snrfactor), y.get_effective_snr(fac = self.snrfactor)))
					self.points[instrument_pair].zerolag_deff.append((x.eff_distance, y.eff_distance))
		else:
			# injections file
			for values in contents.connection.cursor().execute("""
SELECT
	sngl_inspiral_x.*,
	sngl_inspiral_y.*
FROM
	sim_coinc_map
	JOIN coinc_event_map AS coinc_event_map_x ON (
		coinc_event_map_x.coinc_event_id == sim_coinc_map.coinc_event_id
	)
	JOIN sngl_inspiral AS sngl_inspiral_x ON (
		coinc_event_map_x.table_name == 'sngl_inspiral'
		AND coinc_event_map_x.event_id == sngl_inspiral_x.event_id
	)
	JOIN coinc_event_map AS coinc_event_map_y ON (
		coinc_event_map_y.coinc_event_id == sim_coinc_map.coinc_event_id
	)
	JOIN sngl_inspiral AS sngl_inspiral_y ON (
		coinc_event_map_y.table_name == 'sngl_inspiral'
		AND coinc_event_map_y.event_id == sngl_inspiral_y.event_id
	)
WHERE
	sngl_inspiral_x.ifo > sngl_inspiral_y.ifo
			"""):
				x = contents.sngl_inspiral_table.row_from_cols(values)
				y = contents.sngl_inspiral_table.row_from_cols(values[len(contents.sngl_inspiral_table.columnnames):])
				instrument_pair = (x.ifo, y.ifo)
				if instrument_pair not in self.points:
					self.points[instrument_pair] = BackgroundVsInjectionPlotsMulti.Points()
				self.points[instrument_pair].injections_snreff.append((x.get_effective_snr(fac = self.snrfactor), y.get_effective_snr(fac = self.snrfactor)))
				self.points[instrument_pair].injections_deff.append((x.eff_distance, y.eff_distance))

	def finish(self):
		for (x_instrument, y_instrument), points in self.points.items():
			fig, axes = create_plot(r"$\rho_{\mathrm{eff}}$ in %s" % x_instrument, r"$\rho_{\mathrm{eff}}$ in %s" % y_instrument, aspect = 1.0)
			axes.set_title(r"Effective SNR in %s vs.\ %s (SNR Factor = %g) (Closed Box)" % (y_instrument, x_instrument, self.snrfactor))
			axes.loglog([x for x, y in points.injections_snreff], [y for x, y in points.injections_snreff], "rx")
			axes.loglog([x for x, y in points.background_snreff], [y for x, y in points.background_snreff], "kx")
			axes.legend(("Injections", "Background"), loc = "lower right")
			yield fig, "rho_%s_vs_%s" % (y_instrument, x_instrument), False

			fig, axes = create_plot(r"$\rho_{\mathrm{eff}}$ in %s" % x_instrument, r"$\rho_{\mathrm{eff}}$ in %s" % y_instrument, aspect = 1.0)
			axes.set_title(r"Effective SNR in %s vs.\ %s (SNR Factor = %g)" % (y_instrument, x_instrument, self.snrfactor))
			axes.loglog([x for x, y in points.injections_snreff], [y for x, y in points.injections_snreff], "rx")
			axes.loglog([x for x, y in points.background_snreff], [y for x, y in points.background_snreff], "kx")
			axes.loglog([x for x, y in points.zerolag_snreff], [y for x, y in points.zerolag_snreff], "bx")
			axes.legend(("Injections", "Background", "Zero-lag"), loc = "lower right")
			yield fig, "rho_%s_vs_%s" % (y_instrument, x_instrument), True

			fig, axes = create_plot(r"$D_{\mathrm{eff}}$ in %s" % x_instrument, r"$D_{\mathrm{eff}}$ in %s" % y_instrument, aspect = 1.0)
			axes.set_title(r"Effective Distance in %s vs.\ %s (Closed Box)" % (y_instrument, x_instrument))
			axes.loglog([x for x, y in points.injections_deff], [y for x, y in points.injections_deff], "rx")
			axes.loglog([x for x, y in points.background_deff], [y for x, y in points.background_deff], "kx")
			axes.legend(("Injections", "Background"), loc = "lower right")
			yield fig, "deff_%s_vs_%s" % (y_instrument, x_instrument), False

			fig, axes = create_plot(r"$D_{\mathrm{eff}}$ in %s" % x_instrument, r"$D_{\mathrm{eff}}$ in %s" % y_instrument, aspect = 1.0)
			axes.set_title(r"Effective Distance in %s vs.\ %s" % (y_instrument, x_instrument))
			axes.loglog([x for x, y in points.injections_deff], [y for x, y in points.injections_deff], "rx")
			axes.loglog([x for x, y in points.background_deff], [y for x, y in points.background_deff], "kx")
			axes.loglog([x for x, y in points.zerolag_deff], [y for x, y in points.zerolag_deff], "bx")
			axes.legend(("Injections", "Background", "Zero-lag"), loc = "lower right")
			yield fig, "deff_%s_vs_%s" % (y_instrument, x_instrument), True


#
# =============================================================================
#
#                           Rate vs. Threshold Plots
#
# =============================================================================
#


def sigma_region(mean, nsigma):
	return numpy.concatenate((mean - nsigma * numpy.sqrt(mean), (mean + nsigma * numpy.sqrt(mean))[::-1]))


def create_farplot(axes, zerolag_stats, expected_count_x, expected_count_y, is_open_box, xlim = (None, None), max_events = 1000):
	#
	# isolate relevent data
	#

	zerolag_stats = zerolag_stats[:max_events]

	#
	# background.  uncomment the two lines to make the background
	# stair-step-style like the observed counts
	#

	#expected_count_x = expected_count_x.repeat(2)[1:]
	#expected_count_y = expected_count_y.repeat(2)[:-1]
	line1, = axes.plot(expected_count_x, expected_count_y, 'k--', linewidth = 1)

	#
	# error bands
	#

	expected_count_x = numpy.concatenate((expected_count_x, expected_count_x[::-1]))
	line2, = axes.fill(expected_count_x, sigma_region(expected_count_y, 3.0).clip(0.001, max_events), alpha = 0.25, facecolor = [0.75, 0.75, 0.75])
	line3, = axes.fill(expected_count_x, sigma_region(expected_count_y, 2.0).clip(0.001, max_events), alpha = 0.25, facecolor = [0.5, 0.5, 0.5])
	line4, = axes.fill(expected_count_x, sigma_region(expected_count_y, 1.0).clip(0.001, max_events), alpha = 0.25, facecolor = [0.25, 0.25, 0.25])

	#
	# zero-lag
	#

	N = numpy.arange(1., len(zerolag_stats) + 1., dtype = "double")
	line5, = axes.plot(zerolag_stats.repeat(2)[1:], N.repeat(2)[:-1], 'k', linewidth = 2)

	#
	# legend
	#

	if is_open_box:
		axes.legend((line5, line1, line4, line3, line2), ("Zero-lag", r"$\langle N \rangle$", r"$\pm\sqrt{\langle N \rangle}$", r"$\pm 2\sqrt{\langle N \rangle}$", r"$\pm 3\sqrt{\langle N \rangle}$"), loc = "upper right")
	else:
		axes.legend((line5, line1, line4, line3, line2), (r"$\pi$ shift", r"$\langle N \rangle$", r"$\pm\sqrt{\langle N \rangle}$", r"$\pm 2\sqrt{\langle N \rangle}$", r"$\pm 3\sqrt{\langle N \rangle}$"), loc = "upper right")

	#
	# adjust bounds of plot
	#

	xlim = max(zerolag_stats.min(), xlim[0]), (2.**math.ceil(math.log(zerolag_stats.max(), 2.)) if xlim[1] is None else xlim[1])
	axes.set_xlim(xlim)
	axes.set_ylim((0.001, 10.**math.ceil(math.log10(max_events))))


class RateVsThreshold(object):
	def __init__(self, tag):
		self.tag = tag
		self.zerolag_snr = []
		self.zerolag_rank = []
		self.zerolag_far = []
		self.zerolag_fap = []
		self.bg_snr = []
		self.bg_rank = []
		self.bg_far = []
		self.bg_fap = []
		self.livetime = 0

	def reset_tag(self, tag):
		self.tag = tag

	def add_contents(self, contents):
		if contents.sim_inspiral_table is not None:
			# skip injection documents
			return

		self.livetime = contents.segs_livetime
		# FIXME: first should be rank
		select_candidates = contents.connection.cursor().execute("""
SELECT
	postcoh.fap,
	postcoh.far,
	postcoh.fap,
	postcoh.cohsnr
FROM
	postcoh
WHERE
	postcoh.cohsnr >= 4
		""").fetchall()
		if self.tag == "noninj":
			for (rank, far, fap, snr) in select_candidates:
				self.zerolag_rank.append(rank)
				self.zerolag_far.append(far)
				self.zerolag_fap.append(fap)
				self.zerolag_snr.append(snr)
		elif self.tag == "shift":
			for (rank, far, fap, snr) in select_candidates:
				self.bg_rank.append(rank)
				self.bg_far.append(far)
				self.bg_fap.append(fap)
				self.bg_snr.append(snr)

	def finish(self):
		if self.bg_snr:
			try:
				fig, axes = create_plot(x_label = r"SNR", y_label = r"$\ln \Lambda$")
				axes.loglog(self.bg_snr, self.bg_rank, "kx", label = "Background")
				axes.legend(loc = "upper left")
				axes.set_title(r"$\ln \Lambda$ vs.\ SNR Scatter Plot (Closed Box)")
				yield fig, "lr_vs_snr", False
			except: # snr or rank has 0 values
				pass

		if self.bg_snr and self.zerolag_snr:
			try:
				fig, axes = create_plot(x_label = r"SNR", y_label = r"$\ln \Lambda$")
				axes.loglog(self.bg_snr, self.bg_rank, "kx", label = "Background")
				axes.loglog(self.zerolag_snr, self.zerolag_rank, "bx", label = "Zero-lag")
				axes.legend(loc = "upper left")
				axes.set_title(r"$\ln \Lambda$ vs.\ SNR Scatter Plot")
				yield fig, "lr_vs_snr", True
			except: # snr or rank has 0 values
				pass

		for ranks, fars, is_open_box in [(self.zerolag_rank, self.zerolag_far, True), (self.bg_rank, self.bg_far, False)]:
			if fars:
				fig, axes = create_plot(None, r"Number of Events")
				axes.loglog()
				# fars in ascending order --> ifars in descending order
				zerolag_stats = 1. / numpy.array(sorted(fars))
				expected_count_y = numpy.logspace(-7, numpy.log10(len(zerolag_stats)), 1000)
				expected_count_x = self.livetime / expected_count_y
				create_farplot(axes, zerolag_stats, expected_count_x, expected_count_y, is_open_box, xlim = (None, 2000. * self.livetime))
				if is_open_box:
					axes.set_title(r"Event Count vs.\ Inverse False-Alarm Rate Threshold")
				else:
					axes.set_title(r"Event Count vs.\ Inverse False-Alarm Rate Threshold (Closed Box)")
				axes.set_xlabel(r"Inverse False-Alarm Rate (s)")
				yield fig, "count_vs_ifar", is_open_box

			# if we have some values in ranks
#			if ranks:
#				fig, axes = create_plot(None, r"Number of Events")
#				axes.semilogy()
#
#				zerolag_stats = numpy.array(sorted(ranks, reverse = True))
#
#				# we want to plot FAR(ln L) * livetime vs.
#				# ln L, but we don't have access to the
#				# ranking statistic data file where that
#				# function is encoded.  instead, we rely on
#				# the FARs stored in each coinc, together
#				# with the ln L assigned to each coinc, to
#				# provide us with a collection of samples
#				# of that function.  to get more points, we
#				# combine data from the zero-lag and
#				# background coincs.  in the future,
#				# perhaps this program could be provided
#				# with the marginalized ranking statistic
#				# PDF data file
#
#				expected_count_x = self.zerolag_rank + self.bg_rank
#				order = range(len(expected_count_x))
#				order.sort(key = lambda i: expected_count_x[i], reverse = True)
#				expected_count_x = numpy.array(expected_count_x)[order]
#				expected_count_y = numpy.array(self.zerolag_far + self.bg_far)[order] * self.livetime
#
#				create_farplot(axes, zerolag_stats, expected_count_x, expected_count_y, is_open_box, xlim = (None, 23.), max_events = 10000)
#				if is_open_box:
#					axes.set_title(r"Event Count vs.\ Ranking Statistic Threshold")
#				else:
#					axes.set_title(r"Event Count vs.\ Ranking Statistic Threshold (Closed Box)")
#				axes.set_xlabel(r"$\ln \Lambda$")
#				yield fig, "count_vs_lr", is_open_box
#

#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Parse command line
#


options, filenames = parse_command_line()


#
# Initialize plots
#


# how many there could be, so we know how many digits for the filenames

def setup_plot(dbname, plot_group, options, user_tag, wiki):
    working_filename = dbtables.get_connection_filename(dbname, tmp_path = options.tmp_space, verbose = options.verbose)
    connection = sqlite3.connect(working_filename)
    contents = CoincDatabase(connection, options.segments_name, veto_segments_name = options.vetoes_name, verbose = options.verbose, plotsummary_json = os.path.split(dbname)[-1].replace(".sqlite","").replace(".tmp",""), wiki = wiki, base = os.path.join(options.output_dir, user_tag))
    if contents.sim_inspiral_table is not None:
        create_sim_coinc_view(connection)
    for (n, plot) in plot_group:
	if options.verbose:
		print >>sys.stderr, "adding to plot group %d ..." % n
	plot.add_contents(contents)
    connection.close()
    dbtables.discard_connection_filename(dbname, working_filename, verbose = options.verbose)
    return contents

def finish_plot(contents, plot_group, options, user_tag):
    for (n, plot) in plot_group:
        for (fig, filename_fragment, is_open_box) in plot.finish():
	    for format in options.format:
		if filename_fragment and fig:
                        filename_template = inspiral_pipe.T050017_filename("H1L1V1", "GSTLAL_INSPIRAL_PLOTSUMMARY_%s_%02d_%s_%s", contents.seglists.extent_all()[0], contents.seglists.extent_all()[0], "%s", path = options.output_dir)
			filename = filename_template % (user_tag, n, filename_fragment, ("openbox" if is_open_box else "closedbox"), format)
			if options.verbose:
				print >>sys.stderr, "writing %s ..." % filename
			fig.savefig(filename)


wiki = open(os.path.join(options.output_dir, "%s" % "plotsummary.txt"),"w")

if options.noninj_database:
    plots = []
    base = os.path.join(options.output_dir, options.noninj_user_tag)
    plots.append(SegmentsTable(base))
    plots.append(SummaryTable("noninj"))
    # need the shift database to plot rates
    rate_plot = RateVsThreshold("noninj")
    plots.append(rate_plot)
    plot_group = zip([0,1,6], plots)
    dbname = options.noninj_database
    contents = setup_plot(dbname, plot_group, options, options.noninj_user_tag, wiki)
    finish_plot(contents, plot_group, options, options.noninj_user_tag)
    del contents

if options.shift_database:
    plots = []
    base = os.path.join(options.output_dir, options.shift_user_tag)
    plots.append(SegmentsTable(base))
    plots.append(SummaryTable("shift"))
    if rate_plot:
	rate_plot.reset_tag("shift")
    else:
    	rate_plot = RateVsThreshold("shift")
    plots.append(rate_plot)
    plot_group = zip([0,1,6], plots)
    dbname = options.shift_database
    contents = setup_plot(dbname, plot_group, options, options.shift_user_tag, wiki)
    finish_plot(contents, plot_group, options, options.shift_user_tag)
    del contents


if options.inj_database:
    for (inj_name, tag_name) in zip(options.inj_database.split(","), options.inj_user_tag.split(",")):
        plots = []
        base = os.path.join(options.output_dir, tag_name)
        plots.append(MissedFoundPlots(far_thresh = options.far_threshold))
        plots.append(ParameterAccuracyPlots(far_thresh = options.far_threshold))
        plots.append(InjectionParameterDistributionPlots())
        plot_group = zip([2,3,7], plots)
        dbname = inj_name
        contents = setup_plot(dbname, plot_group, options, tag_name, wiki)
        finish_plot(contents, plot_group, options, tag_name)
        del contents

#
# Process files
#


# noninj database
#
# Finish and write plots, deleting them as we go to save memory
#


