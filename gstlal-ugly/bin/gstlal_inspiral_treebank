#!/usr/bin/python
import itertools
import numpy
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import table
from glue.ligolw import utils
from glue.ligolw import ilwd
from glue.ligolw.utils import process as ligolw_process
from gstlal import metric as metric_module
from gstlal import tree
# FIXME dont do this
from gstlal.tree import *
import os,sys,argparse


# Read command line options
def parse_command_line():

	parser = argparse.ArgumentParser(description="Template generator via a binary tree decomposition.")
	parser.add_argument("-v", "--verbose", action="store_true", default=False,\
					help="Be verbose.")
	parser.add_argument("--Mq", action="store_true", default=False,\
					help="Use total mass and mass ratio coordinates.")
	parser.add_argument("-d", "--debug", action="store_true", default=False,\
					help="Extra explicit information for debugging and sanity checks.")
	parser.add_argument("-o", "--output-name", action="store", default="treebank.xml.gz",\
					help="Specify output bank filename.")

	# mass limits
	parser.add_argument("--min-mass1", action="store", type=float,\
					default=3.0, help="Minimum mass1 to generate bank.")
	parser.add_argument("--max-mass1", action="store", type=float,\
					default=10.0, help="Maximum mass1 to generate bank.")
	parser.add_argument("--min-mass2", action="store", type=float,\
					default=3.0, help="Minimum mass2 to generate bank.")
	parser.add_argument("--max-mass2", action="store", type=float,\
					default=10.0, help="Maximum mass2 to generate bank.")

	# aligned spin limits
	parser.add_argument("--min-spin1z", action="store", type=float,\
					default=0, help="Minimum mass1 to generate bank.")
	parser.add_argument("--max-spin1z", action="store", type=float,\
					default=0, help="Maximum mass1 to generate bank.")
	parser.add_argument("--min-spin2z", action="store", type=float,\
					default=0, help="Minimum mass2 to generate bank.")
	parser.add_argument("--max-spin2z", action="store", type=float,\
					default=0, help="Maximum mass2 to generate bank.")

	# in-plane spin limits
	parser.add_argument("--min-spin1x", action="store", type=float,\
					default=0, help="Minimum mass1 to generate bank.")
	parser.add_argument("--max-spin1x", action="store", type=float,\
					default=0, help="Maximum mass1 to generate bank.")
	parser.add_argument("--min-spin2x", action="store", type=float,\
					default=0, help="Minimum mass2 to generate bank.")
	parser.add_argument("--max-spin2x", action="store", type=float,\
					default=0, help="Maximum mass2 to generate bank.")
	parser.add_argument("--min-spin1y", action="store", type=float,\
					default=0, help="Minimum mass1 to generate bank.")
	parser.add_argument("--max-spin1y", action="store", type=float,\
					default=0, help="Maximum mass1 to generate bank.")
	parser.add_argument("--min-spin2y", action="store", type=float,\
					default=0, help="Minimum mass2 to generate bank.")
	parser.add_argument("--max-spin2y", action="store", type=float,\
					default=0, help="Maximum mass2 to generate bank.")

	parser.add_argument("--min-inc", action="store", type=float,\
					default=0, help="Minimum inclination to generate bank. Relevant only for precessing / sub-dominant mode banks.")
	parser.add_argument("--max-inc", action="store", type=float,\
					default=numpy.pi/2, help="Maximum inclination to generate bank. Relevant only for precessing / sub-dominant mode banks.")

	# meta-params
	parser.add_argument("--min-match", action="store", type=float,\
					default=0.95, help="Minimum match to generate bank.")
	parser.add_argument("--stochastic", action="store_true", \
					default=False, help="Use stochastic placement for tiling instead of a regular lattice.")
	parser.add_argument("--disable-neighbors", action="store_true", \
					default=False, help="Compute matches between all tempaltes for new stochastic proposals.")
	parser.add_argument("--rng-seed", action="store", type=float,\
					default=314, help="Set seed used for random number generator. Relevant only when using stocahstic placement.")
	parser.add_argument("--flow", action="store", type=float,\
					default=30.0, help="Low frequency cutoff for overlap calculations.")
	parser.add_argument("--fhigh", action="store", type=float,\
					default=1024.0, help="High frequency cutoff for overlap calculations.")
	parser.add_argument("--approximant", action="store", type=str,\
					default="IMRPhenomD", help="Specify approximant.")
	parser.add_argument("--psd-file", action="store",\
					default=None, help="Input PSD file.")
	parser.add_argument("--noise-model", action="store",\
					default=None, help="Specify standard noise model.")

	args = parser.parse_args()

	numpy.random.seed(args.rng_seed)

	if args.noise_model and args.psd_file:
		raise ValueError("Cannot specify both --psd-file and --noise-model")

	if not (args.noise_model or args.psd_file):
		raise ValueError("Must specify a PSD.")

	if args.noise_model:
		raise NotImplementedError("IMPLEMENT NOISE MODELS!!")

	return args



# Initialize coordinate function
args = parse_command_line()
#
# Set up the hypercube which bounds the entire space.
#
coord_limits = []
positions = [] # I don't really get this?

# FIXME: This loop has to ensure that the parameter limits make sense. For
#   instance, the user should not specify inclination limits when the bank is
#   intended to be aligned-spin dominant mode.
for i, v in enumerate(("mass1", "mass2", "spin1x", "spin1y", "spin1z", "spin2x", "spin2y", "spin2z")):
	xi = getattr(args, "min_%s" % v)
	xf = getattr(args, "max_%s" % v)
	dx = xf-xi
	if dx !=0:
		coord_limits.append([xi,xf])
		positions.append(i)
# Function to map from the coordinates used for template placement and the
# metric calculation and the coordinates needed to call into LALSimulation, the
# latter of which includes parameters that may have fixed values.
#   FIXME: Assumes fixed value is zero, but user could specify identical but
#	 non-zero min/max values.
#   FIXME: Supports only precessing template banks. Add
#	 support for sub-dominant mode banks.
#   FIXME: Define a number of standard coordinate functions. This one here is
#	 essentially just the identity mapping.
def coord_func(coords, positions = positions):
	out = numpy.zeros(8)
	for i, pi in enumerate(positions):
		out[pi] = coords[i]
	return out

if args.Mq:
	coord_func = metric_module.M_q_func
else:
	coord_func = coord_func

# Initialize the metric and set the coordinate function
g_ij = metric_module.Metric(
	args.psd_file,
	coord_func = coord_func,
	#coord_func = coord__func,
	duration = 4, # FIXME!!!!!
	flow = args.flow,
	fhigh = args.fhigh,
	approximant = args.approximant)

mismatch = 1.0 - args.min_match

# Initialize the tree root and then split with a given splitsize
def trans_M_q(coord_limits):
	M = []
	q = []
	for mass1 in coord_limits[0]:
		for mass2 in coord_limits[1]:
			M.append(mass1 + mass2)
			q.append(mass1 / mass2)
	#M_q_vertices = zip(M,q)
	q = list(map(lambda x: x if x < 1.0 else x**-1, q))
	print q
	M_limits = [min(M), max(M)]
	q_limits = [min(q), max(q)]
	return [M_limits, q_limits]

if args.Mq:
	coord_limits_2 = trans_M_q(coord_limits)
	bank = Node(HyperCube(numpy.array(coord_limits_2), mismatch, symmetry_func = lambda x: True, metric = g_ij))
else:
	coord_limits_2 = coord_limits
	bank = Node(HyperCube(numpy.array(coord_limits_2), mismatch, symmetry_func = tree.mass_sym, metric = g_ij))


if args.verbose:
	print "The bank size according to the center metric: ", bank.cube.size
	print "The bank boundaries are: "
	for row in bank.cube.boundaries:
		print "\t", row

mismatch = 1.0 - args.min_match
bank.split(2, mismatch = mismatch, verbose = args.verbose)

# prepare a new XML document for writing template bank
xmldoc = ligolw.Document()
xmldoc.appendChild(ligolw.LIGO_LW())
sngl_inspiral_columns = ("process_id", "mass1", "mass2", "spin1x", "spin1y", "spin1z", "spin2x", "spin2y", "spin2z")
tbl = lsctables.New(lsctables.SnglInspiralTable, columns = sngl_inspiral_columns)
xmldoc.childNodes[-1].appendChild(tbl)
# FIXME make a real process table
process = ligolw_process.register_to_xmldoc(xmldoc, sys.argv[0], {})
ligolw_process.set_process_end_time(process)

previous_tiles = []
nodes = bank.leafnodes()
patches = []
expected = 0
bad_metrics = 0
for n, c in enumerate(nodes):

	tiles = c.tile(mismatch = mismatch, stochastic = args.stochastic)
	expected += c.num_templates(mismatch)
	if not c.metric.metric_is_valid:
		bad_metrics+=1

	for t in tiles:
		row = lsctables.SnglInspiralTable.RowType()
		row.mass1, row.mass2, row.spin1x, row.spin1y, row.spin1z, row.spin2x, row.spin2y, row.spin2z = coord_func(t)
		row.event_id = ilwd.ilwdchar('sngl_inspiral:event_id:%d' % len(tbl))
		row.ifo = "H1" # FIXME
		if row.mass1 < row.mass2:
			mass1 = row.mass1
			row.mass1 = row.mass2
			row.mass2 = mass1
		row.process_id = process.process_id
		if coord_limits[0][0] <= row.mass1 <= coord_limits[0][1] and coord_limits[1][0] <= row.mass2 <= coord_limits[1][1]: 
			tbl.append(row)
			previous_tiles.append(t)

        if args.verbose:
		print "Placed %04d tiles in hyperrectangle %d/%d with boundary:" % (len(tiles), n+1, len(nodes))
		for row in c.boundaries:
			print "\t", row
                print "\tcurrent bank size: %d" % len(tbl)
	patches.append(c.boundaries)

print "bad metrics ", bad_metrics

numpy.save("patches.npy", numpy.array(patches))

utils.write_filename(xmldoc, args.output_name,  gz=args.output_name.endswith("gz"))

if args.verbose:
	print >>sys.stderr, "Number of leaf nodes: ", n+1
	print >>sys.stderr, "Number of templates (tiles): ", len(tbl)
	print >>sys.stderr, "Expected number ", expected
