#!/usr/bin/python
import itertools
import numpy
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import table
from glue.ligolw import utils
from glue.ligolw import ilwd
from glue.ligolw.utils import process as ligolw_process
from pylal.xlal.datatypes.snglinspiraltable import SnglInspiralTable
from gstlal import metric as metric_module
from gstlal import tree
# FIXME dont do this
from gstlal.tree import *
import os,sys,argparse

# Read command line options
def parse_command_line():

	parser = argparse.ArgumentParser(description="Template generator via a binary tree decomposition.")
	parser.add_argument("-v", "--verbose", action="store_true", default=False,\
					help="Be verbose.")
	parser.add_argument("-d", "--debug", action="store_true", default=False,\
					help="Extra explicit information for debugging and sanity checks.")
	parser.add_argument("-o", "--output-name", action="store", default="treebank.xml.gz",\
					help="Specify output bank filename.")

	# mass limits
	parser.add_argument("--min-mass1", action="store", type=float,\
					default=3.0, help="Minimum mass1 to generate bank.")
	parser.add_argument("--max-mass1", action="store", type=float,\
					default=10.0, help="Maximum mass1 to generate bank.")
	parser.add_argument("--min-mass2", action="store", type=float,\
					default=3.0, help="Minimum mass2 to generate bank.")
	parser.add_argument("--max-mass2", action="store", type=float,\
					default=10.0, help="Maximum mass2 to generate bank.")

	# aligned spin limits
	parser.add_argument("--min-spin1z", action="store", type=float,\
					default=0, help="Minimum mass1 to generate bank.")
	parser.add_argument("--max-spin1z", action="store", type=float,\
					default=0, help="Maximum mass1 to generate bank.")
	parser.add_argument("--min-spin2z", action="store", type=float,\
					default=0, help="Minimum mass2 to generate bank.")
	parser.add_argument("--max-spin2z", action="store", type=float,\
					default=0, help="Maximum mass2 to generate bank.")

	# in-plane spin limits
	parser.add_argument("--min-spin1x", action="store", type=float,\
					default=0, help="Minimum mass1 to generate bank.")
	parser.add_argument("--max-spin1x", action="store", type=float,\
					default=0, help="Maximum mass1 to generate bank.")
	parser.add_argument("--min-spin2x", action="store", type=float,\
					default=0, help="Minimum mass2 to generate bank.")
	parser.add_argument("--max-spin2x", action="store", type=float,\
					default=0, help="Maximum mass2 to generate bank.")
	parser.add_argument("--min-spin1y", action="store", type=float,\
					default=0, help="Minimum mass1 to generate bank.")
	parser.add_argument("--max-spin1y", action="store", type=float,\
					default=0, help="Maximum mass1 to generate bank.")
	parser.add_argument("--min-spin2y", action="store", type=float,\
					default=0, help="Minimum mass2 to generate bank.")
	parser.add_argument("--max-spin2y", action="store", type=float,\
					default=0, help="Maximum mass2 to generate bank.")

	parser.add_argument("--min-inc", action="store", type=float,\
					default=0, help="Minimum inclination to generate bank. Relevant only for precessing / sub-dominant mode banks.")
	parser.add_argument("--max-inc", action="store", type=float,\
					default=numpy.pi/2, help="Maximum inclination to generate bank. Relevant only for precessing / sub-dominant mode banks.")

	# meta-params
	parser.add_argument("--min-match", action="store", type=float,\
					default=0.95, help="Minimum match to generate bank.")
	parser.add_argument("--flow", action="store", type=float,\
					default=30.0, help="Low frequency cutoff for overlap calculations.")
	parser.add_argument("--fhigh", action="store", type=float,\
					default=1024.0, help="High frequency cutoff for overlap calculations.")
	parser.add_argument("--approximant", action="store", type=str,\
					default="IMRPhenomD", help="Specify approximant.")
	parser.add_argument("--psd-file", action="store",\
					default=None, help="Input PSD file.")
	parser.add_argument("--noise-model", action="store",\
					default=None, help="Specify standard noise model.")

	args = parser.parse_args()

	if args.noise_model and args.psd_file:
		raise ValueError("Cannot specify both --psd-file and --noise-model")

	if not (args.noise_model or args.psd_file):
		raise ValueError("Must specify a PSD.")

	if args.noise_model:
		raise NotImplementedError("IMPLEMENT NOISE MODELS!!")

	return args



# Initialize coordinate function
args = parse_command_line()
#
# Set up the hypercube which bounds the entire space.
#
coord_limits = []
positions = [] # I don't really get this?

# FIXME: This loop has to ensure that the parameter limits make sense. For
#   instance, the user should not specify inclination limits when the bank is
#   intended to be aligned-spin dominant mode.
for i, v in enumerate(("mass1", "mass2", "spin1x", "spin1y", "spin1z", "spin2x", "spin2y", "spin2z")):
	xi = getattr(args, "min_%s" % v)
	xf = getattr(args, "max_%s" % v)
	dx = xf-xi
	if dx !=0:
		coord_limits.append([xi,xf])
		positions.append(i)

# Function to map from the coordinates used for template placement and the
# metric calculation and the coordinates needed to call into LALSimulation, the
# latter of which includes parameters that may have fixed values.
#   FIXME: Assumes fixed value is zero, but user could specify identical but
#	 non-zero min/max values.
#   FIXME: Supports only precessing template banks. Add
#	 support for sub-dominant mode banks.
#   FIXME: Define a number of standard coordinate functions. This one here is
#	 essentially just the identity mapping.
def coord_func(coords, positions = positions):
	out = numpy.zeros(8)
	for i, pi in enumerate(positions):
		out[pi] = coords[i]
	return out

# Initialize the metric and set the coordinate function
g_ij = metric_module.Metric(
	args.psd_file,
	coord_func = coord_func,
	duration = 4, # FIXME!!!!!
	flow = args.flow,
	fhigh = args.fhigh,
	approximant = args.approximant)

# Initialize the tree root and then split with a given splitsize
#bank = Node(HyperCube(numpy.array(x), symmetries = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0]]), metric = g_ij))
bank = Node(HyperCube(numpy.array(coord_limits), args.min_match, symmetry_func = tree.mass_sym, metric = g_ij))

if args.verbose:
	print "The bank size according to the center metric: ", bank.cube.size
	print "The bank boundaries are: "
	for row in bank.cube.boundaries:
		print "\t", row

# Split according to how many templates you want to place in the hypercube
mismatch = 1.0 - args.min_match
bank.split(4**len(coord_limits), mismatch = mismatch, verbose = args.verbose)

# prepare a new XML document for writing template bank
xmldoc = ligolw.Document()
xmldoc.appendChild(ligolw.LIGO_LW())
tbl = lsctables.New(lsctables.SnglInspiralTable)
xmldoc.childNodes[-1].appendChild(tbl)
# FIXME make a real process table
process = ligolw_process.register_to_xmldoc(xmldoc, sys.argv[0], {})
ligolw_process.set_process_end_time(process)

totalpopcount = 0
for n, c in enumerate(bank.walk()):

	tiles, temppopcount = c.tile(mismatch = mismatch)
	totalpopcount = totalpopcount + temppopcount

	for t in tiles:
		row = SnglInspiralTable()
		row.mass1, row.mass2, row.spin1x, row.spin1y, row.spin1z, row.spin2x, row.spin2y, row.spin2z = coord_func(t)
		row.event_id = ilwd.ilwdchar('sngl_inspiral:event_id:%d' % len(tbl))
		row.ifo = "H1" # FIXME
		if row.mass1 < row.mass2:
			mass1 = row.mass1
			row.mass1 = row.mass2
			row.mass2 = mass1
		tbl.append(row)


utils.write_filename(xmldoc, args.output_name,  gz=args.output_name.endswith("gz"))

if args.verbose:
	print >>sys.stderr, "Number of leaf nodes: ", n
	print >>sys.stderr, "Number of templates (tiles): ", len(tbl)

if args.debug:
	print "Popped templates: ", totalpopcount
