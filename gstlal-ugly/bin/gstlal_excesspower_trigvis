#!/usr/bin/env python
import sys

import matplotlib
import matplotlib.gridspec
matplotlib.use("Agg")
from matplotlib import pyplot

import numpy
import math

from glue.ligolw import utils
from glue.ligolw import lsctables
from glue import segments

from optparse import OptionParser

parser = OptionParser()
parser.add_option("-c", "--channels", action="store", help="Comma separated list of channels. Will plot triggers only from the channels indicated. Otherwise, all channels will be plotted.")
parser.add_option("-o", "--output-file", action="store", help="File to output image to. Default: trigmap.png")
parser.add_option("-i", "--instruments", action="store", help="Comma separates list of instruments. Will plot channels only from the instruments indicated. Otherwise, all no instrument selection is done.")
parser.add_option("-s", "--gps-start", action="store", type=float, help="Plot triggers only after indicated gps time. Default is to infer from triggers.")
parser.add_option("-e", "--gps-end", action="store", type=float, help="Plot triggers only before indicated gps time. Default is to infer from triggers.")
parser.add_option("-f", "--low-frequency", action="store", type=float, default=32.0, help="Plot trigggers with central frequency above this frequency. Default is 32.")
parser.add_option("-F", "--high-frequency", action="store", type=float, default=2000.0, help="Plot trigggers with central frequency below this frequency. Default is 2000.")
parser.add_option("-I", "--infer-parameters", action="store_true", help="Infer the TF map dimensions from the search details in the input files.")
parser.add_option("-S", "--snr-thresh", action="store", type=float, default=0.0, help="Plot trigggers with snr greater than that indicated.")
parser.add_option("-m", "--mark-time", action="store", type=float, help="Mark a particular time on the map. Useful for identifying triggers in a file spanning a large time.")

opts, args = parser.parse_args()

if( opts.channels is not None ):
	channels = opts.channels.split(",")
else: channels = None

if( opts.instruments is not None ):
	instruments = opts.instruments.split(",")
else: instruments = None

# TODO: group by IFO

events = lsctables.SnglBurstTable()
for arg in args:
	xmldoc = utils.load_filename( arg )
	for tbl in lsctables.getTablesByType( xmldoc, lsctables.SnglBurstTable ):
		events += tbl 

	# search data
	#metad = lsctables.getTablesByType( xmldoc, lsctables.SearchSummaryTable )[0]

viewseg = segments.segment( segments.NegInfinity, segments.PosInfinity )
if( opts.gps_start is None ):
	viewseg = segments.segment( min([e.peak_time for e in events]), viewseg[1] )
else: viewseg = segments.segment( opts.gps_start, viewseg[1] )
if( opts.gps_end is None ):
	viewseg = segments.segment( viewseg[0], max([e.peak_time for e in events]) )
else: viewseg = segments.segment( viewseg[0], opts.gps_end )

if( instruments is None and channels is None ):
	instruments = {}
	for event in events:
		instruments[event.ifo] = None
	instruments = instruments.keys()
if( instruments is None ):
	instruments = {}
	for channel in channels:
		instruments[channel.split(":")[0]] = None
	instruments = instruments.keys()

print "Examining instruments: %s" % str(instruments)

if( channels is None ):
	channels = {}
	for event in events:
		if( event.ifo in instruments ):
			channels[(event.ifo, event.channel)] = None
	channels = channels.keys()
	channels.sort()
	print "Looking at channel list:\n", "\n".join( map(lambda cl: ":".join(cl), channels) )
else:
	# TODO: Fix this -- it's stupid
	channels.sort()
	print "Looking at channel list:\n", "\n".join( channels )
	channels = [ c.split(":") for c in channels ]

# construct tf map extent
fig = pyplot.figure(figsize=(10,len(channels)*5))
gs = matplotlib.gridspec.GridSpec( nrows = len(channels), ncols = 2, width_ratios=[30,1])#, hspace=0.3 )

for i, chan in enumerate(channels):
	inst, channel = chan
	ax = pyplot.subplot(gs[2*i])

	# Extent in time
	ax.set_xlim(viewseg[0], viewseg[1])
	# Extent in frequency
	# FIXME: Different Channels won't have the same ifrequencysettings
	ax.set_ylim(opts.low_frequency, opts.high_frequency)

	sys.stdout.write( "Filtering %d events... " % len(events) )
	selected_events = [ event.snr for event in events if event.channel == channel and event.ifo == inst and event.central_freq < opts.high_frequency and event.central_freq > opts.low_frequency and event.peak_time in viewseg ]
	print "%d events remain." % len(selected_events)

	# what's our snr scale
	# FIXME: look only at selected events
	snr_norm = matplotlib.colors.Normalize( 
		min(selected_events), max(selected_events) 
	)
	colormap = matplotlib.cm.ScalarMappable( norm = snr_norm, cmap = matplotlib.cm.jet )

	# Make me purty
	ax.grid()
	if( opts.mark_time in viewseg ):
		pyplot.axvline(opts.mark_time, color="k")

	if( i == len(channels)-1 ):
		pyplot.xlabel( "Time (s)" )
	pyplot.ylabel( "Frequency (Hz)" )
	title = "channel: %s, inst %s" % (channel, inst)
	if( i == 0 ):
		title = "SNR time frequency map\n%s" % title
	pyplot.title( title )

	# construct tiles
	# FIXME: Partition events first
	for event in sorted(events, key=lambda tbl: tbl.snr ):
		if( event.channel != channel ): continue
		if( event.ifo != inst ): continue
		if( not (event.peak_time in viewseg) ): continue

		# 1. plot tile 
		start = event.get_peak()# + event.start_time_ns*1e-9
		tile = matplotlib.patches.Rectangle(
			# lower left point
			( start,
			# FIXME: Presumes tile energy is uniform in frequency
			(event.central_freq - event.bandwidth/2.0) ),
			# tile extent
			event.duration/2.0,
			event.bandwidth,
			color = colormap.to_rgba( event.snr )
		)
		ax.add_patch( tile )
		

	ax = pyplot.subplot( gs[2*i+1] )
	cbl = matplotlib.colorbar.ColorbarBase( ax, cmap=matplotlib.cm.jet, norm=snr_norm, orientation="vertical" )
	cbl.set_label( "SNR" )

filename = opts.output_file or "trigmap"
if( opts.mark_time ): filename += "_%d" % int(opts.mark_time)
fig.savefig( "%s.png" % filename )
