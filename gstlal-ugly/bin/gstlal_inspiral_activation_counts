#!/usr/bin/python
import sys
import itertools
from gstlal import metric as metric_module
from ligo.lw import ligolw
from ligo.lw import utils as ligolw_utils
from ligo.lw import lsctables, param, array
import numpy
import argparse
import h5py
from gstlal import svd_bank

@array.use_in
@param.use_in
@lsctables.use_in
class LIGOLWContentHandler(ligolw.LIGOLWContentHandler):
	pass

def mchirp(m1, m2):
	return (m1*m2)**.6 / (m1+m2)**.2

# Cody's injection cutting scheme
def mchirp_bounds(ml, mh):
	if mh < 10:
		return 0.65*m1, 1.35*mh
	elif mh < 20:
		return 0.5*m1, 1.5*mh
	else:
		return 0.5*m1, 2.0*mh


parser = argparse.ArgumentParser()
parser.add_argument("--output", help = "provide the output file")
parser.add_argument("--psd-xml-file", help = "provide a psd xml file")
parser.add_argument("--svd-file", help = "provide the bank file for which overlaps will be calculated")
parser.add_argument("--m1", action = "append", help = "provide the num:start:stop parameters for mass 1, e.g., 100:1:3")
parser.add_argument("--m2", action = "append", help = "provide the num:start:stop parameters for mass 2, e.g., 100:1:3")
parser.add_argument("--s1", action = "append", help = "provide the num:start:stop parameters for spin 1, e.g., 11:-1:1")

args = parser.parse_args()

outfile = open(args.output, "w")

g_ij = metric_module.Metric(
	args.psd_xml_file,
	coord_func = metric_module.x_y_z_zn_func,
	duration = 1.0, # FIXME!!!!!
	flow = 10,
	fhigh = 1024,
	approximant = "IMRPhenomD"
)

sngl_inspiral_table = []
for n, bank in enumerate(svd_bank.read_banks(args.svd_file, contenthandler = LIGOLWContentHandler, verbose = True)):
	sngl_inspiral_table.extend([row for row in bank.sngl_inspiral_table])

min_mchirp = min(row.mchirp for row in sngl_inspiral_table)
max_mchirp = max(row.mchirp for row in sngl_inspiral_table)

def x_y_z_zn_from_row(row):
	return [metric_module.x_from_m1_m2_s1_s2(row.mass1, row.mass2, row.spin1z, row.spin2z),
		metric_module.y_from_m1_m2_s1_s2(row.mass1, row.mass2, row.spin1z, row.spin2z),
		metric_module.z_from_m1_m2_s1_s2(row.mass1, row.mass2, row.spin1z, row.spin2z),
		metric_module.zn_from_m1_m2_s1_s2(row.mass1, row.mass2, row.spin1z, row.spin2z)
		]

print >> outfile, "m1 start, m1 stop, m2 start, m2 stop, activation counts"

# compute template match functions:
print "computing metrics"
match_funcs = []
for tmp in (x_y_z_zn_from_row(row) for row in sngl_inspiral_table):
	def match(vec2, vec1 = tmp, g = g_ij(tmp)[0]):
		return  g_ij.pseudo_match(g, vec1, vec2)
	match_funcs.append(match)

snrs = numpy.linspace(8., 20., 13)
snrnorm = sum(snrs**-4)

for m1, m2, s1 in zip(args.m1, args.m2, args.s1):

	print m1, m2

	m1n,m1s,m1e = [float(x) for x in m1.split(":")]
	m2n,m2s,m2e = [float(x) for x in m2.split(":")]
	s1n,s1s,s1e = [float(x) for x in s1.split(":")]

	# uniform population in m1 / m2 space
	signals = []
	weights = []
	len_signals = 0
	for m1,m2,s1 in itertools.product(numpy.logspace(numpy.log10(m1s), numpy.log10(m1e), m1n), numpy.logspace(numpy.log10(m2s), numpy.log10(m2e), m2n), numpy.linspace(s1s, s1e, s1n)):
		# assume zero spin
		len_signals += 1
		if mchirp(m1, m2) <= max_mchirp and mchirp(m1, m2) >= min_mchirp:
			signals.append(numpy.array([metric_module.x_from_m1_m2_s1_s2(m1, m2, s1, 0), metric_module.y_from_m1_m2_s1_s2(m1, m2, s1, 0), metric_module.z_from_m1_m2_s1_s2(m1, m2, s1, 0), 0]))
			# Correct for the logarithmic distribution
			weights.append(m1*m2)
	weights = numpy.array(weights)
	signals = numpy.array(signals)

	count = 0
	print "computing counts for %d signals" % len(signals)

	if len(signals) > 0:		
		for n, match_func in enumerate(match_funcs):
			matches = numpy.apply_along_axis(match_func, 1, signals)
			for rho in snrs:
				count += rho**-4 / snrnorm / len_signals * (numpy.exp(-rho**2*(1.0 - matches)**2/2.) * weights).sum()

	print >> outfile, "%f, %f, %f, %f, %e" % (m1s, m1e, m2s, m2e, count)
