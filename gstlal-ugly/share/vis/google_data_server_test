#!/usr/bin/python

import gviz_api
import h5py
from gstlal import llweb
import os
import cgi
import cgitb
cgitb.enable()
form = cgi.parse()
import numpy
import pyparsing

description = {
	"time": ("number", "Time"),
	"latency": ("number", "Latency")
	}

# we have to get a query according to the google standard
# queries must be of the form
# tq = 
assert "tq" in form
assert "reqId" in form
query = form["tq"][0]

#
# Default values
#

data_type = "latency_history"
base_path = "/home/gstlalcbctest/engineering/10/S6/trigs_single_ifo/aggregator"
latest_path = base_path
for level in range(7):
	latest_path += "/%s" % sorted([d for d in os.listdir(path) if len(d) == 1 and d.isdigit()])[-1]
# The power of 10 that we will be accessing data at
resolution = 1000

#
# "SQL" parser.  FIXME. First, google query langauge isn't really SQL and
# second, if this keeps going we need to switch to a parsing library e.g.,
# pyparsing.  For now this is likely to be a collection of once-offs.
#

#
# Data types
#
for data in ("latency_history", "snr_history"):
	if data in form:
		data_type = data

print "Content-type: text/plain"
print
print query


if "tq" in form:
	if "latency_history" in form["tq"][0]:
		path += "/median/latency_history.hdf5"
	elif "snr_history" in form["tq"][0]:
		path += "/median/snr_history.hdf5"
	else:
		path += "/median/latency_history.hdf5"
else:
	path += "/median/latency_history.hdf5"

f = h5py.File(path, "r")
data = []

for t, d in zip(f["time"], f["data"]):
	#data.append({"time":(float(t),str(t)), "latency":(float(d),str(d))})
	d = numpy.random.rand()
	data.append({"time":(float(t),str(t)), "latency":(float(d),str(d))})
f.close()

data_table = gviz_api.DataTable(description)
data_table.LoadData(data)
print "Content-type: text/plain"
print
print data_table.ToJSonResponse(columns_order=("time", "latency"), order_by="time")
