#!/usr/bin/env python
"""
Plot latency from progressreport elements in GStreamer pipelines.

The progressreport elements' names must start with the string "progress_".
"""
__author__ = "Leo Singer <leo.singer@ligo.org>"


# Use OptionParser to generate help line, otherwise this is kind of pointless
from optparse import OptionParser, Option
(options, args) = OptionParser(
	usage='%prog [options] filename [image filename]',
	description='Plot latency from progressreport elements in GStreamer pipelines',
	option_list=[
		Option('--disable-legend', action='store_true', default=False, help='Disable figure legend.'),
		Option('--source-name', help='Name of the progress reports from which to calculate latency.'),
	]
).parse_args()


# If a positional argument is given, try to open the file with that name.
# Otherwise, read from stdin.
if len(args) > 0:
	filename = args[0]
	file = open(filename, 'r')
else:
	import sys
	file = sys.stdin
	filename = '/dev/stdin'

# If a second argument is given, use it as the filename to write to.
if len(args) > 1:
	out_filename = args[1]
else:
	out_filename = None


# Regex matching "progress_(??:??:??) ????????? seconds"
import re
regex = re.compile(r"^progress_([^ ]+) \((\d\d):(\d\d):(\d\d)\): (\d+) seconds$")


# Read file, keeping only lines that match the regex
trends = {}
for line in file:
	m = regex.match(line)
	if m is not None:
		name, hours, minutes, seconds, stream_time = m.groups()
		if name not in trends.keys():
			trends[name] = []
		trends[name].append((int(hours) * 3600 + int(minutes) * 60 + int(seconds), int(stream_time)))
file.close()


gps_start_time = min(trend[0][1] for trend in trends.values())
gps_end_time = max(trend[-1][1] for trend in trends.values())
gps_duration = gps_end_time - gps_start_time
running_duration = max(trend[-1][0] for trend in trends.values())

# Plot
if out_filename is not None:
	import matplotlib
	matplotlib.use('Agg')
import pylab

if options.source_name:
	from scipy.interpolate import interp1d
	pylab.subplot(1,2,1)
	source_trend = trends[options.source_name]
	source_data = pylab.array(source_trend)
	source_data_interp = interp1d(source_data[:,0], source_data[:,1], bounds_error=True)
	for k, v in sorted(trends.iteritems()):
		if k == options.source_name: continue
		data = pylab.array(v)
		data = data[data[:,0] < source_data[:,0].max(), :]
		latencies = data[:,1] - source_data_interp(data[:,0])
		#latencies = pylab.ma.array(latencies, mask=pylab.isfinite(latencies))
		#latencies[latencies < 0] = float('nan')
		h = pylab.hist(latencies, label=k, bins=pylab.arange(pylab.floor(latencies.min()),pylab.ceil(latencies.max())), normed=True, cumulative=0, histtype='step')
		#pylab.xlim(-1, h[0][pylab.searchsorted(h[1], 0.1)])
		#pylab.xlim(0, 200)
	pylab.legend()
	pylab.xlabel('Latency (seconds)')
	pylab.ylabel('Fraction')
	pylab.subplot(1,2,2)

# Plot diagonal grid
t0 = max(gps_duration, running_duration)
for t in range(-t0, t0, t0 / 20):
	lines = pylab.plot((0, t0), (t, t+t0), color='#cccccc')
lines[0].set_label('constant lag')

for k, v in sorted(trends.iteritems()):
	data = pylab.array(v)
	pylab.plot(data[:,0], data[:,1] - gps_start_time, label=k)

pylab.xlim((0, running_duration))
pylab.ylim((0, gps_duration))
pylab.gca().set_aspect('equal')
if not options.disable_legend:
	pylab.legend(loc='lower right')
pylab.xlabel('running time (seconds)')
pylab.ylabel('stream time - %d (seconds)' % gps_start_time)
pylab.title('Progress report for %s' % filename)
if out_filename is None:
	pylab.show()
else:
	pylab.savefig(out_filename)
