#!/usr/bin/python
#
# Copyright (C) 2019 Chad Hanna Amit Reza
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
import argparse
import itertools
import numpy, scipy.interpolate
from lal import series
from ligo.lw import utils as ligolw_utils
import sys


parser = argparse.ArgumentParser(description = 'generate a dt dphi covariance matrix')
parser.add_argument('--psd-xml', help = 'XML containing HLV psd')
parser.add_argument('--H-snr', type = float, help = 'H characteristic SNR')
parser.add_argument('--L-snr', type = float, help = 'L characteristic SNR')
parser.add_argument('--V-snr', type = float, help = 'V characteristic SNR')
args = parser.parse_args()

refpsd = args.psd_xml
rho = {"L1": args.L_snr, "H1": args.H_snr, "V1": args.V_snr}


psd = series.read_psd_xmldoc(ligolw_utils.load_filename(refpsd, verbose = True, contenthandler = series.PSDContentHandler))
psddict = {}
for ifo in psd:
	f = numpy.arange(len(psd[ifo].data.data)) * psd[ifo].deltaF
	psddict[ifo] = scipy.interpolate.interp1d(f, psd[ifo].data.data)

def fn(fmin, fmax, n, ifo, psddict = psddict):
	farr = numpy.linspace(fmin, fmax, 100000)
	df = farr[1] - farr[0]
	return 4 * numpy.sum(farr**(-7/3.) * farr**n * df / psddict[ifo](farr))

def moment(fmin, fmax, n, ifo, psddict = psddict):
	return fn(fmin, fmax, n, ifo, psddict) / fn(fmin, fmax, 0, ifo, psddict)

sigsqtt = {}
sigsqpp = {}
sigsqtp = {}
sigsqdd = {}

for ifo in rho:
	sigsqf = moment(10, 1024, 2, ifo) - moment(10, 1024, 1, ifo)**2
	sigsqtt[ifo] = (1. / (2 * 3.14 * rho[ifo] * sigsqf**.5)**2)
	sigsqpp[ifo] = moment(10, 1024, 2, ifo) / (rho[ifo]**2 * sigsqf)
	sigsqtp[ifo] = moment(10, 1024, 1, ifo) / (2 * 3.14 * rho[ifo]**2 * sigsqf)
	sigsqdd[ifo] = 1. / rho[ifo]**2

transtt = {}
transpp = {}
transtp = {}
transpt = {}
# FIXME do an actual calculation
transdd = {frozenset(("H1", "L1")): 1. / (sigsqdd["H1"] + sigsqdd["L1"])  , frozenset(("H1", "V1")): 1. / (sigsqdd["H1"] + sigsqdd["V1"]), frozenset(("L1", "V1")): 1. / (sigsqdd["L1"] + sigsqdd["V1"])}

for combo in itertools.combinations(("H1", "L1", "V1"), 2):
	a,b = combo
	m11 = sigsqtt[a] + sigsqtt[b]
	m22 = sigsqpp[a] + sigsqpp[b]
	m12 = m21 = sigsqtp[a] + sigsqtp[b]
	mat = numpy.array([[m11, m12], [m21, m22]])
	#print combo
	#print "cholesky on "
	matinv = numpy.linalg.inv(mat)
	cholesky_transpose = numpy.linalg.cholesky(matinv).T
	#print cholesky_transpose
	transtt[frozenset(combo)] = cholesky_transpose[0,0]
	transtp[frozenset(combo)] = cholesky_transpose[0,1]
	transpt[frozenset(combo)] = cholesky_transpose[1,0]
	transpp[frozenset(combo)] = cholesky_transpose[1,1]

print "transtt =", transtt
print "transtp =", transtp
print "transpt =", transpt
print "transpp =", transpp
print "transdd =", transdd

#transtt = {frozenset(("H1", "L1")): 5.19313416e+04, frozenset(("H1", "V1")): 1.39663777e+04, frozenset(("L1", "V1")): 3.98320074e+04}
#transpp = {frozenset(("H1", "L1")): 3.50152221e+00, frozenset(("H1", "V1")): 1.56080114e+00, frozenset(("L1", "V1")): 1.63248925e+00}
#transtp = {frozenset(("H1", "L1")): -6.51410977e+01, frozenset(("H1", "V1")): -2.07581116e+01, frozenset(("L1", "V1")): -6.05964763e+01}
#transpt = {frozenset(("H1", "L1")): 0.0, frozenset(("H1", "V1")): 0.0, frozenset(("L1", "V1")): 0.0}
