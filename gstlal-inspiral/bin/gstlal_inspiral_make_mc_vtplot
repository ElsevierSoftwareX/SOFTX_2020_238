#!/usr/bin/env python3

import itertools
import matplotlib
matplotlib.use("Agg")
matplotlib.rcParams.update({"text.usetex": True})
from matplotlib import pyplot
pyplot.rc('font',**{'family':'serif','serif':['Computer Modern Roman']})
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
from optparse import OptionParser
import pickle
import sqlite3

import lal
from lal import rate
from ligo import segments
from ligo.lw import ligolw, lsctables, dbtables
from gstlal import imr_utils
from gstlal.plots import util as plotutil

@lsctables.use_in
class LIGOLWContentHandler(ligolw.LIGOLWContentHandler):
	pass

def parse_command_line():
	parser = OptionParser(description = __doc__)

	# FAR range and resolution
	parser.add_option("--xaxis-points", metavar = "count", default = 50, type = "int", help = "Specify the number of false-alarm rates for which to compute the search volume.  Default is 50.")
	parser.add_option("--min-far", metavar = "Hertz", default = 1.0e-6/lal.YRJUL_SI, type = "float", help = "Specify the minimum false-alarm rate in Hertz.  Default is 1 per million years.") # one per million years is probably detection worthy
	parser.add_option("--max-far", metavar = "Hertz", default = 12.0/lal.YRJUL_SI, type = "float", help = "Specify the maximum false-alarm rate in Hertz.  Default is 1 per month.") # one per month is possibly EM-followup worthy

	# Input data options
	#parser.add_option("--injection-files", metavar = "filename", help = "XML files containing injection list (required). If there is more than one, separate them with :")
	parser.add_option("--injection-database", default = [], action = "append", help = "Name of database containing injection parameters and triggers (required).")
	parser.add_option("--zero-lag-database", default = [], action = "append", help = "Name of database containing the zero lag segments and triggers (required).")
	parser.add_option("--input-dir", default = "gstlal_inspiral_lnlrcdf_signal", metavar = "name", help = "directory of lnlrcdf_signal data")

	# Output data options
	parser.add_option("--output-dir", default = "./", metavar = "name", help = "Select a directory to place output files.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")

	options, filenames = parser.parse_args()

	options.injection_database.extend(filenames)
	#required_options = ("injection_files", "injection_database", "zero_lag_database")
	required_options = ("injection_database", "zero_lag_database")
	missing_options = [option for option in required_options if not getattr(options, option)]

	if missing_options:
		raise ValueError("%s must be set" % ", ".join("--%s" % option.replace("_", "-") for option in missing_options))

	return options

###########
#HARD CORD#
###########

#Bin injections by source type: BNS mchirp between 0.8 and 2, NSBH between 2 and 4.5, BBH between 4.5 and 45.0, IMBH between 45.0 and 450.0
bin_types = u"Source_Type"
num_split_inj = 100
source_types = ["bns", "nsbh", "bbh", "imbh"]
mbins = [0.5, 2.0, 4.5, 45., 450]

def filter_injections(inj, source_type, source_types = source_types, mbins = mbins):
	min_mchirp, max_mchirp = mbins[source_types.index(source_type):source_types.index(source_type)+2]
	return inj.mchirp >= min_mchirp and inj.mchirp < max_mchirp

##############
#MAIN PROGRAM#
##############

options = parse_command_line()

fars = np.logspace(np.log10(options.min_far), np.log10(options.max_far), options.xaxis_points)

observer = options.zero_lag_database[0].split("_")[0]
observers, observer = observer.split("-")

#
# Search live time
#
if options.verbose:
	print("Searching livetime")

normal_segments = segments.segmentlistdict()
for f in options.zero_lag_database:
	connection = sqlite3.connect(f)
	normal_segments += imr_utils.get_segments(connection, dbtables.get_xml(connection), "coinc_inspiral", "gstlal_inspiral", "vetoes", "datasegments")
zero_lag_segments = normal_segments.union(normal_segments.keys())
livetime = float(abs(zero_lag_segments))/lal.YRJUL_SI

#
# Search injection data
#
if options.verbose:
	print("Searching injection data")
connection = {}
found_injections = []
total_injections = []
for f in options.injection_database:
	inj_file = f.split("-")[1].replace("ALL_LLOID_","")
	connection[inj_file] = sqlite3.connect(f)
	#found, total, missed = imr_utils.get_min_far_inspiral_injections(connection[inj_file], segments = zero_lag_segments, table_name="coinc_inspiral")
	found, total, missed = imr_utils.get_min_far_inspiral_injections(connection[inj_file], table_name="coinc_inspiral")
	found_injections += found
	total_injections += total

total_injections = imr_utils.symmetrize_sims(total_injections, "mass1", "mass2")

distances = [tup[0] for tup in map(imr_utils.sim_to_distance_chirp_mass_bins_function, total_injections)]
bins = rate.NDBins([rate.LinearBins(min(distances), max(distances), 200), rate.IrregularBins(mbins)])

vols_lo_far, vols_far, vols_hi_far = [], [], []
for far in fars:
	found_by_far = [s for f, s in found_injections if f < far]
	eff_lo, eff, eff_hi = imr_utils.compute_search_efficiency_in_bins(found_by_far, total_injections, bins, imr_utils.sim_to_distance_chirp_mass_bins_function)
	vol_lo = imr_utils.compute_search_volume(eff_lo)
	vol_lo.array *= livetime
	vols_lo_far.append(vol_lo)

	vol = imr_utils.compute_search_volume(eff)
	vol.array *= livetime
	vols_far.append(vol)

	vol_hi = imr_utils.compute_search_volume(eff_hi)
	vol_hi.array *= livetime
	vols_hi_far.append(vol_hi)

#
# Ready for plotting
#

fig_far = pyplot.figure()
fig_far.set_size_inches((8., 8./plotutil.golden_ratio))
ax_far = fig_far.gca()
colors = {"bns":"b", "nsbh":"g", "bbh":"r", "imbh":"c"}
another_colors = {"bns":"darkblue", "nsbh":"darkgreen", "bbh":"darkred", "imbh":"darkcyan"}

#
# Read caluculation data
#
if options.verbose:
	print("reading calculation data")
injs = []
for conn in connection.values():
	injs += lsctables.SimInspiralTable.get_table(dbtables.get_xml(conn))

total_injections = [tuple(((inj.distance, inj.mchirp),)) for inj in injs]
found_injections = []
for inj_file, num_split, source_type in itertools.product(connection.keys(), range(num_split_inj), source_types):
		with open("%s/%s_%04d_%s.pkl" %(options.input_dir, inj_file, num_split, source_type), "r") as f:
			found_injections.extend(pickle.load(f))

vols_calc = []
for k, far in enumerate(fars):
	eff_lo, eff, eff_hi = imr_utils.compute_search_efficiency_in_bins(found_injections, total_injections, bins, sim_to_bins_function = lambda sim: sim[0], sim_to_found_weight_function = lambda sim: sim[1][k])
	vol = imr_utils.compute_search_volume(eff)
	vol.array *= livetime
	vols_calc.append(vol)

#
# plot injection and calculation result
#
if options.verbose:
	print("plotting calculation and injection results")

for source_type in source_types:
	#injection
	label = "Injection Result : $M_{\mathrm{chirp}} \in [%.2f, %.2f] \,\mathrm{M}_\odot$" % tuple(mbins[source_types.index(source_type):source_types.index(source_type)+2])
	center = np.array([v.array[source_types.index(source_type)] for v in vols_far])
	if (center == 0).all():
		continue
	lo = np.array([v.array[source_types.index(source_type)] for v in vols_lo_far])
	hi = np.array([v.array[source_types.index(source_type)] for v in vols_hi_far])
	line, = ax_far.plot(fars, center, label=label, linewidth=2, color=colors[source_type])
	ax_far.fill_between(fars, lo, hi, alpha=0.5, color=line.get_color())

	#calculation
	label = "Our Result : $M_{\mathrm{chirp}} \in [%.2f, %.2f] \,\mathrm{M}_\odot$" % tuple(mbins[source_types.index(source_type):source_types.index(source_type)+2])
	center = np.array([v.array[source_types.index(source_type)] for v in vols_calc])
	line, = ax_far.plot(fars, center, label=label, linewidth=2, color=another_colors[source_type])
if len(connection.keys()) > 1:
	inj_file = "COMBINED"
ax_far.set_xlabel("Combined FAR (Hz)")
ax_far.set_ylabel(r"Volume $\times$ Time ($\mathrm{Mpc}^3 \mathrm{yr}$)")
ax_far.set_xscale("log")
ax_far.set_yscale("log")
ax_far.set_xlim(fars[[0, -1]])
ax_far.invert_xaxis()
ax_far.legend(loc='upper left', fontsize=8)
ax_far.grid()

vol_tix = ax_far.get_yticks()
tx = ax_far.twinx() # map volume to distance
tx.set_yticks(vol_tix)
tx.set_yscale("log")
tx.set_ylim(ax_far.get_ylim())
tx.set_yticklabels(["%.3g" % ((float(k)/(4.*np.pi*livetime/3.))**(1./3.)) for k in vol_tix])
tx.set_ylabel("Range (Mpc)")
ax_far.set_title("%s Observing (%.2f days)" % (observer, livetime*365.25))
fig_far.tight_layout(pad = .8)
pdf = PdfPages("%s/%s_%s-SEARCH_SENSITIVITY_%s.pdf" %(options.output_dir, observers, observer, inj_file))
pdf.savefig(fig_far)
pdf.close()
pyplot.close(fig_far)
