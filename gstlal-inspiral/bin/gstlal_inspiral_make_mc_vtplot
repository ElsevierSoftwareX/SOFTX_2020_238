#!/usr/bin/env python

import itertools
import matplotlib
matplotlib.use("Agg")
matplotlib.rcParams.update({"text.usetex": True})
from matplotlib import pyplot
pyplot.rc('font',**{'family':'serif','serif':['Computer Modern Roman']})
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
from optparse import OptionParser
import pickle
import sqlite3

import lal
from lal import rate
from ligo import segments
from ligo.lw import ligolw, lsctables, dbtables
from gstlal import plotutil, imr_utils

@lsctables.use_in
class LIGOLWContentHandler(ligolw.LIGOLWContentHandler):
	pass

def parse_command_line():
	parser = OptionParser(description = __doc__)

	# FAR range and resolution
	parser.add_option("--xaxis-points", metavar = "count", default = 50, type = "int", help = "Specify the number of false-alarm rates for which to compute the search volume.  Default is 50.")
	parser.add_option("--min-far", metavar = "Hertz", default = 1.0e-6/lal.YRJUL_SI, type = "float", help = "Specify the minimum false-alarm rate in Hertz.  Default is 1 per million years.") # one per million years is probably detection worthy
	parser.add_option("--max-far", metavar = "Hertz", default = 12.0/lal.YRJUL_SI, type = "float", help = "Specify the maximum false-alarm rate in Hertz.  Default is 1 per month.") # one per month is possibly EM-followup worthy

	# Input data options
	#parser.add_option("--injection-files", metavar = "filename", help = "XML files containing injection list (required). If there is more than one, separate them with :")
	parser.add_option("--injection-database", default = [], action = "append", help = "Name of database containing injection parameters and triggers (required).")
	parser.add_option("--zero-lag-database", default = [], action = "append", help = "Name of database containing the zero lag segments and triggers (required).")
	parser.add_option("--input-dir", default = "gstlal_inspiral_lnlrcdf_signal", metavar = "name", help = "directory of lnlrcdf_signal data")

	# Output data options
	parser.add_option("--output-dir", default = "./", metavar = "name", help = "Select a directory to place output files.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose (optional).")

	options, filenames = parser.parse_args()

	options.injection_database.extend(filenames)
	#required_options = ("injection_files", "injection_database", "zero_lag_database")
	required_options = ("injection_database", "zero_lag_database")
	missing_options = [option for option in required_options if not getattr(options, option)]

	if missing_options:
		raise ValueError("%s must be set" % ", ".join("--%s" % option.replace("_", "-") for option in missing_options))

	return options

###########
#HARD CORD#
###########

#Bin injections by source type: BNS mchirp between 0.8 and 2, NSBH between 2 and 4.5, BBH between 4.5 and 45.0, IMBH between 45.0 and 450.0
bin_types = u"Source_Type"
num_split_inj = 100
source_types = ["bns", "nsbh", "bbh", "imbh"]
mbins = [0.5, 2.0, 4.5, 45., 450]

def filter_injections(inj, source_type, source_types = source_types, mbins = mbins):
	min_mchirp, max_mchirp = mbins[source_types.index(source_type):source_types.index(source_type)+2]
	return inj.mchirp >= min_mchirp and inj.mchirp < max_mchirp

##############
#MAIN PROGRAM#
##############

options = parse_command_line()

fars = np.logspace(np.log10(options.min_far), np.log10(options.max_far), options.xaxis_points)

observer = options.zero_lag_database[0].split("_")[0]
observers, observer = observer.split("-")

#
# Search live time
#
if options.verbose:
	print "Searching livetime"

normal_segments = segments.segmentlistdict()
for f in options.zero_lag_database:
	connection = sqlite3.connect(f)
	normal_segments += imr_utils.get_segments(connection, dbtables.get_xml(connection), "coinc_inspiral", "gstlal_inspiral", "vetoes", "whitehtsegments")
zero_lag_segments = normal_segments.union(normal_segments.keys())
livetime = float(abs(zero_lag_segments))/lal.YRJUL_SI

#
# Search injection data
#
if options.verbose:
	print "Searching injection data"

found_injections_fars = []
total_injections = []
connection = {}
for inj_file_suffix in options.injection_database:
	inj_file = inj_file_suffix.split("-")[1]
	inj_file = inj_file.replace("ALL_LLOID_","")
	connection[inj_file] = sqlite3.connect(inj_file_suffix)
	#found, total, missed = imr_utils.get_min_far_inspiral_injections(connection[inj_file], segments = zero_lag_segments, table_name="coinc_inspiral")
	found, total, missed = imr_utils.get_min_far_inspiral_injections(connection[inj_file], table_name="coinc_inspiral")
	found_injections_fars += found
	total_injections += total

total_injections = imr_utils.symmetrize_sims(total_injections, "mass1", "mass2")

distances = [tup[0] for tup in map(imr_utils.sim_to_distance_chirp_mass_bins_function, total_injections)]
bins = rate.NDBins([rate.LinearBins(min(distances), max(distances), 200), rate.IrregularBins(mbins)])

vols_lo_far, vols_far, vols_hi_far = [], [], []
for k, far in zip(range(options.xaxis_points), fars):
	found_by_far = [s for f, s in found_injections_fars if f < far]
	eff_lo, eff, eff_hi = imr_utils.compute_search_efficiency_in_bins(found_by_far, total_injections, bins, imr_utils.sim_to_distance_chirp_mass_bins_function)
	vol_lo = imr_utils.compute_search_volume(eff_lo)
	vol_lo.array *= livetime
	vols_lo_far.append(vol_lo)

	vol = imr_utils.compute_search_volume(eff)
	vol.array *= livetime
	vols_far.append(vol)

	vol_hi = imr_utils.compute_search_volume(eff_hi)
	vol_hi.array *= livetime
	vols_hi_far.append(vol_hi)

#
# Calc injection rate
#

num_inj = {}
maxdist = {}
mindist = {}
for inj_file in connection:
	xmldoc = dbtables.get_xml(connection[inj_file])
	injs = lsctables.SimInspiralTable.get_table(xmldoc)
	num_inj[inj_file] = dict((source_type, sum(np.pi*4*inj.distance**2 for inj in injs if filter_injections(inj, source_type))) for source_type in source_types)
	params = lsctables.ProcessParamsTable.get_table(xmldoc)
	try:
		max_dist = np.array([param.value for param in params if param.param=="--max-distance"])[0]
		min_dist = np.array([param.value for param in params if param.param=="--min-distance"])[0]
	except IndexError:
		dist = [inj.distance for inj in injs]
		max_dist = max(dist)
		min_dist = min(dist)

	max_dist = float(max_dist)/10**3
	min_dist = float(min_dist)/10**3
	maxdist[inj_file] = max_dist
	mindist[inj_file] = min_dist

volume = dict((inj_file, (4*np.pi/3.)*(maxdist[inj_file]**3 - mindist[inj_file]**3)) for inj_file in connection)
inj_per_VT = dict((source_type, sum(num_inj[inj_file][source_type]/volume[inj_file]/livetime for inj_file in connection)) for source_type in source_types)

#
# Read caluculation data
#
if options.verbose:
	print "reading calculation data"

fig_far = pyplot.figure()
fig_far.set_size_inches((8., 8./plotutil.golden_ratio))
ax_far = fig_far.gca()
colors = {"bns":"b", "nsbh":"g", "bbh":"r", "imbh":"c"}
acolors = {"bns":"darkblue", "nsbh":"darkgreen", "bbh":"darkred", "imbh":"darkcyan"}
for source_type in source_types:
	inj_files = connection.keys()
	SS_lo, SS_mi, SS_hi = 0., 0., 0.
	if inj_per_VT[source_type] == 0.:
		continue
	for inj_file in inj_files:
		SS = sum(np.loadtxt("%s/%s_%04d_%s.txt" %(options.input_dir, inj_file, num, source_type)) for num in range(num_split_inj))
		SS_lo += SS[0]
		SS_mi += SS[1]
		SS_hi += SS[2]
	SS_lo /= inj_per_VT[source_type]
	SS_mi /= inj_per_VT[source_type]
	SS_hi /= inj_per_VT[source_type]
	inj_file = inj_files[0] if len(inj_files) == 1 else "COMBINED"

	#
	# plot injection and calculation result
	#
	if options.verbose:
		print "plotting calculation and injection results"

	#injection
	label = "Injection Result : $M_{\mathrm{chirp}} \in [%.2f, %.2f] \,\mathrm{M}_\odot$" % tuple(mbins[source_types.index(source_type):source_types.index(source_type)+2])
	center = np.array([v.array[source_types.index(source_type)] for v in vols_far])
	lo = np.array([v.array[source_types.index(source_type)] for v in vols_lo_far])
	hi = np.array([v.array[source_types.index(source_type)] for v in vols_hi_far])
	line, = ax_far.plot(fars, center, label=label, linewidth=2, color=colors[source_type])
	ax_far.fill_between(fars, lo, hi, alpha=0.5, color=line.get_color())

	#calculation
	label = "Our Result : $M_{\mathrm{chirp}} \in [%.2f, %.2f] \,\mathrm{M}_\odot$" % tuple(mbins[source_types.index(source_type):source_types.index(source_type)+2])
	line, = ax_far.plot(fars, SS_mi, label=label, linewidth=2, color=acolors[source_type])
	ax_far.fill_between(fars, SS_lo, SS_hi, alpha=0.5, color=line.get_color())
ax_far.set_xlabel("Combined FAR (Hz)")
ax_far.set_ylabel(r"Volume $\times$ Time ($\mathrm{Mpc}^3 \mathrm{yr}$)")
ax_far.set_xscale("log")
ax_far.set_yscale("log")
ax_far.set_xlim(fars[0], fars[-1])
ax_far.invert_xaxis()
ax_far.legend(loc='upper left', fontsize=8)
ax_far.grid()

vol_tix = ax_far.get_yticks()
tx = ax_far.twinx() # map volume to distance
tx.set_yticks(vol_tix)
tx.set_yscale("log")
tx.set_ylim(ax_far.get_ylim())
tx.set_yticklabels(["%.3g" % ((float(k)/(4.*np.pi*livetime/3.))**(1./3.)) for k in vol_tix])
tx.set_ylabel("Range (Mpc)")
ax_far.set_title("%s Observing (%.2f days)" % (observer, livetime*365.25))
fig_far.tight_layout(pad = .8)
pdf = PdfPages("%s/%s_%s-SEARCH_SENSITIVITY_%s.pdf" %(options.output_dir, observers, observer, inj_file))
pdf.savefig(fig_far)
pdf.close()
pyplot.close(fig_far)
