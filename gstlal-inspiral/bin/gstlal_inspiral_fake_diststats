#!/usr/bin/env python
#
# Copyright (C) 2010--2014  Kipp Cannon, Chad Hanna
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
## @file gstlal_ll_inspiral_create_prior_diststats
# A program to create some prior likelihood data to seed an online analysis
#
# ### Command line interface
#
#		--verbose, action = "store_true", help = "Be verbose."
#		--coincidence-threshold, metavar = "value", type = "float", default = 0.005, help = "Set the coincidence window in seconds (default = 0.005).  The light-travel time between instruments will be added automatically in the coincidence test."
#		--min-instruments, metavar = "count", type = "int", default = 2, help = "Set the minimum number of instruments that must contribute triggers to form a candidate (default = 2).
#		--num-templates, metavar = "N", default = 1000, type = "int", help = "Set the number of templates per bank. default 1000")
#		--num-banks, metavar = "N", default = 1, type = "int", help = "Set the number of banks. default 1")
#		--write-likelihood-basename, metavar = "string", default = "prior.xml.gz", help = "Write likelihood files to disk with this basename: default prior.xml.gz.")
#		--write-likelihood-cache, metavar = "filename", help = "Write likelihood files to disk and include the names in this cachefile file.")
#		--write-zerolag-likelihood-cache, metavar = "filename", help = "Write zerolag likelihood files to disk and include the names in this cachefile file.")
#		--segment-and-horizon, action = "append", help = "Append to a list of segments and horizon distances for a given instrument.  Argument specified as IFO:start:end:horizon, e.g., H1:1000000000:1000000100:120 ")
#		--override-background-prior, metavar = "N", type = "float", help = "Override the count in the SNR/chisquared bins to be this value")
#		--injection-prefactors, metavar = "s,e", default = "0.01,0.25", help = "Set the range of prefactors on the chi-squared distribution for the signal model: default 0.01,0.25")

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import itertools
import os
import shutil
import sys
from gstlal import far
from gstlal import inspiral_pipe
from gstlal.stats import horizonhistory
from gstlal import paths as gstlal_config_paths
from gstlal import svd_bank
from glue.ligolw import utils as ligolw_utils
from glue.ligolw.utils import process as ligolw_process
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import array as ligolw_array
from glue.ligolw import param as ligolw_param
from glue import segments
from lal import LIGOTimeGPS
from lal.utils import CacheEntry
from pylal import rate
from optparse import OptionParser

class DefaultContentHandler(ligolw.LIGOLWContentHandler):
	pass
ligolw_array.use_in(DefaultContentHandler)
ligolw_param.use_in(DefaultContentHandler)
lsctables.use_in(DefaultContentHandler)

def parse_command_line():
	parser = OptionParser(
		version = "Name: %%prog\n%s" % "" # FIXME
	)
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	# FIXME:  default must be kept identical to gstlal_inspiral's
	parser.add_option("--coincidence-threshold", metavar = "value", type = "float", default = 0.005, help = "Set the coincidence window in seconds (default = 0.005).  The light-travel time between instruments will be added automatically in the coincidence test.")
	# FIXME:  default must be kept identical to gstlal_inspiral's
	parser.add_option("--min-instruments", metavar = "count", type = "int", default = 2, help = "Set the minimum number of instruments that must contribute triggers to form a candidate (default = 2).")

	parser.add_option("--svd-bank-file", metavar = "File", help = "Set the number of templates per bank. default 1000")
	parser.add_option("--output", metavar = "string", default = "prior.xml.gz", help = "Write likelihood files to disk with this basename: default prior.xml.gz.")
	parser.add_option("--zerolag-output", metavar = "filename", help = "Write zerolag likelihood files to disk and include the names in this cachefile file.")
	parser.add_option("--segment-and-horizon", action = "append", help = "Append to a list of segments and horizon distances for a given instrument.  Argument specified as IFO:start:end:horizon, e.g., H1:1000000000:1000000100:120 ")
	#parser.add_option("--override-background-prior", metavar = "N", type = "float", help = "Override the count in the SNR/chisquared bins to be this value")
	parser.add_option("--injection-prefactors", metavar = "s,e", default = "0.01,0.25", help = "Set the range of prefactors on the chi-squared distribution for the signal model: default 0.01,0.25")
	options, filenames = parser.parse_args()

	process_params = dict(options.__dict__)

	def parse_segment_and_horizon(options = options):
		seglistdict = segments.segmentlistdict()
		horizon_history = {}
		for x in options.segment_and_horizon:
			ifo, start, stop, horizon = x.split(":")
			seglistdict.setdefault(ifo, segments.segmentlist()).append(segments.segment([LIGOTimeGPS(start), LIGOTimeGPS(stop)]))
			horizon_history.setdefault(ifo, horizonhistory.NearestLeafTree())[float(start)] = float(horizon)
			horizon_history.setdefault(ifo, horizonhistory.NearestLeafTree())[float(stop)] = float(horizon)
		return seglistdict, horizon_history

	if options.segment_and_horizon is None:
		raise ValueError("--segment-and-horizon required")
	seglistdict, horizon_history = parse_segment_and_horizon(options)

	options.instruments = frozenset(seglistdict)
	if not options.instruments:
		raise ValueError("must specify at least one instrument")
	if options.min_instruments > len(options.instruments):
		raise ValueError("--min-instruments is greater than number of available instruments")

	banks = svd_bank.read_banks(options.svd_bank_file, contenthandler = DefaultContentHandler, verbose = options.verbose)
	num_templates = sum([len(b.sngl_inspiral_table) for b in banks])
	mchirp = max([max([row.mchirp for row in b.sngl_inspiral_table]) for b in banks])
	return options, process_params, seglistdict, horizon_history, num_templates, mchirp


options, process_params, segs, horizon_history, num_templates, mchirp = parse_command_line()

if options.verbose:
	print >> sys.stderr, "Livetime: ", abs(segs)
	print >> sys.stderr, "Extent: ", segs.extent_all()
	print >> sys.stderr, "Number of templates: ", num_templates
	print >> sys.stderr, "max chirp mass: ", mchirp

#
# quantities derived from input
#

#
# Number of background events in each detector
#
# This is calculated assuming the following
# 1) num_templates in the analysis
# 2) Each template produces exactly 1 trigger for every second that a given
# detector is on according to the user provided segments
#
# FIXME what should zero lag be? Right now we set them to be the same
#

n_trigs = dict(((ifo, float(abs(seg)) * num_templates) for ifo, seg in segs.items())) 

#
# Initialize an empty ThincaCoincParamsDistributions class
#

diststats = far.ThincaCoincParamsDistributions(instruments = set(segs), delta_t = options.coincidence_threshold, min_instruments = options.min_instruments)

#
# Add background, zero_lag and injection prior distributions in the SNR and chi-squared plane
# 

# FIXME make the prefactors adjustable
diststats.add_background_prior(n = n_trigs, prefactors_range = (0.5, 20.), df = 20, inv_snr_pow = 2., ba = "background_rates", verbose = options.verbose)

# fill in the background to the requested amount
for instrument, number_of_events in n_trigs.items():
	diststats.background_rates["singles"][instrument,] = number_of_events
	if options.verbose:
		print "setting number of singles events in %s to %d" % (instrument, number_of_events)

diststats.add_foreground_snrchi_prior(n = dict(((ifo, 1e8) for ifo, seg in segs.items())), prefactors_range = tuple(float(x) for x in options.injection_prefactors.split(",")), verbose = options.verbose)

#
# Update the horizon distance history with our fake, user provided horizon history
#

diststats.horizon_history.update(horizon_history)


#
# Wrap it up
#

diststats.finish(segs = segs, verbose = options.verbose)

#
# Prep an output XML file
#

xmldoc = ligolw.Document()
xmldoc.appendChild(ligolw.LIGO_LW())
process = ligolw_process.register_to_xmldoc(xmldoc, u"gstlal_ll_inspiral_create_prior_diststats", ifos = options.instruments, paramdict = process_params)
far.gen_likelihood_control_doc(xmldoc, process, diststats, None, segs, comment = u"background and signal priors (no real data)")
ligolw_utils.write_filename(xmldoc, options.output, gz = options.output.endswith(".gz"), verbose = options.verbose)
