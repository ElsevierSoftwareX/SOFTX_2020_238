#!/usr/bin/env python

"""
Typical Usages:

Re-calculating GraceDb gstlal candidates. This assumes you are login to LIGO-Caltech Computing Cluster and
all data (svd banks, psd ...) are availible on the gracedb and the cluster. You also need obtain certificate
via "ligo-proxy-init" before using this option. Use --save to save the svd banks and psd to disk.

Example 1:
$ ligo-proxy-init chiwai.chan
$ export GSTLAL_FIR_WHITEN=0
$ gstlal_inspiral_calc_snr \
--gid G348519 \
--observatory H \
--observatory L \
--type H1_HOFT_C00 \
--type L1_HOFT_C00 \
--track-psd \
--outdir . \
--verbose

Example 2:
$ echo "1250471617 1250472600" >> l1segs.txt
$ echo "1250472615 1250473617" >> l1segs.txt
$ ligolw_segments --name framesegments --insert-from-segwizard L1=l1segs.txt --output framesegments.xml
$ ligo-proxy-init chiwai.chan
$ export GSTLAL_FIR_WHITEN=0
$ gstlal_inspiral_calc_snr \
--gid G347846 \
--observatory L \
--frame-segments-file framesegments.xml \
--frame-segments-name framesegments \
--type L1_HOFT_C00 \
--track-psd \
--outdir . \
--verbose

Calculate SNR using LLOID method. You should have access to svd banks and reference psd for this option. For
filter particular template in the svd banks, you should know the --sub-bank-id and the --row-number of the template;
Otherwise, if only --sub-bank-id is provided, SNRs for all templates in the sub-bank will be produced. To limit the
output size, use --start and --end to specify the range of SNR in GPS time.

Example: G348519

Downloaded from /home/gstlalcbc/observing/3/online/svd/new-bank/4_bns/mario/
> H1-GSTLAL_SVD_BANK_258-0-0.xml.gz
> L1-GSTLAL_SVD_BANK_258-0-0.xml.gz
> V1-GSTLAL_SVD_BANK_258-0-0.xml.gz
Downloaded from gracedb candidate event G348519
> psd.xml.gz

$ export GSTLAL_FIR_WHITEN=0
$ python -m gwdatafind --server "datafind.ligo.org:443" --observatory L --type L1_HOFT_C00 --gps-start 1251009527 --gps-end 1251011527 --lal-cache -O L1_FRAME
$ python -m gwdatafind --server "datafind.ligo.org:443" --observatory H --type H1_HOFT_C00 --gps-start 1251009527 --gps-end 1251011527 --lal-cache -O H1_FRAME
$ cat *_FRAME > frame.cache
$ gstlal_inspiral_calc_snr \
--mode 0\
--data-source frames \
--channel-name H1=GDS-CALIB_STRAIN \
--channel-name L1=GDS-CALIB_STRAIN \
--frame-cache frame.cache \
--gps-start-time 1251009527 \
--gps-end-time 1251009527 \
--reference-psd psd.xml.gz \
--track-psd \
--svd-bank H1:H1-GSTLAL_SVD_BANK_258-0-0.xml.gz,L1:L1-GSTLAL_SVD_BANK_258-0-0.xml.gz,V1:V1-GSTLAL_SVD_BANK_258-0-0.xml.gz \
--sub-bank-id 0 \
--row-number 203 \
--instrument H1 \
--instrument L1 \
--outdir outputs \
--start 1251010522 \
--end 1251010532 \
--verbose


Calculate SNR using Finite Impulse Response. Typically, you won't use this option unless you simply want to calculate SNR for one particular
template and you don't have access to the corresponding svd bank which contains the template. To use this option, You should have a XML file
containing one sngl_inspiral table, the backend of generating template is through cbc_template_fir, see cbc_template_fir to see what parameters
are necessary to generate template. To limit the output size, use --start and --end to specify the range of SNR in GPS time.

Example: G348519

Downloaded from gracedb candidate event G348519
> psd.xml.gz

$ export GSTLAL_FIR_WHITEN=0
$ cp /home/ryan.magee/observing/3/psds/190509/cleaned/H1L1V1psd_new.xml.gz .
$ python -m gwdatafind --server "datafind.ligo.org:443" --observatory L --type L1_HOFT_C00 --gps-start 1251009527 --gps-end 1251011527 --lal-cache -O L1_FRAME
$ python -m gwdatafind --server "datafind.ligo.org:443" --observatory H --type H1_HOFT_C00 --gps-start 1251009527 --gps-end 1251011527 --lal-cache -O H1_FRAME
$ cat *_FRAME > frame.cache
$ python
>> from gstlal import svd_bank_snr
>> svd_bank_snr.FIR_SNR.make_simplified_sngl_inspiral_table(30.383705, 12.924967, 0, 0, -0.24138632, 0, 0, 0.6948265)
$ gstlal_inspiral_calc_snr \
--mode 1\
--data-source "frames" \
--channel-name H1=GDS-CALIB_STRAIN \
--channel-name L1=GDS-CALIB_STRAIN \
--frame-cache frame.cache \
--gps-start-time 1251009527 \
--gps-end-time 1251011527 \
--reference-psd ./psd.xml.gz \
--track-psd \
--table template.xml.gz \
--approximant SEOBNRv4_ROM \
--sample-rate 2048 \
--template-psd ./H1L1V1psd_new.xml.gz \
--f-low 15 \
--instrument H1 \
--instrument L1 \
--start 1251010522 \
--end 1251010532 \
--outdir ./outputs \

"""
import numpy
from optparse import OptionParser, OptionGroup, IndentedHelpFormatter
import os

from gstlal import datasource
from gstlal import inspiral
from gstlal import pipeparts
from gstlal import reference_psd
from gstlal import svd_bank
from gstlal import svd_bank_snr

import lal
import lal.series

from ligo.lw import ligolw
from ligo.lw import utils as ligolw_utils
from ligo.lw import param as ligolw_param
from ligo.lw import array as ligolw_array
from ligo.lw import lsctables
from ligo.lw import table
from ligo.lw.utils import segments as ligolw_segments

@ligolw_param.use_in
@ligolw_array.use_in
@lsctables.use_in
class ContentHandler(ligolw.LIGOLWContentHandler):
	pass

@lsctables.use_in
class LIGOLWContentHandler(ligolw.LIGOLWContentHandler):
	pass

# disable mkchecktimestamps()
# FIXME:  python plugin broken until we switch to Python 3
pipeparts.mkchecktimestamps = lambda pipeline, src, *args: src

class epilogFormatter(IndentedHelpFormatter):
	def format_epilog(self, epilog):
		if epilog:
			return epilog + "\n"
		else:
			return ""

def parse_command_line():
	parser = OptionParser(formatter = epilogFormatter(), description = "Using gstlal inspiral pipeline to calculate SNR for template(s)", epilog = __doc__)

	datasource.append_options(parser)

	group = OptionGroup(parser, "Whiten / PSD Options", "Adjust noise spectrum estimation parameter")
	group.add_option("--reference-psd", metavar = "filename", help = "Load noise spectrum from LIGO light-weight XML file (optional).")
	group.add_option("--psd-fft-length", metavar = "seconds", default = 32, type = "int", help = "Length of the FFT used to whiten strain data (default = 32 s).")
	group.add_option("--track-psd", action = "store_true", help = "Enable dynamic PSD tracking. Enabled by default if --reference-psd is not given.")
	group.add_option("--zero-pad", metavar = "seconds", default = 0, type = "int", help = "The zero padding of the Hanning window in seconds (default = 0).")
	group.add_option("--average-samples", default = 64, type = "int", help = "The number of samples used to estimate the average value of the PSD")
	group.add_option("--median-samples", default = 7, type = "int", help = "The number of samples used to estimate the median value of the PSD")
	parser.add_option_group(group)

	group = OptionGroup(parser, "Template Options", "Choose a template from a SVD bank file / a single SnglInspiral Table")
	group.add_option("--svd-bank", metavar = "filename", help = "A LIGO light-weight xml / xml.gz file containing svd bank information. These can be given as a comma separated list such as H1:file1,H2:file2,L1:file3 to analyze multiple instruments (require)." )
	group.add_option("--coinc", metavar = "filename", help = "The coinc.xml file associated with --svd-bank. This is used to find the --sub-bank-id and --row-number for a particular event. If given, the --sub-bank-id and --row-number will be overwritten. (optional)")
	group.add_option("--sub-bank-id", type = "int", help = "Bank id is of the form <int>ID_<int>N where N is the sub bank id. (require).")
	group.add_option("--row-number", type = "int", help = "The row number of the template (optional). All the SNRs will be outputed if it is not given.")
	group.add_option("--table", metavar = "filename", help = "A LIGO light-weight xml.gz file containing SnglInspiral Table. Expecting one template only.")
	group.add_option("--approximant", metavar = "name", type = "str", help = "Name of the Waveform model (require).")
	group.add_option("--sample-rate", metavar = "Hz", default = 2048, type = "int", help = "Sampling rate of the template and SNR for mode 1")
	group.add_option("--f-low", metavar = "Hz", default = 10, type = "float", help = "The minimum frequency of GW signal")
	group.add_option("--f-high", metavar = "Hz", type = "float", help = "The maximum frequency of GW signal")
	group.add_option("--template-psd", metavar = "filename", help = "The psd for whitening template (require).")
	parser.add_option_group(group)

	group = OptionGroup(parser, "Data Quality Options", "Adjust data quality handling")
	group.add_option("--ht-gate-threshold", metavar= "sigma", type = "float", default = float("inf"), help = "Set the threshold on whitened h(t) to excise glitches in units of standard deviation (defalut = inf). ")
	group.add_option("--veto-segments-file", metavar = "filename", help = "Set the name of the LIGO light-weight XML file from which to load vetoes (optional).")
	group.add_option("--veto-segments-name", metavar = "name", default = "vetoes", help = "Set the name of the LIGO light-weight XML file from which to load vetoes (default = 'veto') (optional).")
	parser.add_option_group(group)

	group = OptionGroup(parser, "GraceDb Event Options", "Produce SNR time series for gstlal gracedb event.")
	group.add_option("--gid", metavar = "gracedb event id", type = "str", help = "The gracedb event id.")
	group.add_option("--observatory", metavar = "OBS", type = "str", action = "append", help = "Name of the observatory (H,L,V ...), also see gwdatafind.")
	group.add_option("--type", metavar = "frame type", type = "str", action = "append", help = "Name of the observatory (H,L,V ...), also see gwdatafind.")
	group.add_option("--time-span", metavar = "seconds", type = "int", default = 1000, help = "The time span around the event's trigger time, must be larger or equal to 1000s (default = 1000).")
	parser.add_option_group(group)

	group = OptionGroup(parser, "Output Control Options", "Control SNR output")
	group.add_option("--outdir", metavar = "directory", default = ".", type = "str", help = "Output directory for SNR(s) (default = .).")
	group.add_option("--save", action = "store_true", default = False, help = "Save frame cache / svd bank / psd (default = False).")
	group.add_option("--mode", metavar = "method", type = "int", default = 0, help = "The method (0 = LLOID / 1 = FIR) that is used to calculate SNR (default = 0).")
	group.add_option("--complex", action = "store_true", help = "Choose whether to output the complex snr or not.")
	group.add_option("--start", metavar = "seconds", type = "float", help = "Start SNR time series at GPS time '--start' (require).")
	group.add_option("--end", metavar = "seconds", type = "float", help = "End SNR time series at GPS time '--end' (require).")
	group.add_option("--output-width", metavar = "bits", type = "int", default = 32, help = "The size of the output data, can only be 32 or 64 bits (default = 32 bits).")
	group.add_option("--instrument", metavar = "name", type = "str", action = "append", help = "The instrument(s) to be analyzed(require).")
	parser.add_option_group(group)

	parser.add_option("--verbose", action = "store_true", help = "Be verbsoe.")

	options, args = parser.parse_args()

	# initialize gw_data_source_info
	gw_data_source_info = None

	if options.outdir is None:
		missing_required_options.append("--outdir")
	# Setting up GW data
	if options.gid is not None:
		# Setting up inputs for GraceDb event, this will overwrite svd-bank/template/psd related inputs.
		if options.observatory is None or options.type is None:
			raise ValueError("When using --gid, --observatory and --type must be provided.")
		else:
			gwdata_metavars = svd_bank_snr.framecache_from_event(options.gid, options.observatory, options.type, time_span = options.time_span, outdir = options.outdir, verbose = options.verbose)
			# We can hardcoded here, since we know all the information from gracedb.
			# This assume everything on the gracedb are correct and complete which could go wrong in the future.
			# (e.g files are deleted)
			options.data_source = "frames"
			options.frame_cache = os.path.join(options.outdir, "frame.cache")
			options.gps_start_time = gwdata_metavars["gps_start_time"][0]
			options.gps_end_time = gwdata_metavars["gps_end_time"][0]
			options.channel_name = gwdata_metavars["channels_name"]
			options.instrument = gwdata_metavars["instruments"]
			gw_data_source_info = datasource.GWDataSourceInfo(options)

			# FIXME: Adjustable parameters, hardcoded here for simplicity.
			trigger_time = min(gwdata_metavars["trigger_times"])
			options.start = trigger_time - 5
			options.end = trigger_time + 5

			# It must be using LLOID
			options.mode = 0

			psds_dict = svd_bank_snr.psd_from_event(options.gid, save = options.save, verbose = options.verbose)

			banks_dict, options.sub_bank_id, options.row_number = svd_bank_snr.svd_banks_from_event(options.gid, save = options.save, verbose = options.verbose)

			return options, gw_data_source_info, banks_dict, psds_dict
	else:
		# Setting up GW data for non-GraceDb event
		gw_data_source_info = datasource.GWDataSourceInfo(options)
		# Setting up how many instruments to analyze
		if options.instrument is not None:
			# Avoid repeated --instrument
			options.instrument = list(set(options.instrument))
		else:
			raise ValueError("Must provide at least one --instrument.")
		# Check if --frame-cache contains the data from --instrument
		for instrument in options.instrument:
			if instrument not in gw_data_source_info.channel_dict.keys():
				raise ValueError("No such instrument: %s in GWDataSourceInfo: (%s)"% (instrument, ", ".join(gw_data_source_info.channel_dict.keys())))

	# Check SNRs series output
	if options.start is None or options.end is None:
		raise ValueError("Must have --start and --end.")
	elif options.start >= options.end:
		raise ValueError("--start must less than --end.")
	# Extra handle for SNRs output because SNRs are not stable initially and have padding at the end
	# FIXME: the 50s is hardcoded and only use to avoid snr being unstable due to edge effect when doing convoluion
	if options.start - gw_data_source_info.seg[0] <= 50 or gw_data_source_info.seg[1] - options.end <= 50:
		raise ValueError("Check your inputted --start / --end or your frame file. You should have a long enough data such that, the --start/--end is larger/less than the start/end of your data at least 50s. ")

	# Setting up PSD
	if options.reference_psd:
		psd = lal.series.read_psd_xmldoc(ligolw_utils.load_url(options.reference_psd, contenthandler = lal.series.PSDContentHandler))
		# Check if --reference-psd contains the psd from --instrument
		for instrument in options.instrument:
			if instrument not in set(psd):
				raise ValueError("No such instrument: %s in psd: (%s)"% (instrument, ", ".join(set(psd))))
	else:
		options.track_psd = True

	# Use LLOID method
	if options.mode == 0:
		missing_required_options = []
		# Checking required options
		if options.svd_bank is None:
			missing_required_options.append("--svd-bank")
		if options.sub_bank_id is None and options.coinc is None:
			missing_required_options.append("--sub-bank-id")
		# Raise VauleError is required option(s) is/are missing
		if missing_required_options:
			raise ValueError("Missing required option(s) %s" % ", ".join(sorted(missing_required_options)))

		# Setting up SVD bank
		bank_urls = inspiral.parse_svdbank_string(options.svd_bank)
		# Check if --svd-bank contains svd banks from --instrument
		for instrument in options.instrument:
			if instrument not in set(bank_urls):
				raise ValueError("No SVD Banks for --instrument=%s." % instrument)

		banks_dict = dict([(ifo, svd_bank.read_banks(svdbanks, svd_bank.DefaultContentHandler)) for ifo, svdbanks in bank_urls.items()])

		# Scan for the --sub-bank-id and --row-number if --coinc is given
		if options.coinc is not None:
			coinc_xmldoc = ligolw_utils.load_url(options.coinc, verbose = options.verbose, contenthandler = ContentHandler)
			options.sub_bank_id, options.row_number = svd_bank_snr.scan_svd_banks_for_row(coinc_xmldoc, banks_dict)
		# Check if --sub-bank-id and --row-number is valid
		for banks in banks_dict.values():
			if not (0 <= options.sub_bank_id < len(banks)) :
				raise ValueError("Invaild --sub-bank-id %d. Possible id [0-%d)\n" % (options.sub_bank_id, len(banks)))
			if options.row_number is not None and not (0 <= options.row_number < len(banks[options.sub_bank_id].sngl_inspiral_table)):
				raise ValueError("No such template: Invaild --row-number %d. Possible range [0-%d)\n" % (options.row_number, len(banks[options.sub_bank_id].sngl_inspiral_table)))

		return options, gw_data_source_info, banks_dict, psd

	# Use Finite Impulse Response
	elif options.mode == 1:
		missing_required_options = []
		# Checking required options
		if options.table is None:
			missing_required_options.append("--table")
		if options.approximant is None:
			missing_required_options.append("--approximant")
		if options.template_psd is None:
			missing_required_options.append("--template-psd")
		# Raise VauleError is required option(s) is/are missing
		if missing_required_options:
			raise ValueError("Missing required option(s) %s" % ", ".join(sorted(missing_required_options)))

		xmldoc = ligolw_utils.load_url(options.table, contenthandler = ContentHandler, verbose = options.verbose)
		template_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)

		return options, gw_data_source_info, template_table, psd

	# Unknown mode
	else:
		raise ValueError("Invalid mode: %d" % options.mode)

options, gw_data_source_info, template, psds_dict  = parse_command_line()

if options.veto_segments_file is not None:
	veto_segments = ligolw_segments.segmenttable_get_by_name(ligolw_utils.load_filename(options.veto_segments_file, verbose = options.verbose, contenthandler = LIGOLWContentHandler), options.veto_segments_name).coalesce()
else:
	veto_segments = None

#====================================================================================================
#
#						main
#
#====================================================================================================

if options.mode == 0:
	banks_dict = template

	for instrument in options.instrument:
		lloid_snr = svd_bank_snr.LLOID_SNR(
			gw_data_source_info,
			banks_dict[instrument][options.sub_bank_id],
			instrument,
			options.row_number,
			options.start,
			options.end,
			psd = psds_dict,
			psd_fft_length = options.psd_fft_length,
			ht_gate_threshold = options.ht_gate_threshold,
			veto_segments = veto_segments,
			track_psd = options.track_psd,
			width = options.output_width,
			verbose = options.verbose
		)
		snrdict = {}
		if options.row_number is None:
			snrdict.setdefault(instrument, [])
			for index, snr in enumerate(lloid_snr(COMPLEX = options.complex)):
				snr.epoch += banks_dict[instrument][options.sub_bank_id].sngl_inspiral_table[index].end
				snrdict[instrument].append(snr)
			svd_bank_snr.write_url(svd_bank_snr.make_xmldoc(snrdict), os.path.join(options.outdir, "%s-SVD_BANK_SNR_%d-%d-%d.xml.gz" % (instrument, options.sub_bank_id, int(snr.epoch), int(snr.data.length * snr.deltaT))), verbose = options.verbose)
		else:
			snrdict = {instrument : lloid_snr(COMPLEX = options.complex)}
			snrdict[instrument][0].epoch += banks_dict[instrument][options.sub_bank_id].sngl_inspiral_table[options.row_number].end
			svd_bank_snr.write_url(svd_bank_snr.make_xmldoc(snrdict), os.path.join(options.outdir, "%s-SVD_BANK_SNR_%d_%d-%d-%d.xml.gz" % (instrument, options.sub_bank_id, options.row_number, int(snrdict[instrument][0].epoch), int(snrdict[instrument][0].data.length * snrdict[instrument][0].deltaT))), verbose = options.verbose)

elif options.mode == 1:
	template_table = template

	for instrument in options.instrument:
		template, time_offset = svd_bank_snr.FIR_SNR.make_template(template_table, options.template_psd, options.sample_rate, options.approximant, instrument, options.f_low, f_high = options.f_high, verbose = options.verbose)

		#FIXME: proper handle for latency
		fir_snr = svd_bank_snr.FIR_SNR(
			gw_data_source_info,
			template,
			instrument,
			options.sample_rate,
			0,
			options.start,
			options.end,
			psd = psds_dict,
			psd_fft_length = options.psd_fft_length,
			ht_gate_threshold = options.ht_gate_threshold,
			veto_segments = veto_segments,
			width = options.output_width,
			track_psd = options.track_psd,
			verbose = options.verbose
			)

		firsnr = fir_snr(COMPLEX = options.complex)
		snrdict = {instrument : firsnr}
		snrdict[instrument][0].epoch += time_offset
		svd_bank_snr.write_url(svd_bank_snr.make_xmldoc(snrdict),os.path.join(options.outdir, "%s-FIR_SNR-%d-%d.xml.gz" % (instrument, int(snrdict[instrument][0].epoch), int(snrdict[instrument][0].data.length * snrdict[instrument][0].deltaT))), verbose = options.verbose)
