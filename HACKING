=================
Hacking on gstlal
=================


This file is meant as a starting point for gstlal development.


Handling errors in element plugins
==================================

If you are developing a GStreamer element, you should know of at least three
different ways to handle error conditions, and when to use each of them.

* Logging subsystem: ``GST_ERROR_OBJECT``, ``GST_WARNING_OBJECT``, ``GST_INFO_OBJECT``
  
  Use these macros to produce informative text of varying levels of urgency.
  These should be used when you want to inform the user or other developers of
  unusual, but not irrecoverable or dangerous, conditions.

  For example, if you are writing a chain() routine, the following idiom is
  customary::
  
    res = gst_pad_push (GST_BASE_TRANSFORM_SRC_PAD (resample), outbuf);
    
	if (G_UNLIKELY (res != GST_FLOW_OK))
      GST_WARNING_OBJECT (resample, "Failed to push drain: %s", gst_flow_get_name (res));
	return res;

  See <http://library.gnome.org/devel/gstreamer/unstable/gstreamer-GstInfo.html>.

* GError error reporting: ``GST_ELEMENT_ERROR``
  
  Use this macro to report a fatal error.  Calling GST_ELEMENT_ERROR will bring
  the pipeline to a screeching halt, and a GstMessage of type GST_MESSAGE_ERROR
  will be sent to the application via the bus.

  An example invocation::
    
	GST_ELEMENT_ERROR(element, RESOURCE, SEEK, ("XLALFrSeek() to %d.%09u s failed", epoch.gpsSeconds, epoch.gpsNanoSeconds), ("%s", XLALErrorString(XLALGetBaseErrno())));

  See <http://www.gstreamer.net/data/doc/gstreamer/head/gstreamer/html/gstreamer-GstGError.html>.

* Glib assertions: ``g_assert``, etc.
  
  Use these macros to check for programming errors only.  Assertions are useful
  for checking preconditions, but should not be used for everyday error reporting.
  An assertion ulimately results in a call to ``abort()``.

  See <http://library.gnome.org/devel/glib/stable/glib-Testing.html>.


Writing elements in Python
==========================

GStreamer fully supports Python elements in all GStreamer-enabled applications.

Advantages:

* Develop elements in Python first, to get the logic right, then port them to C
  when time permits and performance demands its.

* Write less boilerplate code: it is easier to write a class in Python than in
  native C under glib/gobject.

* Avoid writing code to handle common error conditions (out of memory, failed to
  push tags, type mismatch, etc.).  PyGST checks return values generates
  exceptions.

* Take advantage of Python's powerful introspection, collection data types,
  string processing, and database handling within your elements.

* Create beautiful realtime plots.  Embed matplotlib code directly in elements
  to build interactive visualizations: spectrum analyzers, digital storage 
  oscilloscopes, pulse count analyzers, histograms -- whatever you can dream up!


Here is how it works:

1. GStreamer looks in each directory on the plugin path (a combination of 
   $GST_PLUGIN_PATH, $GST_PLUGIN_SYSTEM_PATH, ~/.gstreamer-0.10/plugins)
   for a subdirectory named "python".

2. For each "python" directory, it looks for all files ending in ".py".

3. For each ".py" file, it attempts to import that file as a module in a
   subinterpreter.

4. If successful, it looks for a module-level variable '__gstelementfactory__'.
   If it is defined, it should be a tuple consisting of the element name, 
   the rank for autoplugging, and the Python class that implements the element.
   This usually looks something like::
   
     __gstelementfactory__ = ('lal_foobarmux', gst.RANK_NONE, lal_foobarmux)

5. If this variable exists, then GStreamer registers the element.  It is now
   a card-carrying member of your plugin registry, and can be used in any
   context where elements can normally used: you can use it in gst-launch
   invocations, you can gst-inspect it, or even use it from any native C
   gstreamer application.


Caveats
-------

* All Pythonic elements are currently lumped under a single plugin, "python".


Tips and tricks
---------------

Notice that in the source release the Python elements are in the directory
"src/plugins/python".  Rest assured that they will be installed into your 
prefix in the normal place "lib/gstreamer-0.10/python".  However, if you are
hacking on one of these elements, you can set the ``GST_PLUGIN_PATH``
environment variable to "src/plugins" in order to avoid having to
``make install`` every time you want to test a change.  Here's how::
  
  $ cd src/plugins
  $ export GST_PLUGIN_PATH=$PWD
 
